
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.3/font/bootstrap-icons.css">
  <style>
    div[class='buttons'] {
      margin-top:8px;
      float: left;
      white-space: nowrap;
    }
    input[class='square'] {
      padding: 0;
      width: 150%;
      height: 150%;
      margin: -25%;
    }
    .cp_wrapper {
      overflow: hidden;
      width: 36px;
      height: 36px;
      border-radius: 0%;
      display:inline-block;
    }
    div[id='gridbox'] {
      display:none;
      position:absolute;
      width:500px;
      top:50px;
      left:14px;
      background-color:#aaa;
      padding:8px 8px 8px 8px;
    }
    td {
      white-space: nowrap;
    }
    body {background-color:#ccc;}
    button {background-color:#fff;
     border:none;
     border-radius:4px;
     min-width:24px;
     padding:4px 4px 2px 4px;
    }
    select {width:100px;}
    select[id='palettechoice'] {
      width:7em;
    }
    select[id='smooth'] {
      width:3em;
    }
    input, img, span, a{
      vertical-align: middle;
    }
    i {
      font-size: 12px;
    }
    input[id='lower'] {
     -webkit-transform: rotateY(180deg);
     -moz-transform: rotateY(180deg);
     -ms-transform: rotateY(180deg);
     -o-transform: rotateY(180deg);
     transform: rotateY(180deg);
    }
    #lower{
      transform: rotateY(180deg);
    }
    span[id='pointsta']
    {
      font-size:1em;
      display:inline-block;
      vertical-align:baseline;
    }
    textarea
    {
      font-size:1em;
      display:inline-block;
      vertical-align:middle;
      width:180px;
    }
    input[type='text'] {
      width: 114px;
    }
    input[type='number'] {
      width: 50px;
    }
    span[class='sample'] {
      display:inline-block;
      width:32px;
      text-align:right;
    }
    input[type='color'] {
      display:inline-block;
      vertical-align: baseline;
    }
    canvas[id='palettecanvas'] {
      margin:2px;
      border-style: solid;
      border-color: black;
      border-width: 1px;
    }
    div[id=tip] {
      position:absolute;
      top:160px;
      left:24px;
      color:#c00;
      display: none;
      background-color: #fff;
      border:3px solid #222222;
      padding:8px;
      font-size:24px;
      z-index:2;
    }
    div[id='background'] {
      background-color: #ffffff;
      opacity: 1.0;
      background-image:  repeating-linear-gradient(45deg, #aaaaaa 25%, transparent 25%, transparent 75%, #aaaaaa 75%, #aaaaaa), repeating-linear-gradient(45deg, #aaaaaa 25%, #ffffff 25%, #ffffff 75%, #aaaaaa 75%, #aaaaaa);
      background-position: 0 0, 10px 10px;
      background-size: 20px 20px;
    }
    svg {background-color:#ccc;}
    svg[class=white] { background-color:#fff;}
  </style>
  
  <script src="pantone.js"></script>
  <script src="wordlist2.js"></script>
  <script src="ptwords.js"></script>
  <script src="drawings.js"></script>
  <script src="mouse-paper.js"></script>

  </head>
  <body>
    
  <div style='margin:4px;white-space: nowrap;'>
    &nbsp;&nbsp;<a href="javascript:showtools()" title="show tools"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="black" class="bi bi-sliders" viewBox="0 0 16 16">
    <path fill-rule="evenodd" d="M11.5 2a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3zM9.05 3a2.5 2.5 0 0 1 4.9 0H16v1h-2.05a2.5 2.5 0 0 1-4.9 0H0V3h9.05zM4.5 7a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3zM2.05 8a2.5 2.5 0 0 1 4.9 0H16v1H6.95a2.5 2.5 0 0 1-4.9 0H0V8h2.05zm9.45 4a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3zm-2.45 1a2.5 2.5 0 0 1 4.9 0H16v1h-2.05a2.5 2.5 0 0 1-4.9 0H0v-1h9.05z"/>
  </svg></a>
  &nbsp;<input type='file' name='img' size='65' id='uploadimage' style="display:none;">
    <span onclick="openFile()" id="imgloader" title="open image file..."><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="black" class="bi bi-upload" viewBox="0 0 16 16">
      <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
      <path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708l3-3z"/>
    </svg></span>
  &nbsp;
  <a href="#" id="downloader" onclick="saveAs()" download="image.png" title="save as png file"
  ><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="black" class="bi bi-download" viewBox="0 0 16 16">
    <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
    <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
  </svg></a>
  &nbsp;
  
  <span class="cp_wrapper">
  <input type="color" id="paintcolor" onchange="paintcolorChange()" class="square" style="margin-bottom:6px;" value="#ffffff">
  </span>
  &nbsp;
  <!--a href="javascript:randomPickColor()" title='random color'>
  <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="black" class="bi bi-palette" viewBox="0 0 16 16">
    <path d="M8 5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3zm4 3a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3zM5.5 7a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm.5 6a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z"/>
    <path d="M16 8c0 3.15-1.866 2.585-3.567 2.07C11.42 9.763 10.465 9.473 10 10c-.603.683-.475 1.819-.351 2.92C9.826 14.495 9.996 16 8 16a8 8 0 1 1 8-8zm-8 7c.611 0 .654-.171.655-.176.078-.146.124-.464.07-1.119-.014-.168-.037-.37-.061-.591-.052-.464-.112-1.005-.118-1.462-.01-.707.083-1.61.704-2.314.369-.417.845-.578 1.272-.618.404-.038.812.026 1.16.104.343.077.702.186 1.025.284l.028.008c.346.105.658.199.953.266.653.148.904.083.991.024C14.717 9.38 15 9.161 15 8a7 7 0 1 0-7 7z"/>
  </svg></a-->
  
  <a href="javascript:stack_fill()" title="fill"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="black" class="bi bi-bucket" viewBox="0 0 16 16">
    <path d="M2.522 5H2a.5.5 0 0 0-.494.574l1.372 9.149A1.5 1.5 0 0 0 4.36 16h7.278a1.5 1.5 0 0 0 1.483-1.277l1.373-9.149A.5.5 0 0 0 14 5h-.522A5.5 5.5 0 0 0 2.522 5zm1.005 0a4.5 4.5 0 0 1 8.945 0H3.527zm9.892 1-1.286 8.574a.5.5 0 0 1-.494.426H4.36a.5.5 0 0 1-.494-.426L2.58 6h10.838z"/>
  </svg></a>
  &nbsp;
  
  &nbsp;<a href="javascript:toggleGridBox()"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="black" class="whitex" style="padding:4px;" viewBox="0 0 18 18">
    <path d="M0 1.5A1.5 1.5 0 0 1 1.5 0h13A1.5 1.5 0 0 1 16 1.5v13a1.5 1.5 0 0 1-1.5 1.5h-13A1.5 1.5 0 0 1 0 14.5v-13zM1.5 1a.5.5 0 0 0-.5.5V5h4V1H1.5zM5 6H1v4h4V6zm1 4h4V6H6v4zm-1 1H1v3.5a.5.5 0 0 0 .5.5H5v-4zm1 0v4h4v-4H6zm5 0v4h3.5a.5.5 0 0 0 .5-.5V11h-4zm0-1h4V6h-4v4zm0-5h4V1.5a.5.5 0 0 0-.5-.5H11v4zm-1 0V1H6v4h4z"/>
    </svg></a>
  
    &nbsp;<a href="javascript:stack_drawD()"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="black" class="whitex" style="padding:4px;" viewBox="0 0 18 18">
    <path d="M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168l10-10zM11.207 2.5 13.5 4.793 14.793 3.5 12.5 1.207 11.207 2.5zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293l6.5-6.5zm-9.761 5.175-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325z"/>
  </svg></a>
  
  <a href='javascript:togglerecord()' id="record" ><svg xmlns="http://www.w3.org/2000/svg" id="recordsvg" width="30" height="30" fill="black" class="nope" viewBox="0 0 16 16">
  <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
  <path d="M11 8a3 3 0 1 1-6 0 3 3 0 0 1 6 0z"/>
  </svg></a>
  &nbsp;
  <a href='javascript:playFunctions()' id="play" title="play recorded macro (when red)"><svg xmlns="http://www.w3.org/2000/svg" id="playsvg" width="30" height="30" fill="#707070" class="bi bi-bucket" viewBox="0 0 16 16">
    <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
    <path d="M6.271 5.055a.5.5 0 0 1 .52.038l3.5 2.5a.5.5 0 0 1 0 .814l-3.5 2.5A.5.5 0 0 1 6 10.5v-5a.5.5 0 0 1 .271-.445z"/>
    </svg></a>
  &nbsp;
  <a href='javascript:stackToCode()' id="code" title="shoe code for macro">
  <svg xmlns="http://www.w3.org/2000/svg" id="codesvg" width="30" height="30" fill="#707070" class="bi bi-code-slash" viewBox="0 0 16 16">
  <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z" id="path2" />
  <path d="M 9.9648918,2.9107776 A 0.40719501,0.40719501 0 1 0 9.1864797,2.6713915 L 5.9295257,13.256492 a 0.40719497,0.40719497 0 0 0 0.778412,0.239386 z M 5.3856144,4.9455597 a 0.40711925,0.40711925 0 0 1 0,0.5764808 L 2.8232058,8.0836348 5.3856144,10.645229 A 0.40763355,0.40763355 0 0 1 4.8091336,11.22171 L 1.9592987,8.3718753 a 0.40711925,0.40711925 0 0 1 0,-0.5764809 L 4.8091336,4.9455597 a 0.40711925,0.40711925 0 0 1 0.5764808,0 z m 5.1231886,0 a 0.40711925,0.40711925 0 0 0 0,0.5764808 l 2.562409,2.5615943 -2.562409,2.5615942 a 0.40763362,0.40763362 0 0 0 0.576481,0.576481 l 2.849835,-2.8498347 a 0.40711925,0.40711925 0 0 0 0,-0.5764809 L 11.085284,4.9455597 a 0.40711925,0.40711925 0 0 0 -0.576481,0 z"
  id="path4" style="stroke-width:0.96;stroke-miterlimit:4;stroke-dasharray:none" /></svg></a>

  &nbsp;
  <a href="javascript:stack_clearOff()" title="clear offscreen">
    <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="black" class="bi bi-clipboard-x" viewBox="0 0 16 16">
    <path fill-rule="evenodd" d="M6.146 7.146a.5.5 0 0 1 .708 0L8 8.293l1.146-1.147a.5.5 0 1 1 .708.708L8.707 9l1.147 1.146a.5.5 0 0 1-.708.708L8 9.707l-1.146 1.147a.5.5 0 0 1-.708-.708L7.293 9 6.146 7.854a.5.5 0 0 1 0-.708z"/>
    <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/>
    <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/>
  </svg></a>
  &nbsp;
  <span onclick="stack_copyToOff()" id="copybutton" title="copy canvas offscreen"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="black" class="bi bi-clipboard" viewBox="0 0 16 16">
    <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/>
    <path d="M8 5a.5.5 0 0 1 .5.5v3.793l1.146-1.147a.5.5 0 0 1 .708.708l-2 2a.5.5 0 0 1-.708 0l-2-2a.5.5 0 1 1 .708-.708L7.5 9.293V5.5A.5.5 0 0 1 8 5z"/>
    <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/>
  </svg></span>
  &nbsp;
   <span onclick="stack_pasteFromOff()" id="pastebutton" title="paste from offscreen"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="black" class="bi bi-clipboard" viewBox="0 0 16 16">
    <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/>
    <path d="M8 11a.5.5 0 0 0 .5-.5V6.707l1.146 1.147a.5.5 0 0 0 .708-.708l-2-2a.5.5 0 0 0-.708 0l-2 2a.5.5 0 1 0 .708.708L7.5 6.707V10.5a.5.5 0 0 0 .5.5z"/>
    <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/>
  </svg></span>
  &nbsp;
  <span onclick="stack_swapWithOff()" id="swapbutton" title="swap with offscreen"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="black" class="bi bi-clipboard" viewBox="0 0 16 16">
    <path
       d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"
       id="path2" />
    <path
       style="stroke-width:1.875"
       d="M 14.988281 9.3730469 A 0.9375 0.9375 0 0 0 14.634766 9.4492188 A 0.9375 0.9375 0 0 0 14.632812 9.4492188 A 0.9375 0.9375 0 0 0 14.34375 9.640625 C 14.336265 9.6477388 14.329505 9.6547598 14.322266 9.6621094 L 10.585938 13.398438 A 0.93868425 0.93868425 0 0 0 11.914062 14.726562 L 14.0625 12.576172 L 14.0625 19.421875 L 11.914062 17.271484 A 0.93868425 0.93868425 0 1 0 10.585938 18.599609 L 14.322266 22.335938 C 14.329505 22.343287 14.336265 22.350308 14.34375 22.357422 A 0.9375 0.9375 0 0 0 15.664062 22.349609 L 19.414062 18.599609 A 0.93868425 0.93868425 0 0 0 18.085938 17.271484 L 15.9375 19.421875 L 15.9375 12.576172 L 18.085938 14.726562 A 0.93868425 0.93868425 0 0 0 19.414062 13.398438 L 15.664062 9.6484375 A 0.9375 0.9375 0 0 0 14.988281 9.3730469 z "
       transform="scale(0.53333333)"
       id="path4" />
    <path
       d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"
       id="path8" /></svg>
  </span>
  &nbsp;
  <a href="javascript:zoom_neg()" title="zoom canvas">
    <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="black" class="bi bi-arrows-angle-contract" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M.172 15.828a.5.5 0 0 0 .707 0l4.096-4.096V14.5a.5.5 0 1 0 1 0v-3.975a.5.5 0 0 0-.5-.5H1.5a.5.5 0 0 0 0 1h2.768L.172 15.121a.5.5 0 0 0 0 .707zM15.828.172a.5.5 0 0 0-.707 0l-4.096 4.096V1.5a.5.5 0 1 0-1 0v3.975a.5.5 0 0 0 .5.5H14.5a.5.5 0 0 0 0-1h-2.768L15.828.879a.5.5 0 0 0 0-.707z"/>
    </svg></a>
  &nbsp;
  <a href="javascript:zoom()" title="zoom canvas">
    <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="black" class="bi bi-arrows-angle-expand" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M5.828 10.172a.5.5 0 0 0-.707 0l-4.096 4.096V11.5a.5.5 0 0 0-1 0v3.975a.5.5 0 0 0 .5.5H4.5a.5.5 0 0 0 0-1H1.732l4.096-4.096a.5.5 0 0 0 0-.707zm4.344-4.344a.5.5 0 0 0 .707 0l4.096-4.096V4.5a.5.5 0 1 0 1 0V.525a.5.5 0 0 0-.5-.5H11.5a.5.5 0 0 0 0 1h2.768l-4.096 4.096a.5.5 0 0 0 0 .707z"/>
    </svg></a>
  &nbsp;
  <a href="javascript:stack_flipH()">
    <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="black" class="bi bi-arrow-left-right" viewBox="0 0 16 16">
    <path fill-rule="evenodd" d="M1 11.5a.5.5 0 0 0 .5.5h11.793l-3.147 3.146a.5.5 0 0 0 .708.708l4-4a.5.5 0 0 0 0-.708l-4-4a.5.5 0 0 0-.708.708L13.293 11H1.5a.5.5 0 0 0-.5.5zm14-7a.5.5 0 0 1-.5.5H2.707l3.147 3.146a.5.5 0 1 1-.708.708l-4-4a.5.5 0 0 1 0-.708l4-4a.5.5 0 1 1 .708.708L2.707 4H14.5a.5.5 0 0 1 .5.5z"/>
  </svg></a>
  &nbsp;
  <a href="javascript:stack_flipV()">
    <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="black" class="bi bi-arrow-down-up" viewBox="0 0 16 16">
    <path fill-rule="evenodd" d="M11.5 15a.5.5 0 0 0 .5-.5V2.707l3.146 3.147a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 1 0 .708.708L11 2.707V14.5a.5.5 0 0 0 .5.5zm-7-14a.5.5 0 0 1 .5.5v11.793l3.146-3.147a.5.5 0 0 1 .708.708l-4 4a.5.5 0 0 1-.708 0l-4-4a.5.5 0 0 1 .708-.708L4 13.293V1.5a.5.5 0 0 1 .5-.5z"/>
  </svg></a>
  &nbsp;
  <a href="javascript:stack_rc()" title="rotate clockwise">
    <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="black" class="bi bi-arrow-clockwise" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
      <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
    </svg></a>
  &nbsp;
  <a href="javascript:stack_rcc()" title="rotate counter-clockwise">
  <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="black" class="bi bi-arrow-counterclockwise" viewBox="0 0 16 16">
    <path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2v1z"/>
    <path d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.308a.25.25 0 0 0 0 .384l2.36 1.966A.25.25 0 0 0 8 4.466z"/>
  </svg></a>
  &nbsp;
  <a href="javascript:greyScale()" title="convert to greyscale">
  <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="grey" class="bi bi-palette-fill" viewBox="0 0 16 16">
    <path d="M12.433 10.07C14.133 10.585 16 11.15 16 8a8 8 0 1 0-8 8c1.996 0 1.826-1.504 1.649-3.08-.124-1.101-.252-2.237.351-2.92.465-.527 1.42-.237 2.433.07zM8 5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm4.5 3a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zM5 6.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm.5 6.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3z"/>
  </svg></a>
  &nbsp;
  <a href="javascript:invertColors()" title="invert colors">
  <svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" width="30" height="30" fill="black" class="bi bi-square" viewBox="0 0 16 16" version="1.1" id="svg4" sodipodi:docname="spiral.svg" inkscape:version="0.92.4 (5da689c313, 2019-01-14)">
    <metadata   id="metadata10">  <rdf:RDF>    <cc:Work       rdf:about="">      <dc:format>image/svg+xml</dc:format>      <dc:type         rdf:resource="http://purl.org/dc/dcmitype/StillImage" />      <dc:title />    </cc:Work>  </rdf:RDF>
    </metadata>
    <defs   id="defs8" />
    <sodipodi:namedview   pagecolor="#ffffff"   bordercolor="#666666"   borderopacity="1"   objecttolerance="10"   gridtolerance="10"   guidetolerance="10"   inkscape:pageopacity="0"   inkscape:pageshadow="2"   inkscape:window-width="2072"   inkscape:window-height="1160"   id="namedview6"   showgrid="false"   inkscape:zoom="19.666667"   inkscape:cx="1.0038413"   inkscape:cy="12.028218"   inkscape:window-x="30"   inkscape:window-y="20"   inkscape:window-maximized="1"   inkscape:current-layer="svg4" />
    <path   style="fill:#080907;fill-opacity:0.99041533;stroke:#000000;stroke-width:0.35413408;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"   d="M 7.8490935,9.3582994 C 7.9125109,15.175258 8.0046144,15.190446 8.0046144,15.190446 4.6226405,15.292508 2.3125978,12.610557 2.3125978,9.5345523 2.3125978,6.458548 5.0547716,4.9796141 7.771333,0.99629336 7.7355147,6.4754756 7.8136598,6.1079957 7.8490935,9.3582994 Z"   id="path868"   inkscape:connector-curvature="0"   sodipodi:nodetypes="ssscs" />
    <path   sodipodi:nodetypes="ssscs"   inkscape:connector-curvature="0"   id="path871"   d="m 8.1290313,9.3898868 c -0.063417,5.8169592 -0.2799378,5.7847662 -0.2799378,5.7847662 3.3819755,0.102062 5.4431455,-2.564096 5.4431455,-5.6400996 0,-3.0760053 -2.446648,-4.4826064 -5.1632077,-8.465928 0.035818,5.479183 0.035433,5.0709575 0,8.3212614 z"   style="fill:none;fill-opacity:0.99041533;stroke:#000000;stroke-width:0.40277886;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:0.99680511" />
  </svg></a>
  
  &nbsp;
  <a href="javascript:stack_clearCanvas()" title="clear canvas">
    <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="red" class="bi bi-x-circle" viewBox="0 0 16 16">
    <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
    <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
  </svg></a>
  <!--a href="info.html" title="info">
  <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="black" class="bi bi-info-circle" viewBox="0 0 16 16">
    <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
    <path d="m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/>
  </svg></a-->
  
   <!--a href="javascript:showCanvasSettings()" title="show canvas info">
  <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="black" class="bi bi-bug" viewBox="0 0 16 16">
    <path d="M4.355.522a.5.5 0 0 1 .623.333l.291.956A4.979 4.979 0 0 1 8 1c1.007 0 1.946.298 2.731.811l.29-.956a.5.5 0 1 1 .957.29l-.41 1.352A4.985 4.985 0 0 1 13 6h.5a.5.5 0 0 0 .5-.5V5a.5.5 0 0 1 1 0v.5A1.5 1.5 0 0 1 13.5 7H13v1h1.5a.5.5 0 0 1 0 1H13v1h.5a1.5 1.5 0 0 1 1.5 1.5v.5a.5.5 0 1 1-1 0v-.5a.5.5 0 0 0-.5-.5H13a5 5 0 0 1-10 0h-.5a.5.5 0 0 0-.5.5v.5a.5.5 0 1 1-1 0v-.5A1.5 1.5 0 0 1 2.5 10H3V9H1.5a.5.5 0 0 1 0-1H3V7h-.5A1.5 1.5 0 0 1 1 5.5V5a.5.5 0 0 1 1 0v.5a.5.5 0 0 0 .5.5H3c0-1.364.547-2.601 1.432-3.503l-.41-1.352a.5.5 0 0 1 .333-.623zM4 7v4a4 4 0 0 0 3.5 3.97V7H4zm4.5 0v7.97A4 4 0 0 0 12 11V7H8.5zM12 6a3.989 3.989 0 0 0-1.334-2.982A3.983 3.983 0 0 0 8 2a3.983 3.983 0 0 0-2.667 1.018A3.989 3.989 0 0 0 4 6h8z"/>
  </svg></a-->
  &nbsp;
  <a href="javascript:exposureInfo()" title="exposure info"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="black" class="bi bi-image" viewBox="0 0 16 16">
    <path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/>
    <path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-12zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1h12z"/>
  </svg></a>
   </div>
   <div style='margin:4px;white-space: nowrap;' id="dropdowns">
     &nbsp;
     <button id="ff" onclick="testImage('framefunctions')" title="frame functions"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="black" class="white" viewBox="0 0 16 16">
      <path d="M3.5.5A.5.5 0 0 1 4 1v13h13a.5.5 0 0 1 0 1h-2v2a.5.5 0 0 1-1 0v-2H3.5a.5.5 0 0 1-.5-.5V4H1a.5.5 0 0 1 0-1h2V1a.5.5 0 0 1 .5-.5zm2.5 3a.5.5 0 0 1 .5-.5h8a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0V4H6.5a.5.5 0 0 1-.5-.5z"/>
      </svg></button>
     <select id="framefunctions">
       <option value="dropFrame">drop shadow</option>
       <option value="zoomOutImage">zoom out</option>
       <option value="zoomImage">zoom in</option>
       <option value="makeSquare">pad to square</option>
       <option value="cropSquare">crop to square</option>
       <option value="resizeTo1080">crop to 1080</option>
       <option value="leftCut" style="color:red">left cut</option>
       <!--option value="leftClip" style="color:red">left clip</option-->
       <option value="nudgeRight" style="color:red">nudge horizontal</option>
       <option value="nudgeDown" style="color:red">nudge vertcal</option>
       
       <option value="rectFrame">rect frame</option>
       <option value="filmFrame">film frame</option>
       <option value="lineFrame">line frame</option>
       <option value="roundedFrame">rounded frame</option>
       <option value="frameCircle">circle frame</option>
       <option value="framePolaroid">polaroid frame</option>
       <option value="frame">jaggy frame</option>
       <option value="ripFrame">rip frame</option>
       <option value="halfRip" style="color:red">left rip</option>
       <option value="leftClip" style="color:red">left clip</option>

       <!--option value="make4to5">pad to 4:5</option-->
       
       <option value="nudgehalfdown" style="color:red">nudge down right</option>
       <option value="nudgeCW" style="color:red">nudge angle</option>
       <option value="expandMarginsAll">expand margins</option>
       <option value="expandMarginsDown">expand bottom</option>
     </select>
      &nbsp;<button onclick="testImage('fadefunctions')" title="fade, darken, blur, gray"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="black" class="white" viewBox="0 0 16 16">
        <path d="M2 6a6 6 0 1 1 10.174 4.31c-.203.196-.359.4-.453.619l-.762 1.769A.5.5 0 0 1 10.5 13a.5.5 0 0 1 0 1 .5.5 0 0 1 0 1l-.224.447a1 1 0 0 1-.894.553H6.618a1 1 0 0 1-.894-.553L5.5 15a.5.5 0 0 1 0-1 .5.5 0 0 1 0-1 .5.5 0 0 1-.46-.302l-.761-1.77a1.964 1.964 0 0 0-.453-.618A5.984 5.984 0 0 1 2 6zm6-5a5 5 0 0 0-3.479 8.592c.263.254.514.564.676.941L5.83 12h4.342l.632-1.467c.162-.377.413-.687.676-.941A5 5 0 0 0 8 1z"/>
      </svg></button>
      <select id="fadefunctions">
        <option value="retro">retro</option>
        <option value="enhanceExposure" >enhance exposure</option>
        <option value="haze">haze</option>
        <option value="yellowedEdges">yellowed edge</option>
        <option value="lightenEdges">lighten edge</option>
        <option value="darkenEdges">darken edge</option>
        <option value="fadeEdges">fade edge</option>
        <option value="tint">tint</option>
        <option value="spotlight">spotlight</option>
        <option value="lightleak">light leak</option>
        <option value="multileak">multi leak</option>
        <option value="sobel">sobel</option>
        <option value="pop">pop</option>
        <option value="embossCanvas">emboss</option>
        <option value="blurAlpha">blur alpha</option>
        <option value="edgeDarken" style="color:red">darken edges</option>
        <option value="edgeLighten" style="color:red">lighten edges</option>
        <option value="edgeBlur" style="color:red">blur edges</option>
        <option value="edgeGrey" style="color:red">gray edges</option>
        <option value="fadeCenter" style="color:red">fade center</option>
        <option value="transparenter">fade all</option>
        <option value="opaqueer">unfade all</option>
        <option value="fr">fade right</option>
        <option value="fd">fade dowm</option>
        <option value="chaze">edge haze</option>
        <option value="darkenSky">darken sky</option>
        <option value="tintSky">tint sky</option>
        <option value="decolorSky">decolor sky</option>
        <!--option value="rotateBrightness">shift colors</option>
        <option value="randomizeColors">randomize colors</option-->
      </select>
      &nbsp;<button id="cf" onclick="testImage('colorfunctions')" title="color functions"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="black" class="white" viewBox="0 0 16 16">
      <path d="M1.5 1.5A.5.5 0 0 1 2 1h12a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.128.334L10 8.692V13.5a.5.5 0 0 1-.342.474l-3 1A.5.5 0 0 1 6 14.5V8.692L1.628 3.834A.5.5 0 0 1 1.5 3.5v-2zm1 .5v1.308l4.372 4.858A.5.5 0 0 1 7 8.5v5.306l2-.666V8.5a.5.5 0 0 1 .128-.334L13.5 3.308V2h-11z"/>
    </svg></button>
    <select id='colorfunctions'>
      <option value="colorFilterOut" >filter selected</option>
      <option value="colorFilter">filter unselected</option>
      <option value="alphaWhite">filter light</option>
      <option value="alphaBlack">filter dark</option>
      <option value="filterGrays">filter grays</option>
      <option value="highContrast">high contrast</option>
      <option value="threshold">threshold</option>
      <option value="threshold_soft">threshold soft</option>
      <option value="posterize" >posterize</option>
      <option value="palettetint" >palette tint</option>
      <option value="tintByCloseness" >extracted tint</option>
      <option value="simplifyColors">simplify colors</option>
      <!-- value="cymk">CYMK</option-->
      <option value="halfToneMono" >HT mono</option>
      <option value="stipple">stipple</option>
      <option value="etch" selected>etch</option>
      <option value="typewriter" >typewriter</option>
      <option value="markwriter">markwriter</option>
      <option value="regMarks" >registration</option>
      <option value="paintByNumbers">mono by numbers</option>
      <option value="paintByNumbers2">color by numbers</option>
      <option value="hatches">hatches</option>
      <option value="hatchescolor">hatches color</option>
      <option value="nicksmith">nick smith</option>
      <option value="bricks">bricks</option>
      <option value="sampleImageData">sample dark</option>
      <option value="sampleImageDataColor">sample colors</option>
      <option value="sampleImageDataColor2" >sample colors2</option>
      <option value="pointillism2">pointillism</option>
      <option value="mosaic">mosaic</option>
      <option value="nearest">squares mosaic</option>
      <option value="dotmosaic">dot mosaic</option>
      </select>
      &nbsp;
      <button onclick="testImage('patternfunctions')" title="patterns"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="black" class="white" viewBox="0 0 16 16">
      <path d="M0 .5A.5.5 0 0 1 .5 0h15a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5H14v2h1.5a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5H14v2h1.5a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5H.5a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5H2v-2H.5a.5.5 0 0 1-.5-.5v-3A.5.5 0 0 1 .5 6H2V4H.5a.5.5 0 0 1-.5-.5v-3zM3 4v2h4.5V4H3zm5.5 0v2H13V4H8.5zM3 10v2h4.5v-2H3zm5.5 0v2H13v-2H8.5zM1 1v2h3.5V1H1zm4.5 0v2h5V1h-5zm6 0v2H15V1h-3.5zM1 7v2h3.5V7H1zm4.5 0v2h5V7h-5zm6 0v2H15V7h-3.5zM1 13v2h3.5v-2H1zm4.5 0v2h5v-2h-5zm6 0v2H15v-2h-3.5z"/>
      </svg></button>
      <select id="patternfunctions">
        <option value="wavyPaper" selected>paper</option>
        <option value="canvas1">canvas</option>
        <option value="watercolorPaper">wc paper</option>
        <option value="diss" >distress</option>
        <option value="wash" >wash</option>
        <option value="wash2" >wash2</option>
        <option value="wash3" >wash3</option>
        <option value="increaseGrain">increase grain</option>
        <option value="specksRadial">specks</option>
        <option value="blobs">blobs</option>
        <option value="fog">fog</option>
        <option value="smudge">smudges</option>
        <option value="smudgewatercolor" >watercolor</option>
        <option value="smudgestreaks">streaks</option>
        <option value="smudgestreaks2">streaks2</option>
        <option value="smudgehorizontal">horizontal</option>
        <option value="smudgehorizontal2">horizontal2</option>
        <option value="vanishingpoint">vanishing point</option>
        <option value="smudgearcs">arcs</option>
        <option value="smudgearcs2" >arcs2</option>
        <option value="smudgestars">stars</option>
        <option value="rays">rays</option>
        <option value="chips">chips</option>
        <option value="strokes2">strokes</option>
        <option value="skinnyLines">horizontal3</option>
        <option value="slantedLines">slanted</option>
        <option value="skinnyRings">rings</option>
        <option value="linearSpiral">spiral</option>
        <option value="waves">waves</option>
        <option value="snow">snow</option>
      </select>
       &nbsp;<button onclick="testImage('drawingfunctions')" title="drawing functions">
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="black" class="white" viewBox="0 0 16 16">
        <path d="M15.825.12a.5.5 0 0 1 .132.584c-1.53 3.43-4.743 8.17-7.095 10.64a6.067 6.067 0 0 1-2.373 1.534c-.018.227-.06.538-.16.868-.201.659-.667 1.479-1.708 1.74a8.118 8.118 0 0 1-3.078.132 3.659 3.659 0 0 1-.562-.135 1.382 1.382 0 0 1-.466-.247.714.714 0 0 1-.204-.288.622.622 0 0 1 .004-.443c.095-.245.316-.38.461-.452.394-.197.625-.453.867-.826.095-.144.184-.297.287-.472l.117-.198c.151-.255.326-.54.546-.848.528-.739 1.201-.925 1.746-.896.126.007.243.025.348.048.062-.172.142-.38.238-.608.261-.619.658-1.419 1.187-2.069 2.176-2.67 6.18-6.206 9.117-8.104a.5.5 0 0 1 .596.04zM4.705 11.912a1.23 1.23 0 0 0-.419-.1c-.246-.013-.573.05-.879.479-.197.275-.355.532-.5.777l-.105.177c-.106.181-.213.362-.32.528a3.39 3.39 0 0 1-.76.861c.69.112 1.736.111 2.657-.12.559-.139.843-.569.993-1.06a3.122 3.122 0 0 0 .126-.75l-.793-.792zm1.44.026c.12-.04.277-.1.458-.183a5.068 5.068 0 0 0 1.535-1.1c1.9-1.996 4.412-5.57 6.052-8.631-2.59 1.927-5.566 4.66-7.302 6.792-.442.543-.795 1.243-1.042 1.826-.121.288-.214.54-.275.72v.001l.575.575zm-4.973 3.04.007-.005a.031.031 0 0 1-.007.004zm3.582-3.043.002.001h-.002z"/>
      </svg></button>
    <select id="drawingfunctions" >
      
      <option value="script">script</option>
      <option value="crayonScript">script (crayon)</option>
      <option value="placeTextAt">word</option>
      <!--option value="placeRectAt">mockup</option-->
      <option value="scratchout">scratch out</option>
      <option value="rose">rose</option>
      <option value="natural">loop</option>
      <option value="spiral4">scribble</option>
      <option value="paintDrips">paint drips</option>
      <option value="paintDrip">drip at</option>
      <option value="hstripes">stripes</option>
      <option value="monocubes">mono cubes</option>
      <option value="monoballs">mono balls</option>
      <option value="monoblobs">line polys</option>
      <option value="halfTone">half-tone</option>
      <option value="kites">kites</option>
      <option value="flags">flags</option>
      <option value="pointys" >pointy</option>
      <option value="dflags">diags</option>
      <option value="weave">weave</option>
      <option value="weave2">weave2</option>
      <option value="pinwheels">pinwheels</option>
      <option value="fourXfour">fourXfour</option>
      <!--option value="origami4by4">4x4</option-->
      <option value="onesquare">1 square</option>
      <option value="twosquares">2 squares</option>
      <option value="foursquares">4 squares</option>
      <option value="circle" >1 circle</option>
      <option value="threeCircles">3 circles</option>
      <option value="twohemispheres">2 hemi</option>
      <option value="cornercurve">diag curve</option>
      <option value="everythingSymb">message</option>
      <option value="crazywall">crazy wall</option>
      <option value="natal" >natal</option>
      <option value="aconst" >constellation</option>
      <option value="socialnetwork">social network</option>
      <option value="everythingArray">symbol array</option>
      <!--option value="tv">tv</option>
      <option value="hand">hand</option>
      <option value="heart">heart</option>
      <option value="talk">talk</option>
      <option value="thought">thought</option>
      <option value="ivy" >ivy</option>
      <option value="user">user</option>
      <option value="stairs">stairs</option>
      <option value="ladder">ladder</option>
      <option value="lamp">lamp</option>
      <option value="prayer">prayer</option>
      <option value="slide">slide</option-->
      <option value="chair" >chair</option>
      <option value="chairStorm">chair storm</option>
      <option value="treeStorm">tree storm</option>
      <option value="swing">swing set</option>
      <option value="glass_line" >glass</option>
      <option value="glass" >glass (fill)</option>
      <option value="envelope">envelope</option>
      <option value="hairs">hairs</option>
      <option value="mnts" >mnts</option>
      <option value="crackle">crackle curves</option>
      <option value="cracklelines" >crackle lines</option>
      <option value="origami">origami</option>
      <option value="dotArray">dot array</option>
      <!--option value="pyrm">pyrm</option-->
      <option value="neckerline">necker</option>
      <option value="necker">necker (fill)</option>
      <option value="house">house (fill)</option>
      <option value="monocube">cube (mono)</option>
      <option value="cube">cube (fill)</option>
      <option value="cube2">cube2</option>
      <option value="phase">phase</option>
      <option value="shape2">shape</option>
      <option value="scraps">scraps</option>
      <option value="multiScraps">multi scraps</option>
      <option value="tape">tape</option>
      <!--option value="phases">phases</option>
      <option value="corner">corner</option>
      <option value="facade" >facade</option>
      <option value="core">core</option>
      <option value="eclipse">eclipse</option>
      <option value="constellations" >constellations</option>
      <option value="seasons">seasons</option>
      <option value="tides">tides</option-->
      <!--option value="strokes">strokes</option>
      <option value="strokes2">strokes2</option>
      <option value="strokesH">strokes horizontal</option>
      <option value="scratch">scratch</option>
      <option value="randomTexture" >random texture</option>
      <option value="randomTexture2">random texture2</option>
      <option value="landscape3">landscape</option-->
      <!--option value="coloringbook">coloring book</option-->
      <!--option value="edgeSmear">streak left</option>
      <option value="smeardownOff">vertical streaks</option-->
    </select>
    &nbsp;<button onclick="testImage('paperfunctions')" title="fade, darken, blur, gray"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="black" class="white" viewBox="0 0 16 16">
      <path d="M14 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5L14 4.5zm-3 0A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4.5h-2z"/>
    </svg></button>
    <select id="paperfunctions">
      <!--option value="roadmap">road map</option-->
      <option value="moleskine2">mole blank</option>
      <option value="moleskine">mole grid</option>
      <option value="moleskineDay">day planner</option>
      <option value="cuttingboard">cutting board</option>
      <option value="perforations">perforations</option>
      <option value="label">label</option>
      <option value="form1">form</option>
      <option value="form2">form decoration</option>
      <option value="form3">form (nest)</option>
      <option value="detail">detail</option>
      <option value="pageOfBook">book page</option>
      <option value="ctrlchart">ctrl chart</option>
      <option value="stepchart">step chart</option>
      <option value="histograph" >histograph</option>
      <option value="pairedwords">form pairs</option>
      <option value="nested">nested sqrs</option>
      <option value="index">index</option>
      <option value="moleText">clues</option>
      <option value="crosswordPad">crossword</option>
      <option value="sketchpad">sketch pad</option>
      <option value="floppyPage">stack of pages</option>
      <option value="linedPad">lined pad</option>
      <option value="dividedPad">divided pad</option>
      <option value="gridLinear" >grid paper</option>
      <option value="griddiag"selected>grid diag</option>
      <option value="griddots">grid dots</option>
      <option value="griddiagd">diagonal</option>
      <option value="gridLog">log paper</option>
      <option value="gridpaper">grid</option>
      <option value="musicpaper">music</option>
      <option value="checklist">checklist</option>
      <option value="survey">survey</option>
      <option value="requirements">requirements pad</option>
      <option value="messagepad">message</option>
      <option value="datedue">date due</option>
      <option value="interdepartmental">interdepartmental</option>
      <option value="postcard">postcard</option>
      <option value="indexcard">index card</option>
      <!--option value="oiloncanvas">oiloncanvas</option>
      <option value="sold">sold</option>
      <option value="thisSpace">this space</option>
      <option value="spiralbound">spiral bound</option-->
      <option value="photoBook">photo book</option>
      <option value="justlines">martin</option>
      <!--option value="periodictable">periodic table</option>
      <option value="calendar">calendar</option>
      <option value="clock">clock</option>
      <option value="planet">planet</option>
      <option value="system">system</option>
      <option value="rings">rings</option>
      <option value="star">star</option-->
    </select>
     &nbsp;
     <button onclick="testImage('transformfunctions')" title="transformations"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="black" class="white" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M0 3.5A.5.5 0 0 1 .5 3H1c2.202 0 3.827 1.24 4.874 2.418.49.552.865 1.102 1.126 1.532.26-.43.636-.98 1.126-1.532C9.173 4.24 10.798 3 13 3v1c-1.798 0-3.173 1.01-4.126 2.082A9.624 9.624 0 0 0 7.556 8a9.624 9.624 0 0 0 1.317 1.918C9.828 10.99 11.204 12 13 12v1c-2.202 0-3.827-1.24-4.874-2.418A10.595 10.595 0 0 1 7 9.05c-.26.43-.636.98-1.126 1.532C4.827 11.76 3.202 13 1 13H.5a.5.5 0 0 1 0-1H1c1.798 0 3.173-1.01 4.126-2.082A9.624 9.624 0 0 0 6.444 8a9.624 9.624 0 0 0-1.317-1.918C4.172 5.01 2.796 4 1 4H.5a.5.5 0 0 1-.5-.5z"/>
      <path d="M13 5.466V1.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384l-2.36 1.966a.25.25 0 0 1-.41-.192zm0 9v-3.932a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384l-2.36 1.966a.25.25 0 0 1-.41-.192z"/>
      </svg></button>
    <select id="transformfunctions">
      <option value="impasto">impasto</option>
      <option value="dotblur" >dot blur</option>
      <option value="dirblur">dir blur</option>
      <option value="jaggyblur">jaggy blur</option>
      <option value="bokehs">bokeh</option>
      <option value="flares">flares</option>
      <!--option value="haloblur" style="color:red">halo dot</option>
      <option value="halojaggy" style="color:red">halo jaggy</option-->
      <option value="smearside">smear right</option>
      <option value="motionblur">motion blur</option>
      <option value="shaken" selected>shaken</option>
      <option value="tiltshift">tilt-shift</option>
      <option value="wrap" >wrap</option>
      <option value="afold" >fold</option>
      <option value="unfolded" >unfolded</option>
      <option value="fourfold">fourfold</option>
      <option value="distortion">fisheye</option>
      <option value="ripinhalf">rip in half</option>
      <option value="duplicate">duplicate</option>
      <option value="fourbyfourplain">4x4</option>
      <option value="fourbyfour">warhol</option>
      <option value="reverse">reversible</option>
      <option value="pasta">pasta</option>
      <option value="blasco">blasco</option>
      <option value="shred">shred</option>
      <option value="shred2">shred+splice</option>
      <option value="slices">slices</option>
      <option value="pixelado">pixelado</option>
      <option value="checkerboard">checkerboard</option>
      <option value="diamonds">diamonds</option>
      <option value="dots">dots</option>
      <option value="dashes">dashes</option>
      <option value="holes">holes</option>
      <option value="holes2">holes2</option>
      </select>
   </div>
   
   <div style="margin-left:8px;display:block;" id="tools">
   <table border="0" cellpadding="4" style="margin-left:6px;">
     <tr>
       <td style="text-align:right;">canvas size </td><td>
      <select id="canvassizes" onchange="resizeCanvas()">
        <option value="square">square</option>
        <option value="portrait" >portrait</option>
        <option value="1:0.75" >1:0.75</option>
        <option value="landscape">landscape</option>
      </select> &nbsp;<span id="redspan" style="color:red;">cut </span><input type="number" step="1" id="rednumber" style="color:red;" onchange="pushMarker()">
      <!--input type="range" id="canvas_size" class="range" min="1" max="5" value="5" onchange="resizeCanvas()"-->
    </td>
       <td style="text-align:left;">&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="black" class="bi bi-thermometer-high" viewBox="0 0 16 16">
    <path d="M9.5 12.5a1.5 1.5 0 1 1-2-1.415V2.5a.5.5 0 0 1 1 0v8.585a1.5 1.5 0 0 1 1 1.415z"/>
    <path d="M5.5 2.5a2.5 2.5 0 0 1 5 0v7.55a3.5 3.5 0 1 1-5 0V2.5zM8 1a1.5 1.5 0 0 0-1.5 1.5v7.987l-.167.15a2.5 2.5 0 1 0 3.333 0l-.166-.15V2.5A1.5 1.5 0 0 0 8 1z"/>
  </svg></td><td>
    <button onclick="adjustWarmth(5, null, true)">+</button>&nbsp;&nbsp;<button onclick="adjustWarmth(-5, null, true)">-</button>
     </td>
     <td rowspan='4'>
         <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="black" viewBox="0 0 16 16">
      <path d="M1.5 1.5A.5.5 0 0 1 2 1h12a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.128.334L10 8.692V13.5a.5.5 0 0 1-.342.474l-3 1A.5.5 0 0 1 6 14.5V8.692L1.628 3.834A.5.5 0 0 1 1.5 3.5v-2zm1 .5v1.308l4.372 4.858A.5.5 0 0 1 7 8.5v5.306l2-.666V8.5a.5.5 0 0 1 .128-.334L13.5 3.308V2h-11z"/>
    </svg>
         lower: <input type="range" id="lower" style="width:5em;" min='0' max='100'
  value="100" onchange="rangecheck()"> <span class='sample' id='lowsample' style="background-color:#000;">&nbsp;</span> <span id="lowerrange">0</span> %
       &nbsp;|&nbsp;  upper: <input type="range" id="upper" style="width:5em;" min='0' max='100'
  value="100" onchange="rangecheck()"> <span class='sample' id='highsample' style="background-color:#fff;">&nbsp;</span> <span id="upperrange">100</span> %<br>
       <div
  style="border-style:solid;margin:1px;border-color:#a0a0a0;padding:2px;">
         <canvas id="palettecanvas" width="480" height="96"></canvas><br>
         <select id="palettechoice" onchange="loadPalette(true)">
          <option value="uno">uno</option>
          <option value="halfway">color ramp</option>
          <option value="10">10</option>
          <option value="16">16</option>
          <option value="101">10,1</option>
          <option value="1011">10,1,1</option>
          <option value="9411">9,4,1,1</option>
          <option value="933">9,3,3</option>
          <option value="5311">5,3,1,1</option>
          <option value="541">5,4,1</option>
          <option value="721">7,2,1</option>
          <option value="4411">4,4,1,1</option>
          <option value="3331">3,3,3,1</option>
          <option value="primary" >primary</option>
          <option value="vivid">vivid</option>
          <option value="afklint">af klint</option>
          <option value="afklint2">af klint(2)</option>
          <option value="gertrudeabercrombie">abercrombie</option>
          <option value="dali">dali</option>
          <option value="cmy">cmy</option>
          <option value="rainbow">rainbow</option>
          <option value="monokai">monokai</option>
          <option value="rust">rust</option>
          <option value="post-it">post-it</option>
          <option value="yellowed">yellowed</option>
          <option value="nighthawks">nighthawks</option>
          <option value="earring">earring</option>
          <option value="none">none</option>
        </select>
        <!--select id="numcolors" style="width:50px;" title='use N colors'>
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5" selected>5</option>
        </select-->
       <button id="randompalette" onclick="loadPalette()">Load palette</button>&nbsp;<button onclick="extractPalette()">Extract</button>
        
    <input type='file' name='img' size='65' id='openextract' style="display:none;">
    <button><a onclick="openFileExtract()" id="paletteloader" title="extract from file..."><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="black" class="white" viewBox="0 0 16 16">
    <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
    <path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708l3-3z"/>
    </svg></a></button>
    <button>
    <a id="palettedownloader" onclick="savePaletteAs()" download="image.png" title="save palette as png file">
    
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="black" class="white" viewBox="0 0 16 16">
    <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
    <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
  </svg></a></button>
  <button>
    <a onclick="setRandPalette()"  title="random palette">
  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="black" class="white" viewBox="0 0 16 16">
    <path d="M13 1a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h10zM3 0a3 3 0 0 0-3 3v10a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V3a3 3 0 0 0-3-3H3z"/>
    <path d="M5.5 4a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm8 0a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0 8a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm-8 0a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm4-4a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/>
  </svg></a></button>
  
  <button>
  <a onclick="sortByBrightness()"  title="sort by brightness">
  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="black" class="white" viewBox="0 0 16 16">
    <path d="M3.5 12.5a.5.5 0 0 1-1 0V3.707L1.354 4.854a.5.5 0 1 1-.708-.708l2-1.999.007-.007a.498.498 0 0 1 .7.006l2 2a.5.5 0 1 1-.707.708L3.5 3.707V12.5zm3.5-9a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zM7.5 6a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1h-5zm0 3a.5.5 0 0 0 0 1h3a.5.5 0 0 0 0-1h-3zm0 3a.5.5 0 0 0 0 1h1a.5.5 0 0 0 0-1h-1z"/>
  </svg></a></button>
  
  <button>
  <a onclick="sortByHue()"  title="sort by hue">
  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="red" class="white" viewBox="0 0 16 16">
    <path d="M3.5 12.5a.5.5 0 0 1-1 0V3.707L1.354 4.854a.5.5 0 1 1-.708-.708l2-1.999.007-.007a.498.498 0 0 1 .7.006l2 2a.5.5 0 1 1-.707.708L3.5 3.707V12.5zm3.5-9a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zM7.5 6a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1h-5zm0 3a.5.5 0 0 0 0 1h3a.5.5 0 0 0 0-1h-3zm0 3a.5.5 0 0 0 0 1h1a.5.5 0 0 0 0-1h-1z"/>
  </svg></a></button>
  
  <button>
    <a onclick="lightenPalette()"  title="lighten">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="black" class="white" viewBox="0 0 16 16">
        <path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>
      </svg></a></button>
  
  <button>
    <a onclick="darkenPalette()"  title="darken">
  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="black" class="white" viewBox="0 0 16 16">
    <path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zm.5-9.5a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0zm0 11a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0zm5-5a.5.5 0 1 1 0-1 .5.5 0 0 1 0 1zm-11 0a.5.5 0 1 1 0-1 .5.5 0 0 1 0 1zm9.743-4.036a.5.5 0 1 1-.707-.707.5.5 0 0 1 .707.707zm-7.779 7.779a.5.5 0 1 1-.707-.707.5.5 0 0 1 .707.707zm7.072 0a.5.5 0 1 1 .707-.707.5.5 0 0 1-.707.707zM3.757 4.464a.5.5 0 1 1 .707-.707.5.5 0 0 1-.707.707z"/>
  </svg></a></button>
  
  <button  onclick="showHex()" title="show hex values">#</button>
  </div></td>
  <td rowspan="2">
  <div style="display:inline-block;
  vertical-align: baseline;">
  <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
  <path d="M11 8a3 3 0 1 1-6 0 3 3 0 0 1 6 0z"/>
</svg></div></td>
  </tr>
  <tr>
    <td style="text-align:right;">feature size</td><td><input type="range" id="featuresize" onchange="featuresizeChange()" min="0" max="500" value="25"></td>
    <td style="text-align:right;"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="black" class="bi bi-camera" viewBox="0 0 16 16">
      <path d="M7.938 2.016A.13.13 0 0 1 8.002 2a.13.13 0 0 1 .063.016.146.146 0 0 1 .054.057l6.857 11.667c.036.06.035.124.002.183a.163.163 0 0 1-.054.06.116.116 0 0 1-.066.017H1.146a.115.115 0 0 1-.066-.017.163.163 0 0 1-.054-.06.176.176 0 0 1 .002-.183L7.884 2.073a.147.147 0 0 1 .054-.057zm1.044-.45a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566z"/>
    </svg></td><td><button onclick="sharpen2(true)">+</button>&nbsp;&nbsp;<button onclick="shrinkBlur(true)">-</button></td>
    
    </tr>
    <tr><td style="text-align:right;">quantity</td><td><input type="range" id="number" onchange="numberChange()" min="9" max="20000" value="10000">
    </td>
    <td style="text-align:right;"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="black" class="bi bi-droplet" viewBox="0 0 16 16">
    <path fill-rule="evenodd" d="M7.21.8C7.69.295 8 0 8 0c.109.363.234.708.371 1.038.812 1.946 2.073 3.35 3.197 4.6C12.878 7.096 14 8.345 14 10a6 6 0 0 1-12 0C2 6.668 5.58 2.517 7.21.8zm.413 1.021A31.25 31.25 0 0 0 5.794 3.99c-.726.95-1.436 2.008-1.96 3.07C3.304 8.133 3 9.138 3 10a5 5 0 0 0 10 0c0-1.201-.796-2.157-2.181-3.7l-.03-.032C9.75 5.11 8.5 3.72 7.623 1.82z"/>
    <path fill-rule="evenodd" d="M4.553 7.776c.82-1.641 1.717-2.753 2.093-3.13l.708.708c-.29.29-1.128 1.311-1.907 2.87l-.894-.448z"/>
  </svg></td><td><button onclick="saturationScale(1.1,null,true)">+</button>&nbsp;&nbsp;<button onclick="saturationScale(0.9,null,true)">-</button>
    </td>
     
    </tr>
    <tr> <td style="text-align:right;">opacity</td><td><input type="range" onchange='opacityChange()' id="opacity" min="1" max="100" value="100" ></td><td style="text-align:right;"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="black" class="bi bi-circle-half" viewBox="0 0 16 16">
    <path d="M8 15A7 7 0 1 0 8 1v14zm0 1A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"/>
    </svg></td><td><button onclick="contrastImage(5,null,true)">+</button>&nbsp;&nbsp;<button onclick="contrastImage(-5,null,true)">-</button></td>
    </tr>
    <tr>
      
      <td
  style="text-align:right;">&nbsp;&nbsp;alt:<input type="checkbox" id="grungy" title="alternate behaviour" onchange="checkChange()"></td>
  <td>mode: <select id="mode" onchange="modeChange()">
      <option value="source-over" selected>source-over</option>
      <option value="source-in">source-in</option>
      <option value="source-out">source-out</option>
      <option value="source-atop">source-atop</option>
      <option value="destination-over">destination-over</option>
      <option value="destination-in">destination-in</option>
      <option value="destination-out">destination-out</option>
      <option value="destination-atop">destination-atop</option>
      <option value="difference">difference</option>
      <option value="exclusion">exclusion</option>
      <option value="color-dodge">color-dodge</option>
      <option value="color-burn">color-burn</option>
      <option value="screen">screen</option>
      <option value="overlay">overlay</option>
      <option value="darken">darken</option>
      <option value="lighten">lighten</option>
      <option value="color">color</option>
      <option value="hue">hue</option>
      <option value="saturation">saturation</option>
      <option value="luminosity">luminosity</option>
      <option value="xor">xor</option>
    </select><!--W: <input type="number"
  id="canvaswidth" min="40" size="3" onchange="checkWidth()">
       H: <input
  type="number" id="canvasheight" min="40" size="3"
  onchange="checkHeight()">&nbsp;<span
  id="aspectratio" ></span--></td>
     
      <td style="text-align:right;">&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="black" class="bi bi-brightness-high" viewBox="0 0 16 16">
    <path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>
  </svg>
  </td><td>
    <button onclick="adjustBrightness(5, null, true)">+</button>&nbsp;&nbsp;<button onclick="adjustBrightness(-5, null, true)">-</button>
  </td>
  <td rowspan='1'>

  </td>
  </tr>
  </table>
  </div>
  <div class="progresslabel" id="tip"></div>
  <canvas id="marker" width='512' height='6' style="border:1px solid #000000;" title="touch canvas: red mark shows location of clip or rip"></canvas>
  <div id="background" style="width:1024px;height:1024px;float:left;position:relative;">
  
  <canvas id="myCanvas" width="1080" height="1080" style="border:1px solid #000000;">
  </canvas><canvas id="OC" width="1080" height="1080" style="border:1px solid #000000;display:none;"></canvas>
  </div>
  <div>
  </div><br>
  
   
   <div id="gridbox" sytle="display:none;">
  <button onclick="toggleGridBox()" style="float:right;">X</button>
   <canvas id="myDCanvas" sytle="border:1px solid #000000;" width="500" height="500"></canvas>
   <br>
   <br>grid: <select id="gridsize" style="width:48px;" onchange="clearAll()">
    <option value="4">4</option>
    <option value="5">5</option>
    <option value="6">6</option>
    <option value="7">7</option>
    <option value="8">8</option>
    <option value="9">9</option>
    <option value="10" >10</option>
    <option value="12">12</option>
    <option value="14">14</option>
    <option value="16">16</option>
    <option value="18">18</option>
    <option value="20">20</option>
    <option value="24" selected>24</option>
    <option value="32">32</option>
    <option value="80">80</option>
  </select>
  &nbsp;
    
    &nbsp;<input type="checkbox" id="gradient" checked><label for="gradient"> gradient fills</label>
    &nbsp;<input type="checkbox" id="qmode" onclick="killCP()"><label for="qmode"> quadratic</label>
    &nbsp;<select id="fillstroke" style="width:50px;" >
      <option value="fill">fill</option>
      <option value="stroke">stroke</option>
     
    </select>
    &nbsp;<button onclick="closePath()">close path</button>
    &nbsp;
    <button onclick="drawD()">draw</button>
    <br>
    <br>
    &nbsp;<button onclick="clearAll()">clear</button>
    &nbsp;Item count <span id="lastitem">0</span>
    
    &nbsp;
    <a href="javascript:undoLast()" id="undolast" title="undo last item">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="black" class="white" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2v1z"/>
      <path d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.308a.25.25 0 0 0 0 .384l2.36 1.966A.25.25 0 0 0 8 4.466z"/>
    </svg>
    </svg></a>
    
    &nbsp;
    <a href="javascript:downloadCode()" id="downloaderc" title="save drawing code"
    ><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="black" class="white" viewBox="0 0 16 16">
      <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
      <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
    </svg></a>
    &nbsp;
    <br>
    <textarea id="text1" rows="4" cols="68" wrap="soft"  style="display:none;"></textarea>
  </div>
  
    <br>
    <div style="display:none;">
      <canvas id="offscreen" width='512' height='512' hidden></canvas>
    </div>
     <div sytle="display:none;">
      <canvas id="off" width='512' height='512' style="visibility:hidden;"></canvas>
    </div>
    <br>
<script>
let BLACK = 0
let LASTCLICK = [512,512]
let OCISCLEAR = true
let SHOWBOX = false

function toggleGridBox () {
  let el = document.getElementById("gridbox")
  if (SHOWBOX) {
    el.style.display = "none"
    SHOWBOX = false
  } else {
    el.style.display = "block"
    SHOWBOX = true
  }
}

function drawD () {
  let c = document.getElementById("myCanvas")
  var ctx = c.getContext('2d');
  
  makeHighRes(c)
  copyCode()
  let txt = document.getElementById("text1").value
  //console.log(txt)
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.globalCompositeOperation = document.getElementById("mode").value
  eval(txt)
  // set for lower res at next opportunity
  setNormalRes(document.getElementById("myCanvas"))
}

function setNormalRes (c) {
 // copyToOff()
  var ctx = c.getContext('2d');
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "source-over"
  let a = ctx.globalAlpha
  ctx.globalAlpha = 1.0
  ocanvas.height = c.height
  ocanvas.width = c.width
  octx.drawImage(c, 0, 0)
  c.width = 1080, c.height = 1080/*
  // console.log(c.width)
  //if (c.width >= 2160) return
  // finally query the various pixel ratios
  var devicePixelRatio = window.devicePixelRatio || 1;
  var backingStoreRatio = ctx.webkitBackingStorePixelRatio ||
      ctx.mozBackingStorePixelRatio ||
      ctx.msBackingStorePixelRatio ||
      ctx.oBackingStorePixelRatio ||
      ctx.backingStorePixelRatio || 1;
  var ratio = 1//devicePixelRatio / backingStoreRatio;
  //console.log(devicePixelRatio)
  // upscale canvas if the two ratios don't match
  if (true) {
      var oldWidth = c.width;
      var oldHeight = c.height;
      c.width = Math.round(oldWidth * ratio);
      c.height = Math.round(oldHeight * ratio);
      c.style.width = oldWidth + 'px';
      c.style.height = oldHeight + 'px';
      // now scale the context to counter
      // the fact that we've manually scaled
      // our canvas element
      ctx.scale(ratio, ratio);
  }*/
  //syncBackground(c)
  ctx.drawImage(ocanvas,0,0,c.width,c.height)
}

function makeHighRes (c) {
  var ctx = c.getContext('2d');
  // console.log(c.width)
  if (c.width >= 2160) return
  
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "source-over"
  let a = ctx.globalAlpha
  ctx.globalAlpha = 1.0
  ocanvas.height = c.height
  ocanvas.width = c.width
  octx.drawImage(c, 0, 0)
  // finally query the various pixel ratios
  var devicePixelRatio = window.devicePixelRatio || 1;
  var backingStoreRatio = ctx.webkitBackingStorePixelRatio ||
      ctx.mozBackingStorePixelRatio ||
      ctx.msBackingStorePixelRatio ||
      ctx.oBackingStorePixelRatio ||
      ctx.backingStorePixelRatio || 1;
  var ratio = 2//devicePixelRatio / backingStoreRatio;
  //console.log(devicePixelRatio)
  // upscale canvas if the two ratios don't match
  if (devicePixelRatio !== backingStoreRatio) {
      var oldWidth = c.width;
      var oldHeight = c.height;
      c.width = Math.round(oldWidth * ratio);
      c.height = Math.round(oldHeight * ratio);
     // c.style.width = oldWidth + 'px';
     // c.style.height = oldHeight + 'px';
      // now scale the context to counter
      // the fact that we've manually scaled
      // our canvas element
      ctx.scale(ratio, ratio);
  }
  //console.log(c.width)
  ctx.drawImage(ocanvas,0,0,c.width/2,c.height/2)
}

window.onload = function () {
  let myCanvas = document.getElementById("myCanvas")
  let ctx = myCanvas.getContext("2d")
  
  ctx.willReadFrequently = true
  resizeCanvas()
  LASTCLICK[0] = myCanvas.width/2
  LASTCLICK[1] = myCanvas.height/2
  myCanvas.addEventListener('click', function(event) {
    var rect = myCanvas.getBoundingClientRect();
    var x = event.clientX - rect.left;
    var y = event.clientY - rect.top;
    LASTCLICK = []
    LASTCLICK.push(x)
    LASTCLICK.push(y)
    syncMarker(true)
    pushFunction('setLastclick', [x,y])
}, false);


let marker = document.getElementById("marker")
marker.addEventListener('click', function(event) {
    let rect = marker.getBoundingClientRect();
    let x = event.clientX - rect.left;
    LASTCLICK[0] = x
    syncMarker(true)
    showTip("X: "+Math.floor(x), "marker")
    
}, false);

  document.getElementById("mode").addEventListener ('change', function(event) {
    refreshMode()
  }, false);
  
  document.getElementById("opacity").addEventListener ('change', function(event) {
    ctx.globalAlpha = document.getElementById("opacity").value/100
  }, false);
  
  let result = document.getElementById("background")
  result.style.backgroundColor = "#fff";
  randomPick(getCurrentPalette()) // was paintcolor = randomColor()
  loadPalette()
  const selectElement = document.getElementById("mode");
  selectElement.addEventListener('change', (event) => {
  let ctx = document.getElementById("myCanvas").getContext("2d");
  ctx.globalCompositeOperation = selectElement.value

  let filePicker = document.getElementById("uploadimage");
  filePicker.addEventListener("click", function(){this.value = null;}, false);
  
  let filePicker2 = document.getElementById("openextract");
  filePicker2.addEventListener("click", function(){this.value = null;}, false);
  });
  setRandPalette()
  rangecheck()
  syncMarker()
  
  initOC()
  frameVisible()
  
  //makeHighRes(myCanvas)
}

function checkChange () {
  let a = (document.getElementById("grungy").checked)? true: false;
  pushFunction("checkAlt", a)
}

function checkAlt (checked) {
  var elm = document.getElementById('grungy');
  if (checked != elm.checked) {
    elm.click();
  }
}

function setLastclick (lc) {
  LASTCLICK[0] = lc[0]
  LASTCLICK[1] = lc[1]
  syncMarker()
}

function showTip (msg, item) {
  var e = document.getElementById("tip")
  e.innerHTML = msg;
  e.style.display = "block"
  e.style.zIndex = "5"
  let rect = document.getElementById(item).getBoundingClientRect()
  let top = -24 + Math.floor(rect.top + window.scrollY)+"px"
  let left = 24 + Math.floor(rect.left + window.scrollX)+"px"
  if (top)
    e.style.top = top
  if (left)
    e.style.left = left
  else
    e.style.left = "66px"
  setTimeout(function() {
    e.style.display = "none"
    e.innerHTML = ""
  }, 3000);
}




function jaggytest () {
  let x = 0, y = 0, W = 1080
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  
  let alt = document.getElementById("grungy").checked
  if (alt)
    makeHighRes(canvas)
  let oc = document.createElement('canvas')
  let occtx = oc.getContext("2d")
  oc.height = canvas.height, oc.width = canvas.width
  let colors = shuffle(getCurrentPalette(true,13))
  let H = W, cpx, cpy, points = [], n = 0
  let STROKE = false, FILL = true, PATTERN = false
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/5
  ctx.strokeStyle = randomPick(colors)
  ctx.strokeStyle = 'black'
  ctx.lineCap = "square"
  ctx.lineJoin = "meter"

  //1
  ctx.beginPath()
  ctx.moveTo(x+0*W/24, y+0*H/24)
  ctx.lineTo(x+24*W/24, y+0*H/24)
  ctx.lineTo(x+24*W/24, y+24*H/24)
  ctx.lineTo(x+0*W/24, y+24*H/24)
  if (true) {
    ctx.fillStyle = "#000000"
    ctx.fill()
  }


  //2
  ctx.beginPath()
  ctx.moveTo(x+2*W/24, y+2*H/24)
  cpx = x+2*W/24
  cpy = y+6*H/24
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/24, y+6*H/24)
  cpx = x+10*W/24
  cpy = y+6*H/24
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/24, y+2*H/24)
  if (true) {
    ctx.fillStyle = "#ffffff"//randomGradientPal()
    ctx.fill()
  }

  //3
  ctx.beginPath()
  ctx.moveTo(x+12*W/24, y+2*H/24)
  cpx = x+13*W/24
  cpy = y+6*H/24
  ctx.quadraticCurveTo(cpx, cpy, x+16*W/24, y+6*H/24)
  cpx = x+19*W/24
  cpy = y+6*H/24
  ctx.quadraticCurveTo(cpx, cpy, x+20*W/24, y+2*H/24)
  if (true) {
    //ctx.fillStyle = randomGradientPal()
    ctx.fill()
  }


  //4
  ctx.beginPath()
  ctx.moveTo(x+2*W/24, y+8*H/24)
  cpx = x+4*W/24
  cpy = y+14*H/24
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/24, y+14*H/24)
  cpx = x+20*W/24
  cpy = y+14*H/24
  ctx.quadraticCurveTo(cpx, cpy, x+22*W/24, y+8*H/24)
  if (true) {
    //ctx.fillStyle = randomGradientPal()
    ctx.fill()
  }

  //5
  ctx.beginPath()
  ctx.moveTo(x+5*W/24, y+22*H/24)
  cpx = x+5*W/24
  cpy = y+16*H/24
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/24, y+16*H/24)
  cpx = x+10*W/24
  cpy = y+16*H/24
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/24, y+22*H/24)
  cpx = x+13*W/24
  cpy = y+16*H/24
  if (true) {
    //ctx.fillStyle = randomGradientPal()
    ctx.fill()
  }

  //6
  ctx.beginPath()
  ctx.moveTo(x+13*W/24, y+16*H/24)
  cpx = x+13*W/24
  cpy = y+22*H/24
  ctx.quadraticCurveTo(cpx, cpy, x+15*W/24, y+22*H/24)
  cpx = x+18*W/24
  cpy = y+22*H/24
  ctx.quadraticCurveTo(cpx, cpy, x+18*W/24, y+16*H/24)
  if (true) {
    ctx.fill()
  }
}

function printcanvas () {
   let canvas = document.getElementById("myCanvas")
   // Get URL beforehand to reduce delay between write and print
  // (probably unnecessary but just being on the safe side)
  let url = canvas.toDataURL();
  // New tab to isolate canvas for printing
  let win = window.open();
  // 'img' element will show url as image
  win.document.write("<img src='" + url + "'/>");
  // Print preview shows empty page... almost as if to be called before write
  //win.print();
  // Magically seems to cause print to be called after write
  win.setTimeout(() => win.print(), 0);
}

function paperSelect () {
  let sel = document.getElementById("patternfunctions").value
  if (sel === "watercolorPaper")
    watercolorPaper()
  else
  if (sel === "canvas1")
    canvas1()
  else
    wavyPaper()
}

function watercolorPaperD (x,y,w,h) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  ctx.shadowBlur = 0
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = 0;
  ctx.fillStyle = "#eeeeee"
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.fillRect(0,0,canvas.width,canvas.height)
  let fs = document.getElementById("featuresize").value
  let d = 1+Math.floor(fs/100)
  let alpha = document.getElementById("opacity").value
  let n = document.getElementById("number").value
  let c = randomPick(getCurrentPalette()) // was paintcolor
  document.getElementById("featuresize").value = 350
  document.getElementById("opacity").value = 90
  document.getElementById("number").value = 6000
  smudgestreaks2(canvas, "#cccccc")
  smudgestreaks2(canvas, "#cccccc")
  smudgestreaks2(canvas, "#ffffff")
  document.getElementById("number").value = n
  document.getElementById("featuresize").value = fs
  document.getElementById("opacity").value = alpha
  embossCanvas()
  zoomImage(false, d)
  //shrinkBlur()
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "destination-over"
  ctx.fillStyle = "#dedede"
  ctx.fillRect(0,0,canvas.width,canvas.height)
  ctx.globalCompositeOperation = mode
  
  ctx.clearRect(0,0,x,canvas.height)
  ctx.clearRect(0,0,canvas.width,y)
  ctx.clearRect(canvas.width - x, 0, canvas.width, canvas.height)
  ctx.clearRect(0,canvas.height-y,canvas.width,canvas.height)
}

function watercolorPaper () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  ctx.shadowBlur = 0
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = 0;
  ctx.fillStyle = "#eeeeee"
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.fillRect(0,0,canvas.width,canvas.height)
  let fs = document.getElementById("featuresize").value
  let d = 1+Math.floor(fs/100)
  let alpha = document.getElementById("opacity").value
  let n = document.getElementById("number").value
  let c = randomPick(getCurrentPalette()) // was paintcolor
  document.getElementById("featuresize").value = 350
  document.getElementById("opacity").value = 90
  document.getElementById("number").value = 6000
  randomPick(getCurrentPalette()) // was paintcolor = "#cccccc"
  smudgestreaks2(canvas, "#cccccc")
  smudgestreaks2(canvas, "#cccccc")
  randomPick(getCurrentPalette()) // was paintcolor = "#ffffff"
  smudgestreaks2(canvas, "#ffffff")
  document.getElementById("number").value = n
  document.getElementById("featuresize").value = fs
  document.getElementById("opacity").value = alpha
  randomPick(getCurrentPalette()) // was paintcolor = c
  embossCanvas()
  zoomImage(false, d)
  //shrinkBlur()
  
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "destination-over"
  ctx.fillStyle = "#dedede"
  ctx.fillRect(0,0,canvas.width,canvas.height)
  ctx.globalCompositeOperation = mode
}

function canvas1 () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  ctx.shadowBlur = 0
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = 0;
  ctx.fillStyle = "#eeeeee"
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.fillRect(0,0,canvas.width,canvas.height)
  let fs = document.getElementById("featuresize").value
  let d = 5+Math.floor(fs/20)
  let alpha = document.getElementById("opacity").value
  let n = document.getElementById("number").value
 // let c = randomPick(getCurrentPalette()) // was paintcolor
  //document.getElementById("featuresize").value = 250
  document.getElementById("opacity").value = 90
  document.getElementById("number").value = 6000
  //randomPick(getCurrentPalette()) // was paintcolor = "#cccccc"
  ctx.strokeStyle = "#cccccc"
  smudgehorizontal(canvas, "#cccccc")
  rc()
  smudgehorizontal2(canvas, "#cccccc")
  rc()
  ctx.strokeStyle = "#ffffff"

  //randomPick(getCurrentPalette()) // was paintcolor = "#ffffff"
  smudgehorizontal(canvas, "#ffffff")
  rc()
  smudgehorizontal2(canvas, "#ffffff")
  rc()
  document.getElementById("number").value = n
  document.getElementById("featuresize").value = fs
  document.getElementById("opacity").value = alpha
 // randomPick(getCurrentPalette()) // was paintcolor = c
  embossCanvas()
  //shrinkBlur()
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "destination-over"
  ctx.fillStyle = "#dedede"
  ctx.fillRect(0,0,canvas.width,canvas.height)
  ctx.globalCompositeOperation = mode
}

function wavyPaper (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  ctx.shadowBlur = 0
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = 0;
  ctx.fillStyle = "#ffffff"
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.fillRect(0,0,canvas.width,canvas.height)
  let fs = document.getElementById("featuresize").value
  let d = 5+Math.floor(fs/20)
  let alpha = document.getElementById("opacity").value
  let n = document.getElementById("number").value
  let c = randomPick(getCurrentPalette()) // was paintcolor
  let functions = ["fog", "smudge", "smudgewatercolor"]
  document.getElementById("featuresize").value = 500
  document.getElementById("opacity").value = 30
  document.getElementById("number").value = 6000
  let i = 0, f
  for (; i < 3; i++) {
    f = randomPick(functions)
    if (f === "smudge")
      window[f]("", canvas, "#aaaaaa")
    else
      window[f](canvas, "#aaaaaa")

  }
  document.getElementById("opacity").value = 10
  document.getElementById("featuresize").value = 150
  dirblur()
  dotblur()
  dotblur()
  dotblur()
  document.getElementById("number").value = n
  document.getElementById("featuresize").value = fs
  document.getElementById("opacity").value = alpha
  embossCanvas()
  zoomImage(false, d)
  shrinkBlur()
  enhanceExposure()
}
  
function adjustBrightnessC (col, amt) {
  if (col[0] == "#") {
      col = col.slice(1);
      usePound = true;
  }
  var R = parseInt(col.substring(0,2),16);
  var G = parseInt(col.substring(2,4),16);
  var B = parseInt(col.substring(4,6),16);
  // to make the colour less bright than the input
  // change the following three "+" symbols to "-"
  R = R + amt;
  G = G + amt;
  B = B + amt;
  if (R > 255) R = 255;
  else if (R < 0) R = 0;
  if (G > 255) G = 255;
  else if (G < 0) G = 0;
  if (B > 255) B = 255;
  else if (B < 0) B = 0;
  var RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
  var GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
  var BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));
  return "#" + RR + GG + BB;
}

function savePaletteAs () {
  document.getElementById("palettedownloader").download = "image.png";
  document.getElementById("palettedownloader").href = document.getElementById("palettecanvas").toDataURL("image/png").replace(/^data:image\/[^;]/, 'data:application/octet-stream');
}

function halfway (c1,c5) {
  let R = Math.floor((hexToR(c1) + hexToR(c5))/2)
  let G = Math.floor((hexToG(c1) + hexToG(c5))/2)
  let B = Math.floor((hexToR(c1) + hexToB(c5))/2)
  var RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
  var GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
  var BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));
  return "#" + RR + GG + BB;
}

function brightnessOfColor(color) {
  let sum = hexToR(color)
  sum += hexToG(color)
  sum += hexToB(color)
  return sum/3
}

let extendedPalette = []

function getCurrentPalette () {
  return extendedPalette.slice(0,18)
}

function lightenPalette () {
  let n = 0, c, k, amt
  let b = getCurrentPalette(true)
  for (; n < b.length; n++) {
    k = Math.floor(brightnessOfColor(b[n])/10)
    b[n] = adjustBrightnessC(b[n], k)
  }
  updateExtraColors(b)
}
  function darkenPalette () {
    let n = 0, c, k, amt
    let b = getCurrentPalette(true)
    for (; n < b.length; n++) {
      k = Math.floor(brightnessOfColor(b[n])/10)
      b[n] = adjustBrightnessC(b[n], -k)
    }
    updateExtraColors(b)
  }

function loadPalette (PUSH) {
  let a = [], b = []
  let type = document.getElementById("palettechoice").value
  if (PUSH)
    paletteChange(PUSH)
  if (type === "none")
    return
  if (type === "halfway") {
    let clrs = getCurrentPalette()
    let c1 = randomColor()
    let c5 = randomColor()
    let c3 = halfway(c1,c5)
    b = [
    c1,
    halfway(c1,halfway(c1,c3)),
    halfway(c1,c3),
    halfway(halfway(c1,c3), c3),
    c3,
    halfway(c3,halfway(c3,c5)),
    halfway(c3,c5),
    halfway(halfway(c3,c5), c5),
    c5
    ]
    updateExtraColors(b)
    return
  } else
  if (type === "3331") {
    let c1 = randomColorDark()
    let c2 = randomColorDark()
    let c3 = randomColor()
    let c4 = randomColor()
    let amt = Math.floor((5+Math.random()*50))
    b = [
      c1,adjustBrightnessC(c1, amt*2),adjustBrightnessC(c1, amt*3),
      c2,adjustBrightnessC(c2, amt*2),adjustBrightnessC(c2, amt*3),
      c3,adjustBrightnessC(c3, amt*2),adjustBrightnessC(c3, amt*3),
      c4
    ]
    updateExtraColors(b)
    return
  } else
  
  if (type === "4411") {
    let c1 = randomColorDark()
    let c2 = randomColorDark()
    let c3 = randomColor()
    let c4 = randomColorLight()
    let amt = Math.floor((5+Math.random()*50))
    b = [
      c1,adjustBrightnessC(c1, amt),adjustBrightnessC(c1, amt*2),adjustBrightnessC(c1, amt*3),
      c2,adjustBrightnessC(c2, amt),adjustBrightnessC(c2, amt*2),adjustBrightnessC(c2, amt*3),
      c3,
      c4
    ]
    updateExtraColors(b)
    return
  } else
  if (type === "5311") {
    let c1 = randomColorDark()
    let c2 = randomColorDark()
    let c3 = randomColor()
    let c4 = randomColorLight()
    let amt = Math.floor((5+Math.random()*50))
    b = [
      c1,adjustBrightnessC(c1, amt),adjustBrightnessC(c1, amt*2),
         adjustBrightnessC(c1, amt*3),adjustBrightnessC(c1, amt*4),
      c2,adjustBrightnessC(c2, amt),adjustBrightnessC(c2, amt*3),
      c3,
      c4
    ]
    updateExtraColors(b)
    return
  } else
  
  if (type === "10") {
    let c1 = randomColorDark()
    let amt = Math.floor((5+Math.random()*20))
    b = [
      c1,adjustBrightnessC(c1, amt),adjustBrightnessC(c1, amt*2),
         adjustBrightnessC(c1, amt*3),adjustBrightnessC(c1, amt*4),
         adjustBrightnessC(c1, amt*5),adjustBrightnessC(c1, amt*6),
         adjustBrightnessC(c1, amt*7),adjustBrightnessC(c1, amt*8),
         adjustBrightnessC(c1, amt*9)
    ]
    updateExtraColors(b)
    return
  } else
  
  if (type === "uno") {
    let pal = getCurrentPalette()
    if (pal.length > 1)
      b = [pal[0]]
    else
      b = [randomColor()]
    updateExtraColors(b)
    return
  } else
  if (type === "16") {
    let c1 = randomColorVDark()
    let amt = Math.floor((5+Math.random()*15))
    let i = 0
    b = []
    for (; i < 16; i++) {
      b.push(adjustBrightnessC(c1, amt*i))
    }
    updateExtraColors(b)
    return
  } else
  if (type === "101") {
    let c1 = randomColorVDark()
    let c2 = randomColorDark()
    let c3 = randomColor()
    let c4 = randomColorLight()
    let amt = Math.floor((5+Math.random()*33))
    b = [
      c1,adjustBrightnessC(c1, amt),adjustBrightnessC(c1, amt*2),
         adjustBrightnessC(c1, amt*3),adjustBrightnessC(c1, amt*4),
         adjustBrightnessC(c1, amt*5),adjustBrightnessC(c1, amt*6),
         adjustBrightnessC(c1, amt*7),adjustBrightnessC(c1, amt*8),
         adjustBrightnessC(c1, amt*9),
        c3
    ]
    updateExtraColors(b)
    return
  } else
  if (type === "1011") {
    let c1 = randomColorVDark()
    let c2 = randomColorDark()
    let c3 = randomColor()
    let c4 = randomColorLight()
    let amt = Math.floor((5+Math.random()*33))
    b = [
      c1,adjustBrightnessC(c1, amt),adjustBrightnessC(c1, amt*2),
         adjustBrightnessC(c1, amt*3),adjustBrightnessC(c1, amt*4),
         adjustBrightnessC(c1, amt*5),adjustBrightnessC(c1, amt*6),
         adjustBrightnessC(c1, amt*7),adjustBrightnessC(c1, amt*8),
         adjustBrightnessC(c1, amt*9),
        c3,c4
    ]
    updateExtraColors(b)
    return
  } else
  if (type === 'dali') {
    b = ["#9d4305", "#271100", "#a95912", "#5b3a08", "#2f2513", "#674c18", "#c0a651", "#f4d673", "#837648", "#d8d18b", "#dce5c6", "#9bb7a0", "#65826e"]
    updateExtraColors(b)
  } else
  if (type === 'gertrudeabercrombie') {
    b = ["#905a4f", "#918b7c", "#b4ab93", "#1a1915", "#383933", "#525850", "#4f6f66", "#1b515c"]
    updateExtraColors(b)
  } else
  if (type === 'vivid') {
    b = ["#fcfcfc", "#ec7d09", "#fbe90e", "#cedea5", "#49603a", "#7ad650", "#059440", "#0a9bdf", "#144263", "#074d98", "#7c43a3", "#e00665", "#730f36", "#040102", "#e10613", "#ffb9ba", "#c41c1d"]
    updateExtraColors(b)
  } else
    
  if (type === 'afklint') {
    b = ["#be4a3c", "#4c4948", "#c76a47", "#ddc1b1", "#c2a491", "#d68d4a", "#e9ded2", "#24211d", "#d1a947", "#383631", "#e2b84c", "#828d63", "#657b64", "#4e6355", "#a9bac8", "#93a4b6", "#baa4ab", "#a89397"]
    updateExtraColors(b)
  } else
  
  if (type === 'afklint2') {
    b = ["#ca8d8d", "#ac7978", "#c36731", "#cc7a49", "#eadccf", "#e2ba92", "#d47e21", "#ddae2e", "#e9c45f", "#fefefd", "#6e6e45", "#899ab9", "#6a88ce", "#afb6cb", "#1e1f32", "#38373b", "#bd6469", "#964347"]
    updateExtraColors(b)
  }
  if (type === "9411") {
    let c1 = randomColorVDark()
    let c2 = randomColorDark()
    let c3 = randomColor()
    let c4 = randomColorLight()
    let amt = Math.floor((5+Math.random()*20))
    b = [
      c1,adjustBrightnessC(c1, amt),adjustBrightnessC(c1, amt*2),
         adjustBrightnessC(c1, amt*3),adjustBrightnessC(c1, amt*4),
         adjustBrightnessC(c1, amt*5),adjustBrightnessC(c1, amt*6),
         adjustBrightnessC(c1, amt*7),adjustBrightnessC(c1, amt*8),
      c2,adjustBrightnessC(c2, amt*3),adjustBrightnessC(c2, amt*5),adjustBrightnessC(c2, amt*7),
      c3,randomColor()
    ]
    updateExtraColors(b)
    return
  } else
  if (type === "933") {
    let c1 = randomColorVDark()
    let c2 = randomColorDark()
    let c3 = randomColor()
    let amt = Math.floor((5+Math.random()*20))
    b = [
      c1,adjustBrightnessC(c1, amt),adjustBrightnessC(c1, amt*2),
         adjustBrightnessC(c1, amt*3),adjustBrightnessC(c1, amt*4),
         adjustBrightnessC(c1, amt*5),adjustBrightnessC(c1, amt*6),
         adjustBrightnessC(c1, amt*7),adjustBrightnessC(c1, amt*8),
      c2,adjustBrightnessC(c2, amt*5),adjustBrightnessC(c2, amt*7),
      c3,adjustBrightnessC(c3, amt*3),adjustBrightnessC(c3, amt*5),
    ]
    updateExtraColors(b)
    return
  } else
  if (type === "721") {
    let c1 = randomColorDark()
    let c2 = randomColorDark()
    let c3 = randomColor()
    let c4 = randomColorLight()
    let amt = Math.floor((5+Math.random()*33))
    b = [
      c1,adjustBrightnessC(c1, amt),adjustBrightnessC(c1, amt*2),
         adjustBrightnessC(c1, amt*3),adjustBrightnessC(c1, amt*4),
         adjustBrightnessC(c1, amt*5),adjustBrightnessC(c1, amt*6),
      c2,adjustBrightnessC(c2, amt*3),
      c3,
    ]
    updateExtraColors(b)
    return
  } else
  if (type === "541") {
    let c1 = randomColorDark()
    let c2 = randomColorDark()
    let c3 = randomColor()
    let c4 = randomColorLight()
    let amt = Math.floor((5+Math.random()*50))
    b = [
      c1,adjustBrightnessC(c1, amt),adjustBrightnessC(c1, amt*2),
         adjustBrightnessC(c1, amt*3),adjustBrightnessC(c1, amt*4),
      c2,adjustBrightnessC(c2, amt),adjustBrightnessC(c2, amt*2),adjustBrightnessC(c2, amt*3),
      c3,
    ]
    updateExtraColors(b)
    return
  } else
  if (type === "cmy") {
    b = ["#00ffff","#ffff00","#ff00ff","#000000","#ffffff"]
    updateExtraColors(b)
    //document.getElementById("numcolors").value = 4
    return
  } else
  if (type === "rainbow") {
    let rb = [randomColorCool(),randomColorCool(),"#cccccc",randomColorWarm(),randomColorWarm()]
    b = []
    b.push(rb[0])
    b.push(rb[1])
    b.push("#cccccc")
    b.push(rb[3])
    b.push(rb[4])
    updateExtraColors(b)
    return
  } else

  if (type === "post-it") {
    a = ["#f6c2d9","#fff69b","#bcdfc9","#a1c8e9","#e4dae2"]
    b = ["#f6c2d9","#fff69b","#bcdfc9","#a1c8e9","#e4dae2"]
    updateExtraColors(b)
  } else
  if (type === "rust"){
    a = ['#120402', '#482519', '#837a4e', '#c0ab7c', '#f2efec']
    b = ['#120402', '#482519', '#837a4e', '#c0ab7c', '#f2efec']
    updateExtraColors(b)
  } else
  if (type === "yellowed"){
    a = ["#ecd27c","#e1c36b","#d6c293","#e1c452","#d8b758" ]
    b = ["#f4e8c4","#ecd89d","#e0d4bb","#c4b589","#d0ae46","#bfa55f","#c09e34","#b09225"]
    updateExtraColors(b)
  } else
  if (type === "monokai") {
    a = ["#2e2e2e", "#b4d273", "#e87d3e", "#9e86c8", "#b05279", "#6c99bb"]
    b = ["#2e2e2e", "#e5b567", "#b4d273", "#e87d3e", "#9e86c8", "#b05279", "#6c99bb", "#797979", "#d6d6d6"]
    updateExtraColors(b)
  } else
  if (type === "scream"){
    a = ['#08120b', '#30362c', '#5b807f', '#f49f58', '#d9ba81']
    b = ['#f2c28b', '#f2a351', '#c29f69', '#7e9480', '#bd7b45', '#da631c', '#7b684a', '#526c6b', '#bc4e19', '#c83302', '#404335', '#152019', '#020904']
    updateExtraColors(b)
  } else

  if (type === "primary") {
    a = ['#ff0000', '#0000ff', '#ffff00', '#008000', '#ffa500', '#800080']
    updateExtraColors(a)
  } else
  if (type === "nighthawks") {
    a = ["#f9f5a4", "#e76d38", "#33745b", "#762016", "#003e39"].reverse()
    b = ['#e7e28e', '#deda7b', '#bbbe74', '#699474', '#888153', '#b57321', '#58856e', '#a05b21', '#2e6f61', '#4f5f4a', '#0c6244', '#4b281a', '#1f2b29']
    updateExtraColors(b)
  } else
  if (type === "venus") {
    a = ['#2b2920', '#4f3a2d', '#889682', '#d6d7c5', '#f5fbf8']
    b = ['#eeead8', '#e9d195', '#efc292', '#b8c3b3', '#dea041', '#b89d72', '#758270', '#99745b', '#a4723a', '#7a5d3b', '#813917', '#353125', '#050402']
    updateExtraColors(b)
  } else
  if (type === "earring") {
    a = ['#151518', '#232b4b', '#808aaf', '#e6cf94', '#eee6d9']
    b = ['#ebd7b3', '#c5bbbb', '#c3ad87', '#9ea7c8', '#9c907f', '#7a84aa', '#967f55', '#75675a', '#735b34', '#4e5b8e', '#4d433e', '#373031', '#151418']
    updateExtraColors(b)
  } else
  if (type === "a1") {
    a = ["#cad44a","#51c5c8","#5396d2","#958a42","#93d489"]
    updateExtraColors(a)
  } else
  if (type === "a2") {
    a = ["#bdd9bf","#2e4052", "#ffc857","#ffffff","#412234"]
    updateExtraColors(a)
  } else
  if (type === "a3") {
    a = ["#084c61","#db504a","#e3b505","#4f6d7a","#56a3a6"]
    updateExtraColors(a)
  } else
  if (type === "a4") {
    a = ["#464d77","#36827f","#f9db6d","#f4eded","#877666"]
    updateExtraColors(a)
  } else
  if (type === "a5") {
    a = ["#083d77","#ebebd3","#da4167","#f4d35e","#f78764"]
    updateExtraColors(a)
  } else
  if (type === "a6") {
    a = ["#0c090d","#e01a4f","#f15946","#f9c22e","#53b3cb"]
    updateExtraColors(a)
  } else
  if (type === "a7") {
    a = ["#dbd56e","#88ab75","#2d93ad","#7d7c84","#de8f6e"]
    updateExtraColors(a)
  } else
  if (type === "a8") {
    a = ["#bac1b8","#58a4b0","#0c7c59","#2b303a","#d64933"]
    updateExtraColors(a)
  }
  
 // document.getElementById("pal1").value = a[0]
 // document.getElementById("pal2").value = a[1]
 // document.getElementById("pal3").value = a[2]
 // document.getElementById("pal4").value = a[3]
 // document.getElementById("pal5").value = a[4]
}

function setRandPalette () {
  setPalette(randomPick(["halfway", "101", "1011", "9411", "933", "4411", "541", "721", "3331", "5311"]))
}

function clearPoints () {
  document.getElementById("points").value = ""
}

function rangecheck () {
  let low = +document.getElementById("lower").value
  low = 100 - low
  let high = +document.getElementById("upper").value
  if (high < low) {
    document.getElementById("lower").value = high
    low = high
  }
  let dlow = parseInt(low*2.55)
  let dhigh = parseInt(high*2.55)
  dlow = dlow.toString(16)
  dhigh = dhigh.toString(16)
  let el = document.getElementById('lowsample')
  el.style.backgroundColor = "#"+dlow+dlow+dlow
  el = document.getElementById('highsample')
  el.style.backgroundColor = "#"+dhigh+dhigh+dhigh
  document.getElementById("upperrange").innerHTML = high
  document.getElementById("lowerrange").innerHTML = low
  return [low/100, high/100]
}

function showtools () {
  let d = document.getElementById("tools")
  if (d.style.display == "block")
    d.style.display = "none"
  else
    d.style.display = "block"
}

function showResize() {
  let canvas = document.getElementById("myCanvas");
  let d = document.getElementById("resize")
 // document.getElementById("canvaswidth").value = canvas.width
 // document.getElementById("canvasheight").value = canvas.height
  d.showModal()
}

// returns true if every pixel's uint32 representation is 0 (or "blank")
function isCanvasBlank(canvas) {
  const context = canvas.getContext('2d');
  context.willReadFrequently = true
  const pixelBuffer = new Uint32Array(
    context.getImageData(0, 0, canvas.width, canvas.height).data.buffer
  );
  return !pixelBuffer.some(color => color !== 0);
}

function getRatio () {
  let canvas = document.getElementById("myCanvas");
  return canvas.width/canvas.height
}

function gcd (a,b) {
  return (b == 0)? a: gcd(b, a%b)
}

function displayRatio () {
  let canvas = document.getElementById("myCanvas");
  let w = canvas.width, h = canvas.height
  let d = gcd(w,h)
  document.getElementById("aspectratio").innerHTML = 1+":"+Math.round(1000*h/w)/1000
  document.getElementById("resize").setAttribute('title', Math.round(100*w/96)/100 + " X " + Math.round(100*h/96)/100 + " inches")
}

function pushMarker() {
  let m = document.getElementById("marker")
  let w = document.getElementById("myCanvas").width
  let value = document.getElementById("rednumber").value
  let s = Math.floor(value)
  if (w <= value)
    value = w/3
  document.getElementById("rednumber").value = value
  LASTCLICK[0] = value
  m.width = w
  ctx = m.getContext("2d")
  ctx.fillStyle = "#ffffff"
  ctx.fillRect(0,0,m.width,m.height)
  let x = s
  m.title = s
  document.getElementById("rednumber").value = +s
  ctx.fillStyle = "#ff0000"
  ctx.beginPath()
  ctx.moveTo(0,0)
  ctx.lineTo(x,0)
  ctx.lineTo(x,6)
  ctx.lineTo(0,6)
  ctx.closePath()
  ctx.fill()
}

function syncMarker (NOSHOW) {
  let m = document.getElementById("marker")
  let w = document.getElementById("myCanvas").width
  let h = document.getElementById("myCanvas").height
  let s = Math.floor(LASTCLICK[0])
  m.width = w
  ctx = m.getContext("2d")
  ctx.fillStyle = "#ffffff"
  ctx.fillRect(0,0,m.width,m.height)
  let x = s
  m.title = s
  document.getElementById("rednumber").value = +s
  ctx.fillStyle = "#ff0000"
  ctx.beginPath()
  ctx.moveTo(0,0)
  ctx.lineTo(x,0)
  ctx.lineTo(x,6)
  ctx.lineTo(0,6)
  ctx.closePath()
  ctx.fill()
  if (!NOSHOW)
    showTip ("WxH: "+w+" x "+h, "marker")
}
/*
function showCanvasSettings () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  alert("W: "+canvas.width+" H: "+canvas.height+"\ny: "+LASTCLICK[1] +"\n"+objToString(ctx))
}*/

function objToString (obj) {
  let str = '';
  for (var p in obj) {
    str += p + '::' + obj[p] + '\n';
  }
  return str;
}

function setDate () {
  let d = document.getElementById("bdate")
  let date = new Date()
  d.innerHTML = date.toString().substring(0,25)
}

function swapDiag () {// number to divide height by, to match width's divisor
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = 2 + Math.floor(document.getElementById("featuresize").value/10)
  ctx.globalAlpha = document.getElementById("opacity").value/100

  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, x = w
  let N = wdivs * hdivs
  let temp = document.createElement('CANVAS')
  let tempctx = temp.getContext("2d")
  temp.width = canvas.width
  temp.height = canvas.height
  tempctx.drawImage(canvas, 0, 0, temp.width, temp.height)
  let grunge = document.getElementById("grungy").checkd

  let sx = 0, sy = 0
  let dx = 0, dy = 0
  tempctx.imageSmoothingEnabled = false
  ctx.imageSmoothingEnabled = false
  for (; i < wdivs; i++) {
    let j = 0
    for (; j < wdivs; j++) {
      sx = i, sy = j
      dx = j, dy = i
      if (grunge)
        tempctx.translate(pt(20), pt(20))
      ctx.drawImage(temp, dx*w, dy*h, w, h, sx*w, sy*h, w, h)
      ctx.drawImage(temp, sx*w, sy*h, w, h, dx*w, dy*h, w, h)
    }
  }
}

function pointN (x, y, id) {
  this.x = x
  this.y = y
  this.neighbors = []
  this.center
  this.min
  this.max
  this.angles = []
  this.id = id
}

function getAngles (pt) {
  let angles = [], i = 0
  let c = pt.center
  if (c)
  for (; i < pt.neighbors.length; i++) {
    pt.angles.push(Math.atan2(pt.neighbors[i].y-c.y, pt.neighbors[i].x-c.x))
  }
}

function findCenter (pts) {
  if (!pts || pts.length < 3)
    return []
  let centerx = -1, centery = -1, i = 0
  let minx = 1000000000, maxx = -1, miny = 1000000000, maxy = -1
  for (; i < pts.length; i++) {
    minx = (pts[i].x < minx)? pts[i].x: minx;
    miny = (pts[i].y < miny)? pts[i].y: miny;
    maxx = (pts[i].x > maxx)? pts[i].x: maxx;
    maxy = (pts[i].y > maxy)? pts[i].y: maxy;
  }
  centerx = minx + (maxx - minx)/2
  centery = miny + (maxy - miny)/2
  return ([new point(centerx, centery), new point(minx, miny), new point(maxx, maxy)])
}

function drawPointsN (ptsN) {
  let pts = ptsN.neighbors
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  ctx.lineWidth = 6
  ctx.strokeStyle ="#000000"
  let i = 0
  for (;i < pts.length; i++) {
    if (pts[i].neighbors && pts[i].neighbors.length > 3) {
      ctx.strokeStyle = randomColor()
      ctx.fillStyle = randomGradientRect(canvas, "#000000",  ptsN.min.x,  ptsN.min.y,  ptsN.max.x,  ptsN.max.y)
      ctx.globalAlpha = 0.05
      ctx.save()
      ctx.beginPath()
      ctx.moveTo(pts[i].neighbors[0].x, pts[i].neighbors[0].y)
      let j = 1
      for (; j < pts[i].neighbors.length; j++) {
        ctx.lineTo(pts[i].neighbors[j].x, pts[i].neighbors[j].y)
      }
      ctx.closePath()
      ctx.clip()
      ctx.fill()
      ctx.restore()
    }
  }
}

function facets (canvas) {
	let pointsN = []
	let x = 0,y = 0,p = 0
	let len = 40//maxX*maxY
	for (; p < len; p++) {
		pointsN.push( new pointN(Math.floor(Math.random() * 1000), Math.floor(Math.random() * 1000), p))
	}
	let mindistance = 300
	let i = 0
	for (; i < pointsN.length; i++) {
	  let j = 0
	  for (; j < pointsN.length; j++) {
	    if (i !== j) {
	      if (distance(pointsN[i].x, pointsN[i].y, pointsN[j].x, pointsN[j].y) < mindistance) {
	        pointsN[i].neighbors.push(pointsN[j])
	      }
	    }
	  }
	}
	i = 0
	for (; i < 2; i++) {
	  let c = findCenter(pointsN[i].neighbors)
	  pointsN[i].center = c[0]
	  pointsN[i].min = c[1]
	  pointsN[i].max = c[2]
	  getAngles(pointsN[i])
	  let N = pointsN[i].neighbors//, A = pointsN[i].angles
	  let A = pointsN[i].angles
    pointsN[i].neighbors = N
	  drawPointsN(pointsN[i])//.slice(0,3))
  }
	return
}

function wash_og () {
  let fs = document.getElementById("featuresize").value
  fill()
  setOpacity(50)
  checkAlt(true)
  setFeaturesize(355)
  crackle()
  fill()
  fill()
  shaken()
  shaken()
  shaken()
  shrinkBlur()
  rcc()
  shaken()
  shaken()
  rc()
  embossCanvas()
  shrinkBlur()
  setMode("destination-over")
  fill()
  fill()
  fill()
  setMode("source-over")
  setOpacity(100)
  checkAlt(false)
  document.getElementById("featuresize").value = fs
}

function wash3 () {
  setFeaturesize(42)
  setPaintColor("#292929")
  fill()
  setPaintColor("#757575")
  smudgestars()
  smudgestars()
  smudgestars()
  smudgestars()
  setPaintColor("#a3a3a3")
  smudgestars()
  smudgestars()
}

function wash2 () {
  fill()
  setOpacity(75)
  checkAlt(true)
  strokes()
  strokes()
  strokes()
  //fill()
  shaken()
 // shaken()
  rcc()
  shaken()
  //shaken()
  rc()
  //embossCanvas()
  shrinkBlur()
  setMode("destination-over")
  setOpacity(100)
  fill()
  setMode("source-over")
  checkAlt(false)
}

function wash () {
  fill()
  setOpacity(75)
  checkAlt(true)
  crackle()
  crackle()
  fill()
  shaken()
  shaken()
  shrinkBlur()
  rcc()
  shaken()
  shaken()
  rc()
  embossCanvas()
  //shrinkBlur()
  setMode("destination-over")
  setOpacity(100)
  fill()
  setMode("source-over")
  checkAlt(false)
}

function diss () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let val = document.getElementById("opacity").value
  let num = document.getElementById("number").value
  let size = document.getElementById("featuresize").value
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let mode = ctx.globalCompositeOperation
  functions = ["smudge", "smudge", "smudge", "rays", /*"specksRadial"*/]
  let args = ["", "streaks", "streaks2", "arcs", "arcs2", "stars", "horizontal"]
  document.getElementById("number").value = 3 + Math.random() * 10000
  document.getElementById("featuresize").value = 1 + Math.random() * 400
  document.getElementById("opacity").value = 15 + Math.random() + 45
  let nf = 3 + Math.floor(Math.random() * 5)
  ctx.globalCompositeOperation = "destination-out"
  let i = 0
  for (; i < nf; i++) {
    randomPickColor()
    let f = randomPick(functions)
    let a = ''
    if (f == "smudge")
      a = randomPick(args)
    document.getElementById("number").value = 3 + Math.random() * 10000
    document.getElementById("featuresize").value = 5 + Math.random() * 200
    document.getElementById("opacity").value = 25 + Math.random() + 55
    window[f](a)
  }
  document.getElementById("opacity").value = 5 + Math.random() + 5
  ctx.globalAlpha = document.getElementById("opacity").value/100
  document.getElementById("opacity").value = 5 + Math.random() + 5
  contrastImage(5 + Math.random() *11)
  document.getElementById("opacity").value = val
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.globalCompositeOperation = "destination-over"
  randomPick(getCurrentPalette()) // was paintcolor = color
  fillA()
  //restore values
  ctx.globalCompositeOperation = mode
  refreshMode()
  document.getElementById("opacity").value = val
  document.getElementById("number").value = num
  document.getElementById("featuresize").value = size
  randomPick(getCurrentPalette()) // was paintcolor = color
  ctx.globalAlpha = document.getElementById("opacity").value/100
}

function dissOver () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  functions = ["smudge", "smudge", "smudge"]
  let args = ["", "streaks", "streaks2", "arcs", "arcs2", "stars", "horizontal"]
  let nf = 3 + Math.floor(Math.random() * 5)
  let i = 0
  for (; i < nf; i++) {
    let f = randomPick(functions)
    let a = ''
    if (f == "smudge")
      a = randomPick(args)
    window[f](a)
  }
}

function pasteFromOffColor () {
  let OC = document.getElementById('OC')
  if (OC && OC.width > 0) {
    let canvas = document.getElementById('myCanvas')
    let ctx = canvas.getContext('2d')
    ctx.globalCompositeOperation = "source-atop"
    let OCctx = OC.getContext('2d')
    OCctx.globalAlpha = document.getElementById("opacity").value/100
    ctx.globalAlpha = 1
    ctx.drawImage(OC, 0, 0)
    return true
  }
  return true
}

function pasteFromOffColorC () {
  let OC = document.getElementById('OC')
  if (OC && OC.width > 0) {
    let canvas = document.getElementById('myCanvas')
    let ctx = canvas.getContext('2d')
    ctx.globalCompositeOperation = "color"
    document.getElementById("mode").value = "color"
    let OCctx = OC.getContext('2d')
    OCctx.globalAlpha = document.getElementById("opacity").value/100
    ctx.globalAlpha = 1
    ctx.drawImage(OC, 0, 0)
    return true
  }
  return true
}

function coloringbook () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  clearOff()
  let alpha = document.getElementById("opacity").value
  let mode = ctx.globalCompositeOperation
  const myPromise = new Promise((copyToOff) => {
    setTimeout(() => {
      copyToOff()
    }, 300);
  });
  
  copyToOff()
  myPromise
    .then(sobel)
    .then(alphaWhite)
    .then(pasteFromOffColor)
    .then(c2)
    .then(pasteFromOffColorC)
  ctx.globalAlpha = alpha/100
  return true
}

function c2 () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  ctx.globalAlpha = 1.0
  ctx.fillStyle = petColor("#dddddd", 120)
  ctx.globalCompositeOperation = "destination-over"
  ctx.fillRect(0,0,canvas.width,canvas.height)
  return true
}

function landscape () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let val = document.getElementById("opacity").value
  let num = document.getElementById("number").value
  let size = document.getElementById("featuresize").value
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let mode = ctx.globalCompositeOperation
  functions = ["smudge", "smudge", "smudge", "rays", "blobs", "hrips", "fog", "tatter", "specksRadial"]
  let args = ["", "streaks", "arcs", "stars", "horizontal", "streaks2"]
  document.getElementById("number").value = 3 + Math.random() * 10000
  document.getElementById("featuresize").value = 1 + Math.random() * 400
  document.getElementById("opacity").value = 15 + Math.random() + 45
  if (Math.random() > 0.5) {
    randomPickColor()
    edgeSmear()
    rc()
  }
  let i = 0
  for (; i < 3; i++) {
    randomPickColor()
    ctx.fillStyle = randomColor()
    if (Math.random() > 0.4)
      shape()
    rc()
    document.getElementById("number").value = 3 + Math.random() * 10000
    document.getElementById("featuresize").value = 1 + Math.random() * 400
    document.getElementById("opacity").value = 15 + Math.random() + 75
  }
  if (document.getElementById("grungy").checked) {
    document.getElementById("opacity").value = 15 + Math.random() + 75
    ctx.fillStyle = randomColor()
    drawHouseAt(ctx, canvas.width/2, canvas.height/2+Math.random()*canvas.height/4, canvas.height/7 + Math.random()*canvas.height/5)
    if (Math.random() > 0.5)
      drawHouseAt(ctx, canvas.width/2, canvas.height/2+Math.random()*canvas.height/4, canvas.height/9 + Math.random()*canvas.height/9)
    if (Math.random() > 0.5)
      drawHouseAt(ctx, canvas.width/2-canvas.width/7, canvas.height/2+Math.random()*canvas.height/4, canvas.height/9 + Math.random()*canvas.height/9)
    if (Math.random() > 0.5)
      flipH()
    if (Math.random() > 0.5)
      rc()
  }
  let nf = 1 + Math.floor(Math.random() * 5)
  i = 0
  for (; i < nf; i++) {
    randomPickColor()
    let f = randomPick(functions)
    let a = ''
    if (f == "smudge")
      a = randomPick(args)
    document.getElementById("number").value = 3 + Math.random() * 10000
    document.getElementById("featuresize").value = 5 + Math.random() * 400
    document.getElementById("opacity").value = 15 + Math.random() + 60
    window[f](a)
  }
  
  document.getElementById("opacity").value = 5 + Math.random() + 5
  ctx.globalAlpha = document.getElementById("opacity").value/100
  smeardown()
  rcc()
  if (Math.random() > 0.5) {
    smeardown()
    rcc()
  }
  document.getElementById("opacity").value = 5 + Math.random() + 5
  smear()
  smear()
  rcc()
  contrastImage(5 + Math.random() *11)
  document.getElementById("opacity").value = val
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.globalCompositeOperation = "color"
  randomPick(getCurrentPalette()) // was paintcolor = color
  fill()
  //restore values
  ctx.globalCompositeOperation = mode
  refreshMode()
  document.getElementById("opacity").value = val
  document.getElementById("number").value = num
  document.getElementById("featuresize").value = size
  randomPick(getCurrentPalette()) // was paintcolor = color
  ctx.globalAlpha = document.getElementById("opacity").value/100
}

function landscape2 () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let val = document.getElementById("opacity").value
  let num = document.getElementById("number").value
  let size = document.getElementById("featuresize").value
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let mode = ctx.globalCompositeOperation
  functions = ["smudge", "smudge", "smudge", "rays", "blobs", "birds", "hrips", "fog", "specksRadial"]
  let args = ["", "streaks", "arcs", "stars", "horizontal"]
  document.getElementById("number").value = 3 + Math.random() * 10000
  document.getElementById("featuresize").value = 1 + Math.random() * 400
  document.getElementById("opacity").value = 15 + Math.random() + 45
  if (Math.random() > 0.5) {
    randomPickColor()
    fill()
    rc()
  }
  let i = 0
  for (; i < 2; i++) {
    randomPickColor()
    ctx.fillStyle = randomColor()
    shape2()
    document.getElementById("number").value = 3 + Math.random() * 10000
    document.getElementById("featuresize").value = 1 + Math.random() * 400
    document.getElementById("opacity").value = 15 + Math.random() + 75
  }
  rc()
  
  if (document.getElementById("grungy").checked) {
    document.getElementById("opacity").value = 15 + Math.random() + 75
    ctx.fillStyle = randomColor()
    drawHouseAt(ctx, canvas.width/2 + pet(canvas.width/3), canvas.height/2+Math.random()*canvas.height/4, canvas.height/7 + Math.random()*canvas.height/5)
    if (Math.random() > 0.5)
      drawHouseAt(ctx, canvas.width/2, canvas.height/2+Math.random()*canvas.height/4, canvas.height/9 + Math.random()*canvas.height/9)
    if (Math.random() > 0.5)
      drawHouseAt(ctx, canvas.width/2-canvas.width/7, canvas.height/2+Math.random()*canvas.height/4, canvas.height/9 + Math.random()*canvas.height/9)
  }
  let nf = 2 + Math.floor(Math.random() * 5)
  i = 0
  for (; i < nf; i++) {
    randomPickColor()
    let f = randomPick(functions)
    let a = ''
    if (f == "smudge")
      a = randomPick(args)
    document.getElementById("number").value = 3 + Math.random() * 5000
    document.getElementById("featuresize").value = 5 + Math.random() * 100
    document.getElementById("opacity").value = 15 + Math.random() + 50
    window[f](a)
   // document.getElementById("opacity").value = 5 + Math.random() + 5
  }
  document.getElementById("opacity").value = 5 + Math.random() + 5
  ctx.globalAlpha = document.getElementById("opacity").value/100
  smeardown()
  rcc()
  document.getElementById("opacity").value = 5 + Math.random() + 5
  smear()
  rc()
  contrastImage(5 + Math.random() *11)
  document.getElementById("opacity").value = val
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.globalCompositeOperation = "color"
  randomPick(getCurrentPalette()) // was paintcolor = color
  fill()
  //restore values
  ctx.globalCompositeOperation = mode
  refreshMode()
  document.getElementById("opacity").value = val
  document.getElementById("number").value = num
  document.getElementById("featuresize").value = size
  randomPick(getCurrentPalette()) // was paintcolor = color
  ctx.globalAlpha = document.getElementById("opacity").value/100
}

function blobFill (fs) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let val = document.getElementById("opacity").value
  let num = document.getElementById("number").value
  let size = document.getElementById("featuresize").value
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let mode = ctx.globalCompositeOperation
  document.getElementById("number").value = 800
  document.getElementById("featuresize").value = 500
  document.getElementById("opacity").value = 100//15 + Math.random() + 75
  randomPick(getCurrentPalette()) // was paintcolor = randomColorVLight()
  fill()
  ctx.fillStyle = randomColorVLight()
  ctx.fillRect(canvas.width/2, 0, canvas.width, canvas.height)
  let i = 0
  for (; i < 2; i++) {
    randomPickColor() // randomLight
    randomPick(getCurrentPalette()) // was paintcolor = randomColorLight()
    blobs()
  }
  // restore
  document.getElementById("number").value = num
  document.getElementById("featuresize").value = size
  document.getElementById("opacity").value = val
  randomPick(getCurrentPalette()) // was paintcolor = color
}

function landscape3 () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let val = document.getElementById("opacity").value
  let num = document.getElementById("number").value
  let size = document.getElementById("featuresize").value
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let grunge = document.getElementById("grungy").checked
  let mode = ctx.globalCompositeOperation
  functions = ["smudge", "smudge", "smudge", "rays", "blobs", "hrips", "fog", "specksRadial"]
  let args = ["", "streaks", "arcs", "arcs2", "stars", "horizontal", "horizontal2"]
  document.getElementById("number").value = 3 + Math.random() * 10000
  document.getElementById("featuresize").value = 1 + Math.random() * 400
  document.getElementById("opacity").value = 100//15 + Math.random() + 75
  randomPickColor()
  fill()
  document.getElementById("opacity").value = 15 + Math.random() + 75
  randomPickColor()
  fog()

  let i = 0
  for (; i < 2; i++) {
    document.getElementById("number").value = 3 + Math.random() * 10000
    document.getElementById("featuresize").value = 1 + Math.random() * 400
    document.getElementById("opacity").value = 15 + Math.random() + 65
    randomPickColor()
    ctx.fillStyle = randomColor()
    if (Math.random() > 0.8)
      diagonal()
    else
      land()
  }
  if (grunge) {
    flipV()
    i = 0
    for (; i < 2; i++) {
      randomPickColor()
      ctx.fillStyle = randomColor()
      if (Math.random() > 0.8)
        diagonal()
      else
        land()
      document.getElementById("number").value = 3 + Math.random() * 10000
      document.getElementById("featuresize").value = 1 + Math.random() * 400
      document.getElementById("opacity").value = 15 + Math.random() + 65
    }
  }
  diss()
  let nf = 2 + Math.floor(Math.random() * 5)
  i = 0
  for (; i < nf; i++) {
    randomPickColor()
    let f = randomPick(functions)
    let a = ''
    if (f == "smudge")
      a = randomPick(args)
    document.getElementById("number").value = 3 + Math.random() * 5000
    document.getElementById("featuresize").value = 5 + Math.random() * 100
    document.getElementById("opacity").value = 15 + Math.random() + 50
    window[f](a)
   // document.getElementById("opacity").value = 5 + Math.random() + 5
  }
  diss()
  //impasto()
  document.getElementById("opacity").value = 5 + Math.random() + 5
  ctx.globalAlpha = document.getElementById("opacity").value/100
  document.getElementById("opacity").value = 5 + Math.random() + 5
  contrastImage(5 + Math.random() *11)
  document.getElementById("opacity").value = val
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.globalCompositeOperation = "color"
  randomPick(getCurrentPalette()) // was paintcolor = color
  fill()
  //restore values
  ctx.globalCompositeOperation = mode
  refreshMode()
  document.getElementById("opacity").value = val
  document.getElementById("number").value = num
  document.getElementById("featuresize").value = size
  randomPick(getCurrentPalette()) // was paintcolor = color
  ctx.globalAlpha = document.getElementById("opacity").value/100
}

function impasto_smudge () {
  let soft = true
  impasto(soft)
}

function impasto (soft) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let num = document.getElementById("number").value
  let size = document.getElementById("featuresize").value
  let checked = document.getElementById("grungy").checked
  document.getElementById("grungy").checked = false
  let mode = ctx.globalCompositeOperation
  functions = ["dotblur", "jaggyblur", "dirblur"]
  let f = randomPick(functions)
  window[f](canvas)
  f = randomPick(functions)
  window[f](canvas)
  f = randomPick(functions)
  window[f](canvas)
  //restore values
  ctx.globalCompositeOperation = mode
  refreshMode()
  document.getElementById("number").value = num
  document.getElementById("featuresize").value = size
  document.getElementById("grungy").checked = checked
  ctx.globalAlpha = document.getElementById("opacity").value/100
}

function randomTexture () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let val = document.getElementById("opacity").value
  let num = document.getElementById("number").value
  let size = document.getElementById("featuresize").value
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alpha = document.getElementById("opacity").value
  let alt = document.getElementById("grungy").checked

  functions = ["smudge", "smudge", "smudge", "smudge", "smudge", "blobs", "specksRadial", "strokes2", "strokesH"]
  let args = ["", "streaks", "arcs", "arcs2", "stars", "horizontal"]
  let i = 0
  for (; i < 4; i++) {
    randomPickColor()
    let f = randomPick(functions)
    let a = ''
    if (f == "smudge")
      a = randomPick(args)
    document.getElementById("number").value = 3 + Math.random() * 10000
    document.getElementById("featuresize").value = 1 + Math.random() * 400
    document.getElementById("opacity").value = 15 + Math.random() + 75
    if (alt) {
      ctx.save()
      clipIrregular()
    }
    window[f](a)
    if (alt)
      ctx.restore()
  }
  sobel()
  document.getElementById("opacity").value = 50
  alphaWhite()
  if (Math.random() > 0.6)
    alphaBlack()
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "source-atop"
  ctx.fillStyle = color
  ctx.fillRect(0,0,canvas.width, canvas.height)
  ctx.globalCompositeOperation = "difference"//"destination-out"
  functions = functions.slice(0, -1)
  functions.push("rays")
  i = 0
  for (; i < 3; i++) {
    randomPickColor()
    let f = randomPick(functions)
    let a = ''
    if (f == "smudge")
      a = randomPick(args)
    document.getElementById("number").value = 3 + Math.random() * 10000
    document.getElementById("featuresize").value = 1 + Math.random() * 400
    document.getElementById("opacity").value = 25 + Math.random() + 70
    if (alt) {
      ctx.save()
      clipIrregular()
    }
    window[f](a)
    if (alt)
      ctx.restore()
  }
  document.getElementById("opacity").value = val
  document.getElementById("number").value = num
  document.getElementById("featuresize").value = size
  randomPick(getCurrentPalette()) // was paintcolor = color
  ctx.globalCompositeOperation = mode
  ctx.globalAlpha = alpha/100
  refreshMode()
}

function randomTexture2 () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let val = document.getElementById("opacity").value
  let num = document.getElementById("number").value
  let size = document.getElementById("featuresize").value
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alpha = document.getElementById("opacity").value
  let alt = document.getElementById("grungy").checked
  let mode = ctx.globalCompositeOperation
  functions = ["smudge", "smudge", "smudge", "smudge", "smudge", "blobs", "rays", "strokes2", "strokesH"]
  let args = ["", "streaks", "arcs", "arcs2", "stars", "horizontal", "watercolor"]
  let i = 0
  ctx.globalAlpha = val/100
  ctx.fillStyle = color
  ctx.fillRect(0,0,canvas.width, canvas.height)
  ctx.globalCompositeOperation = "destination-out"
  for (; i < 6; i++) {
    let f = randomPick(functions)
    let a = ''
    if (f == "smudge")
      a = randomPick(args)
    document.getElementById("number").value = 33 + Math.random() * 10000
    document.getElementById("featuresize").value = 200 + Math.random() * 200
    document.getElementById("opacity").value = 50 + Math.random() + 30
    if (f == "strokes2" || f == "strokesH" || f == "blobs") {
      document.getElementById("opacity").value = 9 + Math.random() + 15
    }
    if (alt) {
      ctx.save()
      clipIrregular()
    }
    window[f](a)
    if (alt)
      ctx.restore()
  }
  document.getElementById("opacity").value = val
  document.getElementById("number").value = num
  document.getElementById("featuresize").value = size
  randomPick(getCurrentPalette()) // was paintcolor = color
  ctx.globalCompositeOperation = mode
  ctx.globalAlpha = alpha/100
  refreshMode()
}

function draw (canvas, ctx, temp, tempctx) {
  var img = new Image();
  img.onload = function () {
    ctx.drawImage(img, 0, 0);
  };
}

function swap () {// number to divide height by, to match width's divisor
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = 2 + Math.floor(document.getElementById("featuresize").value/10)
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, x = w
  let N = wdivs * hdivs
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let temp = document.createElement('CANVAS')
  let tempctx = temp.getContext("2d")
  temp.width = canvas.width
  temp.height = canvas.height
  let MAX = N/5
  if (MAX > 20)
    MAX = 20
  let src = Math.floor(Math.random() * N)
  let sx = src %W, sy = Math.floor(src/W)
  let dest = Math.floor(Math.random() * N)
  let dx = dest % W, dy = Math.floor(dest/W)
  tempctx.imageSmoothingEnabled = false
  ctx.imageSmoothingEnabled = false
  tempctx.drawImage(canvas, 0, 0, temp.width, temp.height)
  let grunge = document.getElementById("grungy").checkd
  for (; i < MAX; i++) {
    src = Math.floor(Math.random() * N)
    sx = src %W, sy = Math.floor(src/W)
    dest = Math.floor(Math.random() * N)
    dx = dest % W, dy = Math.floor(dest/W)
    if (grunge)
      tempctx.translate(pt(2), pt(2))
    ctx.drawImage(temp, sx*w, sy*h, w, h, dx*w, dy*h, w, h)
    ctx.drawImage(temp, dx*w, dy*h, w, h, sx*w, sy*h, w, h)
    tempctx.drawImage(canvas, 0, 0, temp.width, temp.height)
  }
}

function testHW () {// number to divide height by, to match width's divisor
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let wdivs = 20
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let diff  = (ch - (hdivs*h))
  let i = 0, x = w
  for (; i < wdivs; i++) {
    ctx.beginPath()
    ctx.moveTo(x, 0)
    ctx.lineTo(x,ch)
    ctx.closePath()
    ctx.stroke()
    x += w
  }
  i = 0, y = h
  for (; i < hdivs; i++) {
    ctx.beginPath()
    ctx.moveTo(0, y)
    ctx.lineTo(cw,y)
    ctx.closePath()
    ctx.stroke()
    y += h
  }
  ctx.fillRect(4*w, 4*h, w,h)
  ctx.fillRect(1*w, 4*h, w,h)
  ctx.fillRect(4*w, 1*h, w,h)
  let temp = document.createElement('CANVAS')
  let tempctx = temp.getContext("2d")
  temp.width = w
  temp.height = h
  tempctx.drawImage(canvas, 10*w, 10*h, w, h, 0, 0, temp.width, temp.height)
  ctx.drawImage(canvas, 9*w, 9*h, w, h, 10*w, 10*h, w, h)
  ctx.drawImage(temp, 0, 0, w, h, 9*w, 9*h, w, h)
}

function updateExtraColors (colors) {
  extendedPalette = []
  let i = 0, x = 0, y = 0
  let canvas = document.getElementById("palettecanvas")
  let ctx = canvas.getContext("2d");
  ctx.fillStyle = "#a0a0a0"
  ctx.clearRect(0,0,canvas.width, canvas.height)
  if (colors === null || colors.length < 1)
    return
  for (; i < colors.length; i++) {
    if (i === 10) {
      x = 0
      y += 48
    }
    extendedPalette.push(colors[i])
    ctx.fillStyle = colors[i]
    ctx.fillRect(x,y,48,48)
    x += 48
  }
  document.getElementById("paintcolor").value = extendedPalette[0]
}

function getPaletteFromPickers() {
  let colors = []
  colors.push(document.getElementById("pal1").value)
  colors.push(document.getElementById("pal2").value)
  colors.push(document.getElementById("pal3").value)
  colors.push(document.getElementById("pal4").value)
  colors.push(document.getElementById("pal5").value)
  return colors
}

function testColors (colors) {
  let i = 0, j = 0, bad = []
  let cr1,cr2,d,d2
  for (; i < colors.length; i++) {
    cr1 = /* hextorgb*/(colors[i])
    j = i+1
    for (; j < colors.length; j++) {
      cr2 = (colors[j])
      d = Math.round(
        Math.pow(
        Math.pow(cr1[0] - cr2[0], 2) +
        Math.pow(cr1[1] - cr2[1], 2) +
        Math.pow(cr1[2] - cr2[2], 2),
        0.5))
      d2 = dist3d(cr1, cr2)
      if (d2 < 40)
        bad.push(cr2)
    }
  }
  return bad
}

let BRIGHT = true
function sortByBrightness (colors) {
  if (!colors)
    colors = getCurrentPalette(true)
  if (BRIGHT)
    colors = colors.sort((a, b) => bright(b) - bright(a));
  else
    colors = colors.sort((a, b) => bright(a) - bright(b));
  BRIGHT = !BRIGHT
  updateExtraColors(colors)
}

function sortByHue (colors) {
  if (!colors)
    colors = getCurrentPalette(true)
  colors = colors.sort(function(a, b) {// sort by hue
    let rgb = hextorgb(a)
    let hsva = rgbtohsv(rgb[0], rgb[1], rgb[2])
    rgb = hextorgb(b)
    let hsvb = rgbtohsv(rgb[0], rgb[1], rgb[2])
      return hsva[0] - hsvb[0];
  });
  updateExtraColors(colors)
}

function extractPalette (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  if (isCanvasBlank(canvas))
    return
  let colors = colorSamplePalette(canvas)
  //colors.sort((a, b) => bright(b) - bright(a));
  colors = colors.sort(function(a, b) {// sort by hue
    let rgb = hextorgb(a)
    let hsva = rgbtohsv(rgb[0], rgb[1], rgb[2])
    rgb = hextorgb(b)
    let hsvb = rgbtohsv(rgb[0], rgb[1], rgb[2])
      return hsva[0] - hsvb[0];
  });/**/
  
  colors.sort(function(a, b) { return interesting(b) - interesting(a);});
  if (colors.length >= 1) {
    let i = 0, x = 0, y = 0
    let canvas = document.getElementById("palettecanvas")
    let ctx = canvas.getContext("2d");
    ctx.globalAlpha = 1.0
    /*ctx.fillStyle = "#a0a0a0"
    ctx.clearRect(0,0,canvas.width, canvas.height)
    for (; i < colors.length; i++) {
      if (i === 10) {
        x = 0
        y += 48
      }
      ctx.fillStyle = colors[i]
      ctx.fillRect(x,y,48,48)
      x += 48
    }*/
    document.getElementById("palettechoice").value = "none"
  }
  updateExtraColors(colors)
  return (colors)
}

let htmlcolors = {
  "black": "#000000",
  "silver": "#C0C0C0",
  "gray": "#808080",
  "grey": "#808080",
  "white": "#FFFFFF",
  "maroon": "#800000",
  "red": "#FF0000",
  "purple": "#800080",
  "fuchsia": "#FF00FF",
  "green": "#008000",
  "lime": "#00FF00",
  "olive": "#808000",
  "yellow": "#FFFF00",
  "navy": "#000080",
  "blue": "#0000FF",
  "teal": "#008080",
  "aqua": "#00FFFF",
  "darkblue": "#00008B",
  "mediumblue": "#0000CD",
  "darkgreen": "#006400",
  "darkcyan": "#008B8B",
  "deepskyblue": "#00BFFF",
  "darkturquoise": "#00CED1",
  "mediumspringgreen": "#00FA9A",
  "springgreen": "#00FF7F",
  "cyan": "#00FFFF",
  "midnightblue": "#191970",
  "dodgerblue": "#1E90FF",
  "lightseagreen": "#20B2AA",
  "forestgreen": "#228B22",
  "seagreen": "#2E8B57",
  "darkslategray": "#2F4F4F",
  "darkslategrey": "#2F4F4F",
  "limegreen": "#32CD32",
  "mediumseagreen": "#3CB371",
  "turquoise": "#40E0D0",
  "royalblue": "#4169E1",
  "steelblue": "#4682B4",
  "darkslateblue": "#483D8B",
  "mediumturquoise": "#48D1CC",
  "indigo": "#4B0082",
  "darkolivegreen": "#556B2F",
  "cadetblue": "#5F9EA0",
  "cornflowerblue": "#6495ED",
  "rebeccapurple": "#663399",
  "mediumaquamarine": "#66CDAA",
  "dimgray": "#696969",
  "dimgrey": "#696969",
  "slateblue": "#6A5ACD",
  "olivedrab": "#6B8E23",
  "slategray": "#708090",
  "slategrey": "#708090",
  "lightslategray": "#778899",
  "lightslategrey": "#778899",
  "mediumslateblue": "#7B68EE",
  "lawngreen": "#7CFC00",
  "chartreuse": "#7FFF00",
  "aquamarine": "#7FFFD4",
  "skyblue": "#87CEEB",
  "lightskyblue": "#87CEFA",
  "blueviolet": "#8A2BE2",
  "darkred": "#8B0000",
  "darkmagenta": "#8B008B",
  "saddlebrown": "#8B4513",
  "darkseagreen": "#8FBC8F",
  "lightgreen": "#90EE90",
  "mediumpurple": "#9370DB",
  "darkviolet": "#9400D3",
  "palegreen": "#98FB98",
  "darkorchid": "#9932CC",
  "yellowgreen": "#9ACD32",
  "sienna": "#A0522D",
  "brown": "#A52A2A",
  "darkgray": "#A9A9A9",
  "darkgrey": "#A9A9A9",
  "lightblue": "#ADD8E6",
  "greenyellow": "#ADFF2F",
  "paleturquoise": "#AFEEEE",
  "lightsteelblue": "#B0C4DE",
  "powderblue": "#B0E0E6",
  "firebrick": "#B22222",
  "darkgoldenrod": "#B8860B",
  "mediumorchid": "#BA55D3",
  "rosybrown": "#BC8F8F",
  "darkkhaki": "#BDB76B",
  "mediumvioletred": "#C71585",
  "indianred": "#CD5C5C",
  "peru": "#CD853F",
  "chocolate": "#D2691E",
  "tan": "#D2B48C",
  "lightgray": "#D3D3D3",
  "lightgrey": "#D3D3D3",
  "thistle": "#D8BFD8",
  "orchid": "#DA70D6",
  "goldenrod": "#DAA520",
  "palevioletred": "#DB7093",
  "crimson": "#DC143C",
  "gainsboro": "#DCDCDC",
  "plum": "#DDA0DD",
  "burlywood": "#DEB887",
  "lightcyan": "#E0FFFF",
  "lavender": "#E6E6FA",
  "darksalmon": "#E9967A",
  "violet": "#EE82EE",
  "palegoldenrod": "#EEE8AA",
  "lightcoral": "#F08080",
  "khaki": "#F0E68C",
  "aliceblue": "#F0F8FF",
  "honeydew": "#F0FFF0",
  "azure": "#F0FFFF",
  "sandybrown": "#F4A460",
  "wheat": "#F5DEB3",
  "beige": "#F5F5DC",
  "whitesmoke": "#F5F5F5",
  "mintcream": "#F5FFFA",
  "ghostwhite": "#F8F8FF",
  "salmon": "#FA8072",
  "antiquewhite": "#FAEBD7",
  "linen": "#FAF0E6",
  "lightgoldenrodyellow": "#FAFAD2",
  "oldlace": "#FDF5E6",
  "magenta": "#FF00FF",
  "deeppink": "#FF1493",
  "orangered": "#FF4500",
  "tomato": "#FF6347",
  "hotpink": "#FF69B4",
  "coral": "#FF7F50",
  "darkorange": "#FF8C00",
  "lightsalmon": "#FFA07A",
  "orange": "#FFA500",
  "lightpink": "#FFB6C1",
  "pink": "#FFC0CB",
  "gold": "#FFD700",
  "peachpuff": "#FFDAB9",
  "navajowhite": "#FFDEAD",
  "moccasin": "#FFE4B5",
  "bisque": "#FFE4C4",
  "mistyrose": "#FFE4E1",
  "blanchedalmond": "#FFEBCD",
  "papayawhip": "#FFEFD5",
  "lavenderblush": "#FFF0F5",
  "seashell": "#FFF5EE",
  "cornsilk": "#FFF8DC",
  "lemonchiffon": "#FFFACD",
  "floralwhite": "#FFFAF0",
  "snow": "#FFFAFA",
  "lightyellow": "#FFFFE0",
  "ivory": "#FFFFF0"
}

function closestHTMLColor (c) {
  let colors = Object.values(htmlcolors), i = 0
  let min = 100000, mincolor = c, idx = 0
  for (; i < colors.length; i++) {
    let d = colorDistance(c, colors[i])
    if (d < min) {
      min = d
      mincolor = colors[i]
      idx = i
    }
  }
  return [mincolor, Object.keys(htmlcolors)[idx]]
}

function closestColor (c) {
  let colors = Object.values(pantonecolors)[1], i = 0
  let min = 100000, mincolor = c, idx = 0
  for (; i < colors.length; i++) {
    let d = colorDistance(c, colors[i])
    if (d < min) {
      min = d
      mincolor = colors[i]
      idx = i
    }
  }
  return [mincolor, Object.values(pantonecolors)[0][idx]]
}

function colorDistance (c1, c2) {
  return Math.abs(hexToR(c1) - hexToR(c2)) + Math.abs(hexToG(c1) - hexToG(c2)) + Math.abs(hexToB(c1) - hexToB(c2))/3
}

function showHex () {
  let colors = getCurrentPalette(true)
  let hex = "Hex values\n", i = 0
  for (; i < colors.length; i++)
    hex += "\"" + colors[i] + "\", "
  let pan = ""
  i = 0
  for (; i < colors.length; i++) {
    pan += closestColor(colors[i])+"\n"
  }
  // show code for palette
  let code = "\nif (type === '<name>') {\n  b = [\""+colors.join('", "')+"\"]\n  updateExtraColors(b)\n}"
  console.log(code)
  alert(hex+"\n\nClosest Pantone matches\n"+pan)
}

function simplifyColors () {
  return colorSamplePalette (document.getElementById("myCanvas"), true)
}

function colorSamplePalette (canvas, SIMPLIFY) {
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d");
  let off = document.createElement('CANVAS')
  let offctx = off.getContext("2d");
  let W = canvas.width, H = canvas.height
  let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  if (document.getElementById("grungy").checked)
    imgData = ctx.getImageData(W/10, H/10, W-2*W/10, H-2*H/10)
  if (SIMPLIFY)
    imgData = ctx.getImageData(0, 0, W, H)
  let pixels = imgData.data;
  let sample = []
  let i = 0, j = 0
  let r = 6e-11*pixels.length + 0.995
  if (r > 0.998)
    r = 0.998
  for (; i < pixels.length; i += 4) {
    if (Math.random() > r) {
      let n = i
      let c = []
      c.push(pixels[n])
      c.push(pixels[n+1])
      c.push(pixels[n+2])
      if (pixels[n+3] > 0) // don't push transparent pixels
        sample.push(c)
    }
  }

  i = 0
  let m = 0, ct = 0
  for (; i < sample.length; i++) {
    j = i + 1
    for (; j < sample.length; j++) {
      m += dist3d(sample[i], sample[j])
      ct++
    }
  }
  let threshold = m/ct/2.2
  let bins = [], bc = 0
  i = 0
  for (;i < sample.length; i++) {
    if (sample[i]) {
      bins.push([sample[i]])
      let bc = bins.length - 1
      j = i + 1
      for (; j < sample.length; j++) {
        if (sample[j] && dist3d(sample[j], bins[bc][0]) < threshold) { // low threshold ~ more colors
          bins[bc].push(sample[j])
          sample[j] = null
        }
      }
    }
  }
  bins.sort(function(a, b) { return b.length - a.length;});
  let count = bins.length;
  if (count > 20)
    count = 20
  let colors = [], clrs = []
  i = 0
  for (; i < count; i++) {
    colors.push(averageColor(bins[i]))
    clrs.push(averageColor(bins[i], true))
  }
  let bad = testColors(clrs)
  clrs = clrs.filter(x => !bad.includes(x));
  //resort clrs by interesting: gets rid of black, white and grays
  //clrs.sort(function(a, b) { return interesting(b) - interesting(a);});
  let colors2 = []
  i = 0, j = 0
  for (; i < clrs.length; i++) {
    let rgb = clrs[i]
    let R = ('0'+(rgb[0]).toString(16)).slice(-2),
    G = ('0'+(rgb[1]).toString(16)).slice(-2),
    B = ('0'+(rgb[2]).toString(16)).slice(-2);
    colors2.push('#'+R+G+B)
  }
  // replace - simplify
  if (SIMPLIFY) {
    let c
    i = 0, j = 0
    for (; i < pixels.length; i += 4) {
      c = minDistance (clrs, pixels, i)
      pixels[i] = c[0]
      pixels[i+1] = c[1]
      pixels[i+2] = c[2]
    }
    ctx.putImageData(imgData, 0, 0);
  }
  extendedPalette = colors2
  return colors2
}

function tintByCloseness () {
  canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d");
  let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  let pixels = imgData.data;
  let colors = getCurrentPalette(true) // need more colors. post extract colors
  let clrs = []
  let i = 0, R,G,B
  for (; i < colors.length; i++) {
    R = hexToR(colors[i])
    G = hexToG(colors[i])
    B = hexToB(colors[i])
    clrs.push([R,G,B])
  }
  let c
  i = 0, j = 0
  for (; i < pixels.length; i += 4) {
    c = minDistance (clrs, pixels, i)
    pixels[i] = c[0]
    pixels[i+1] = c[1]
    pixels[i+2] = c[2]
  }
  ctx.putImageData(imgData, 0, 0);
}


function filter (n) { // red only
  if (n < 0 || n > 2) return
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d");
  let offcanvas = document.createElement('CANVAS')
  let offctx = canvas.getContext("2d");
  offcanvas.width = canvas.width
  offcanvas.height = canvas.height
  offctx.drawImage(canvas, 0,0)
  let imgData = offctx.getImageData(0, 0, canvas.width, canvas.height);
  let pixels = imgData.data;
  let i = 0
  let c
  i = 0, j = 0
  for (; i < pixels.length; i += 4) {
    pixels[i+n] /= 2
    //pixels[i+1] /= 2
    //pixels[i+2] /= 2
   // pixels[i+3] = pixels[i]
  }
  ctx.putImageData(imgData, 0, 0);
}


function exposureInfo () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let mind = 1000000
  let maxd = -1000000
  let minbright = 1, maxbright = 0, b = 0, colorfull = 0, averageb = 0
  let pixels = imgData.data;
  let sample = []
  let i = 0, j = 0
  for (; i < 2000; i++) {
    let n = 4 * Math.floor(Math.random() * pixels.length/4)
    let c = []
    c.push(pixels[n])
    c.push(pixels[n+1])
    c.push(pixels[n+2])
    colorfull += interesting(c)
    b = (pixels[n] + pixels[n+2] + pixels[n+2])/(3*255)
    averageb += b
    maxbright = (b > maxbright)? b: maxbright;
    minbright = (b < minbright)? b: minbright
    sample.push(c)
  }
  i = 0, j = 1, total = 0
  let m = 0, averaged = 0
  for (; i < sample.length; i++) {
    j = i + 1
    for (; j < sample.length; j++) {
      m = dist3d(sample[i], sample[j])
      averaged += m
      maxd = (maxd < m)? m: maxd
      total++
    }
  }
  averageb /= 2000
  averaged /= (total)
  averaged /= 441.6729559300637
  maxd /= 441.6729559300637
  colorfull /= (255*2000)
  
 // alert("W: "+canvas.width+" H: "+canvas.height+"\ny: "+LASTCLICK[1] +"\n"+objToString(ctx))
  alert("W: "+canvas.width+" H: "+canvas.height+"\nExposure Info\n\nmin brightness: "+Math.round(100*minbright)/100+ ", max brightness: "+Math.round(maxbright*100)/100+"\naverage brightness: "+Math.round(100*averageb)/100+"\nrange: "+Math.round(100*(maxbright-minbright))/100+"\n\nmax tonal distance: "+Math.round(100*maxd)/100 + "\naverage tonal distance: "+Math.round(100*averaged)/100+"\ncolorfullness: "+Math.round(100*colorfull)/100+"\n\n"+objToString(ctx))
}

function minDistance (colors, pixels, i) {
  let minD = 10000000, j = 0, d, index = 0
  for (; j < colors.length; j++) {
    d = dist3d(colors[j], [pixels[i], pixels[i+1], pixels[i+2]])
    if (d < minD) {
      index = j
      minD = d
    }
  }
  return colors[index]
}

function averageColor (b, dec) {
  let aR = 0, aG = 0, aB = 0
  let i = 0
  for (; i < b.length; i++) {
    aR += b[i][0]
    aG += b[i][1]
    aB += b[i][2]
  }
  aR = Math.floor(aR/b.length)
  aG = Math.floor(aG/b.length)
  aB = Math.floor(aB/b.length)
  
  let R = ('0'+(aR).toString(16)).slice(-2),
  G = ('0'+(aG).toString(16)).slice(-2),
  B = ('0'+(aB).toString(16)).slice(-2);
  if (dec)
    return [aR,aG,aB]
  else
    return '#'+R+G+B;
}

function dist3d (p1, p2) {
  let rmean = (p1[0] + p2[0]) / 2
  let r = p1[0] - p2[0]
  let g = p1[1] - p2[1]
  let b = p1[2] - p2[2]
  return Math.sqrt((((512+rmean)*r*r)>>8) + 4*g*g + (((767-rmean)*b*b)>>8))
 //https://www.compuphase.com/cmetric.htm
}

/**
 * Compare color difference in RGB
 * @param {Array} rgb1 First RGB color in array
 * @param {Array} rgb2 Second RGB color in array
 */
function dist3deltaE (rgb1, rgb2) {
  const [ r1, g1, b1 ] = rgb1,
        [ r2, g2, b2 ] = rgb2,
        drp2 = Math.pow(r1 - r2, 2),
        dgp2 = Math.pow(g1 - g2, 2),
        dbp2 = Math.pow(b1 - b2, 2),
        t = (r1 + r2) / 2
  return Math.sqrt(2 * drp2 + 4 * dgp2 + 3 * dbp2 + t * (drp2 - dbp2) / 256)
 // return sqrt((((512+rmean)*r*r)>>8) + 4*g*g + (((767-rmean)*b*b)>>8));
}

/**
 * calculate the perceptual distance between colors in CIELAB
 * https://github.com/THEjoezack/ColorMine/blob/master/ColorMine/ColorSpaces/Comparisons/Cie94Comparison.cs
 *
 * @param {Array} labA First LAB color in array
 * @param {Array} labB Second LAB color in array
 */
function deltaE(labA, labB){
  var deltaL = labA[0] - labB[0];
  var deltaA = labA[1] - labB[1];
  var deltaB = labA[2] - labB[2];
  var c1 = Math.sqrt(labA[1] * labA[1] + labA[2] * labA[2]);
  var c2 = Math.sqrt(labB[1] * labB[1] + labB[2] * labB[2]);
  var deltaC = c1 - c2;
  var deltaH = deltaA * deltaA + deltaB * deltaB - deltaC * deltaC;
  deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
  var sc = 1.0 + 0.045 * c1;
  var sh = 1.0 + 0.015 * c1;
  var deltaLKlsl = deltaL / (1.0);
  var deltaCkcsc = deltaC / (sc);
  var deltaHkhsh = deltaH / (sh);
  var i = deltaLKlsl * deltaLKlsl + deltaCkcsc * deltaCkcsc + deltaHkhsh * deltaHkhsh;
  return i < 0 ? 0 : Math.sqrt(i);
}

function dist3dOG (p1, p2) {
  rmean = (p1[0] + p2[0])/2
  return Math.sqrt((2+rmean/256) * Math.pow(p1[0] - p2[0], 2) + 4 * Math.pow(p1[1] - p2[1], 2)  +  (2+(255-rmean)/256) * Math.pow(p1[2] - p2[2], 2))
}

function dist3d__ (p1, p2) {
  return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2) + Math.pow(p1[2] - p2[2], 2))
}

function interesting (color) {
  let diff = Math.max(color[0], color[1], color[2]) - Math.min(color[0], color[1], color[2])
  return diff
}

function colorfulScore (color, average) {
  let score = Math.abs(color[0] - average)
      score += Math.abs(color[1] - average)
      score += Math.abs(color[2] - average)
  return score
}
function bright (c) { //-ness
  return (hexToR(c)*0.2126 + hexToG(c)*0.7152 + hexToB(c)*0.0722)
}

async function palettetint (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let alt = document.getElementById("grungy").checked
  let alpha = document.getElementById("opacity").value
  let colors = []
  colors = getCurrentPalette()
  /*
  colors.push(document.getElementById("pal1").value)
  colors.push(document.getElementById("pal2").value)
  colors.push(document.getElementById("pal3").value)
  colors.push(document.getElementById("pal4").value)
  colors.push(document.getElementById("pal5").value)*/
  let saved = randomPick(getCurrentPalette()) // was paintcolor

  let level = 20
  let lows = [100, 83.33, 66.67, 50, 16.67]
  let highs = [100, 83.33, 66.67, 50, 16.67].reverse()
  
  if (!alt) {
    lows = [100, 80, 60, 40, 20]
    highs = [100, 80, 60, 40, 20].reverse()
  }
  let i = 0
  for (; i < colors.length; i++) {
    randomPick(getCurrentPalette()) // was paintcolor = colors[i]
    document.getElementById("lower").value = lows[i]
    document.getElementById("upper").value = highs[i]
    tint()
  }
  document.getElementById("lower").value = 100
  document.getElementById("upper").value = 100
  rangecheck()
  randomPick(getCurrentPalette()) // was paintcolor = saved
  ctx.globalAlpha = alpha
  return true
}

async function palettetint_2ramps (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let alt = document.getElementById("grungy").checked
  let alpha = document.getElementById("opacity").value
  let colors = []
  colors.push(document.getElementById("pal1").value)
  colors.push(document.getElementById("pal2").value)
  colors.push(document.getElementById("pal3").value)
  colors.push(document.getElementById("pal4").value)
  colors.push(document.getElementById("pal5").value)
  let saved = randomPick(getCurrentPalette()) // was paintcolor

  let level = 20
  let lows = [100, 83.33, 66.67, 50, 16.67]
  let highs = [100, 83.33, 66.67, 50, 16.67].reverse()
  
  if (!alt) {
    lows = [100, 80, 60, 40, 20]
    highs = [100, 80, 60, 40, 20].reverse()
  }
  let i = 0
  randomPick(getCurrentPalette()) // was paintcolor = colors[0]
  tintlow()
  randomPick(getCurrentPalette()) // was paintcolor = colors[4]
  tinthigh()
  document.getElementById("lower").value = 100
  document.getElementById("upper").value = 100
  rangecheck()
  randomPick(getCurrentPalette()) // was paintcolor = saved
  ctx.globalAlpha = alpha
  return true
}

async function posterize (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let threshold = 127 - document.getElementById("opacity").value * 1.27
  let grunge = document.getElementById("grungy").checked
  let t1 = 255 * 1/5
  let t2 = 255 * 2/5
  let t3 = 255 * 3/5
  let t4 = 255 * 4/5
  let colors = []
  colors = getCurrentPalette()
  /*
  colors.push(document.getElementById("pal1").value)
  colors.push(document.getElementById("pal2").value)
  colors.push(document.getElementById("pal3").value)
  colors.push(document.getElementById("pal4").value)
  colors.push(document.getElementById("pal5").value)*/
  let c = colors[0]
  
  let pixels = imgData.data;
  let i = 0
  for (; i < pixels.length; i += 4) {
    let lightness = pixels[i] * 0.2126 + pixels[i+1] * 0.7152 + pixels[i+2] * 0.0722;
    //let lightness = (pixels[i] + pixels[i+1] + pixels[i+2])/3;
    if (lightness < t1) {
      c = colors[0]
      pixels[i] =   hexToR(c)
      pixels[i+1] = hexToG(c)
      pixels[i+2] = hexToB(c)
    } else
    if (lightness >= t1 && lightness < t2) {
      c = colors[1]
      pixels[i] =   hexToR(c)
      pixels[i+1] = hexToG(c)
      pixels[i+2] = hexToB(c)
    } else
    if (lightness >= t2 && lightness < t3) {
      c = colors[2]
      pixels[i] =   hexToR(c)
      pixels[i+1] = hexToG(c)
      pixels[i+2] = hexToB(c)
    } else
    if (lightness >= t3 && lightness < t4) {
      c = colors[3]
      pixels[i] =   hexToR(c)
      pixels[i+1] = hexToG(c)
      pixels[i+2] = hexToB(c)
    } else
    if (lightness >= t4) {
      c = colors[4]
      pixels[i] =   hexToR(c)
      pixels[i+1] = hexToG(c)
      pixels[i+2] = hexToB(c)
    }
  }
  await ctx.putImageData(imgData, 0, 0);
  return true
}

async function posterize2 (canvas, outctx,x,y,w,h) {
  let ctx = canvas.getContext("2d");
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let threshold = 127 - document.getElementById("opacity").value * 1.27
  let t1 = 255 * 1/4
  let t2 = 255 * 1/2
  let t3 = 255 * 3/4
  let colors = []
  colors = getCurrentPalette()
  /*
  colors.push(document.getElementById("pal1").value)
  colors.push(document.getElementById("pal2").value)
  colors.push(document.getElementById("pal3").value)
  colors.push(document.getElementById("pal4").value)*/
  let c = colors[0]
  let pixels = imgData.data;
  let i = 0
  for (; i < pixels.length; i += 4) {
    let lightness = pixels[i] * 0.2126 + pixels[i+1] * 0.7152 + pixels[i+2] * 0.0722;
    if (lightness < t1) {
      c = colors[0]
      pixels[i] =   hexToR(c)/2
      pixels[i+1] = hexToG(c)/2
      pixels[i+2] = hexToB(c)/2
    } else
    if (lightness >= t1 && lightness < t2) {
      c = colors[1]
      pixels[i] =   hexToR(c) * 0.8
      pixels[i+1] = hexToG(c) * 0.8
      pixels[i+2] = hexToB(c) * 0.8
    } else
    if (lightness >= t2 && lightness < t3) {
      c = colors[2]
      pixels[i] =   Math.max(hexToR(c), (hexToR(c) * 1.2) % 256)
      pixels[i+1] = Math.max(hexToG(c), (hexToG(c) * 1.2) % 256)
      pixels[i+2] = Math.max(hexToB(c), (hexToB(c) * 1.2) % 256)
    } else
    if (lightness >= t3) {
      c = colors[3]
      pixels[i] =   Math.max(hexToR(c), (hexToR(c) * 2) % 256)
      pixels[i+1] = Math.max(hexToG(c), (hexToG(c) * 2) % 256)
      pixels[i+2] = Math.max(hexToB(c), (hexToB(c) * 2) % 256)
    }
  }
  await outctx.putImageData(imgData,x,y,0,0,w,h);
  return true
}

function leftCut () {
  const cut = true
  leftClip(cut)
  syncMarker()
}

function fourbyfour () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = canvas.height, W = canvas.width
  let off = document.createElement('CANVAS')
  off.height = H/2, off.width = W/2
  let offctx = off.getContext("2d")
  offctx.drawImage(canvas,0,0,W/2,H/2)
  //offctx.globalCompositeOperation = "overlay"
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let warhol = document.getElementById("grungy").checked
  randomPick(getCurrentPalette()) // was paintcolor = randomColor()
  let D = (Math.floor(33+Math.random() * 255) % 256)
  let colors = []
  colors.push(randomColor())
  colors.push(randomColor())
  colors.push(randomColor())
  posterize2(off,ctx,0,0,W/2,H/2)
  .then(
    posterize2(off,ctx,W/2,0,W/2,H/2))
  .then(
    posterize2(off,ctx,0,H/2,W/2,H/2))
  .then(
    posterize2(off,ctx,W/2,H/2,W/2,H/2)
    )
  randomPick(getCurrentPalette()) // was paintcolor = color
  return true
}

function fourbyfourplain () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = canvas.height, W = canvas.width
  let off = document.createElement('CANVAS')
  off.height = H/2, off.width = W/2
  let offctx = off.getContext("2d")
  offctx.drawImage(canvas,0,0,W/2,H/2)
  //offctx.globalCompositeOperation = "overlay"
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let warhol = document.getElementById("grungy").checked
  randomPick(getCurrentPalette()) // was paintcolor = randomColor()
  let D = (Math.floor(33+Math.random() * 255) % 256)
  let colors = []
  colors.push(randomColor())
  colors.push(randomColor())
  colors.push(randomColor())
  drawSome(ctx,off,0,0,W/2,H/2)
  .then(
    drawSome(ctx,off,W/2,0,W/2,H/2))
  .then(
    drawSome(ctx,off,0,H/2,W/2,H/2))
  .then(
    drawSome(ctx,off,W/2,H/2,W/2,H/2)
    )
  randomPick(getCurrentPalette()) // was paintcolor = color
  return true
}

async function drawSome (ctx,can,x,y,W,H) {
  await ctx.drawImage(can,x,y,W,H)
  return true
}

function shrinkBlur (PUSH) {
  zoom_neg()
  zoom_neg()
  zoom_neg()
  zoom()
  zoom()
  zoom()
  if (PUSH)
    pushFunction("shrinkBlur")
}

function distortion () {
  let canvas = document.getElementById("myCanvas")
  let alt = document.getElementById("grungy").checkd
  let ctx = canvas.getContext("2d")
  let cx = LASTCLICK[0]// canvas.width/2,
      cy = LASTCLICK[1]//canvas.height/2,
      sizew = canvas.width,
      sizeh = canvas.height
  let imgData = ctx.getImageData(0, 0, sizew, sizeh);
      pixels = imgData.data,
      pixelsCopy = [], index = 0, h = sizeh, w = sizew;
  let i = 0
  for (; i <= pixels.length; i+=4) {
    pixelsCopy[index] = [pixels[i], pixels[i+1], pixels[i+2], pixels[i+3]];
    index++;
  }
  let result = fisheye(pixelsCopy, w, h);
  i = 0
  for(; i < result.length; i++) {
    index = 4*i;
    if (result[i] != undefined) {
      pixels[index + 0] = result[i][0];
      pixels[index + 1] = result[i][1];
      pixels[index + 2] = result[i][2];
      pixels[index + 3] = result[i][3];
    }
  }
  if (alt) {
    ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
    ctx.fillRect(0,0,sizew, sizeh)
  }
  ctx.putImageData(imgData, 0, 0);
}

function fisheye (srcpixels, w, h) {
  let dstpixels = srcpixels.slice();
  let y = 0
  for (; y < h; y++) {
    let ny = ((2*y)/h)-1;
    let ny2 = ny*ny;
    let x = 0
    for (; x < w; x++) {
      let nx = ((2*x)/w)-1;
      let nx2 = nx*nx;
      let r = Math.sqrt(nx2+ny2);
      if (0.0 <= r && r <= 1.0) {
        let nr = Math.sqrt(1.0-r*r);
        nr = (r + (1.0-nr)) / 2.0;
        if (nr <= 1.0) {
          let theta = Math.atan2(ny,nx);
          let nxn = nr*Math.cos(theta);
          let nyn = nr*Math.sin(theta);
          let x2 = parseInt(((nxn+1)*w)/2);
          let y2 = parseInt(((nyn+1)*h)/2);
          let srcpos = parseInt(y2*w+x2);
          if (srcpos >= 0 & srcpos < w*h) {
            dstpixels[parseInt(y*w+x)] = srcpixels[srcpos];
          }
        }
      }
    }
  }
  return dstpixels;
}

function wrap (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let canvasoff = document.createElement("CANVAS")
  let ctxoff = canvasoff.getContext("2d")
  ctx.globalAlpha = document.getElementById("opacity").value/100

  let W = canvas.width, H = canvas.height
  canvasoff.width = W, canvasoff.height = H
  
  ctxoff.drawImage(canvas,  0,0)
  let D = Math.floor(pet(W/2))
  let half = W/2 + D
  ctx.clearRect(0,0,W,H)
  
  ctx.drawImage(canvasoff,  half,0,W,H, 0,0,W,H)
  ctx.drawImage(canvasoff,  0,0,W,H,  half-D*2,0,W,H)
}

function mirror () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  clearOff()
  flipV()
  copyToOff()
  flipV()
  bottomClip()
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "destination-over"
  pasteFromOff()
  ctx.globalCompositeOperation = mode
}

function bottomClip () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = canvas.height, W = canvas.width
  let s = LASTCLICK[1] // Y
  let x = 0, y = s
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(W, y)
  ctx.lineTo(W, H)
  ctx.lineTo(0, H)
  ctx.closePath()
  ctx.clip()
  ctx.clearRect(0,0,W,H)
  ctx.restore()
}

function leftClip (cut) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let mode = ctx.globalCompositeOperation
  let H = canvas.height, W = canvas.width
  let grunge = document.getElementById("grungy").checked
  let alpha = document.getElementById("opacity").value
  let s = LASTCLICK[0]
  if (W-s < 30 && cut) {
    alert("Cannot cut canvas width to less than 30px.")
    return
  }
  let x = 0, y = 0
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(x,y)
  x = s
  ctx.lineTo(x, y)
  y += H+1
  ctx.lineTo(x, y)
  ctx.lineTo(0, y)
  ctx.closePath()
  ctx.clip()
  ctx.clearRect(0,0,W,H)
  ctx.restore()
  ctx.globalAlpha = 1
  let off = document.createElement('CANVAS')
  off.height = canvas.height
  off.width = canvas.width - x
  offctx = off.getContext("2d")
  offctx.drawImage(canvas, -x, 0)
  ctx.clearRect(0,0,W,H)
  if (cut)
    canvas.width -= x
  syncBackground(canvas)
  //document.getElementById("canvaswidth").value = canvas.width
 // document.getElementById("canvasheight").value = canvas.height
  if (cut)
    ctx.drawImage(off, 0, 0)
  else
    ctx.drawImage(off, x, 0)
  ctx.globalCompositeOperation = mode
  ctx.globalAlpha = alpha/100

}

function halfCurve () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = canvas.height, W = canvas.width
  let grunge = document.getElementById("grungy").checked
  let s = document.getElementById("featuresize").value/500
  let half = W*s
  let lx = LASTCLICK[0]
  let offset = 2 + W/(5 + Math.random() * 10)
  let x = 0, y = 0
  if (Math.random() > 0.5)
    offset *= -1
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(x,y)
  x = lx
  ctx.lineTo(x,y)
  ctx.bezierCurveTo(x-offset, H/2, x+offset, H/2, x, H);
  ctx.lineTo(0,H)
  ctx.closePath()
  ctx.clip()
  ctx.clearRect(0,0,W,H)
  ctx.restore()
}

function halfRip () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = canvas.height, W = canvas.width
  let grunge = document.getElementById("grungy").checked
  let alpha = document.getElementById("opacity").value
  let s = document.getElementById("featuresize").value/500
  let half = W*s
  let lx = LASTCLICK[0]
  const offset = 2 + W/100
  let x = 0, y = 0
  x = 0, y = 0
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(x,y)
  x = lx//half-offset
  ctx.lineTo(x, y)
  while (y < H) {
    x += pet(9)
    y += 4 + pet(4)
    ctx.lineTo(x, y)
    if (Math.random() > 0.95)
      y += 9
  }
  ctx.lineTo(0, y)
  ctx.closePath()
  ctx.clip()
  ctx.clearRect(0,0,W,H)
  ctx.restore()
  ctx.globalAlpha = alpha/100
}

function ripFrame () {
  let i = 0
  for (; i < 4;i++) {
    ripSide()
    rc()
  }
}

function ripSide () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = canvas.height, W = canvas.width
  let grunge = document.getElementById("grungy").checked
  const offset = 5 + Math.floor(document.getElementById("featuresize").value/2)
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let alpha = document.getElementById("opacity").value
  let x = 0, y = 0
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(x,y)
  x = offset
  ctx.lineTo(x, y)
  while (y < H) {
    x += pet(4)
    y += 4 + pet(4)
    ctx.lineTo(x, y)
    if (Math.random() > 0.95)
      y += 9
  }
  ctx.lineTo(0, y)
  ctx.closePath()
  ctx.clip()
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  if (grunge)
    ctx.clearRect(0,0,W,H)
  else
    ctx.fill()
  ctx.restore()
  ctx.globalAlpha = alpha/100
}

function bokehs () {
  findBrightSpots(false)
}

function flares () {
  findBrightSpots(true)
}

function findBrightSpots (FLARE) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  off.width = canvas.width
  off.height = canvas.height
  let offctx = off.getContext("2d")
  offctx.drawImage(canvas,0,0)
  offctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let grunge = document.getElementById("grungy").checked
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/400
  let percent = +document.getElementById("number").value/20000
  let i = 0, x = 0, y = 0
  let numsquares = (ch*cw)/100
  let radius = w, j = 0, linecount = 0
  let lightness = 0
  let points = []
  let colors = []
  let offsets = []
  let RADIUS = 1 + Math.floor(document.getElementById("featuresize").value)//radius*10
  for (; i < 6; i++)
    offsets.push((Math.random() - 0.5) * (1 + Math.random()*3))
  for (;j < numsquares; j++) {
    x = Math.floor(Math.random()*cw)
    y = Math.floor(Math.random()*ch)
    let imgData = ctx.getImageData(x, y, w, w) // keep square: w === w
    let threshold = 127 - document.getElementById("opacity").value * 1.27
    let pixels = imgData.data
    i = 0, lightness = 0
    let r = 0, g = 0, b = 0
    for (; i < pixels.length; i += 4) {
      r += parseInt(pixels[i])
      g += parseInt(pixels[i+1])
      b += parseInt(pixels[i+2])
      lightness += parseInt((pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3)
    }
    lightness /= (pixels.length/4) //avg = 0 to 255
    if (lightness > 200) {
      r /= pixels.length/4
      g /= pixels.length/4
      b /= pixels.length/4
      let R = ('0'+(Math.round(r)).toString(16)).slice(-2),
          G = ('0'+(Math.round(g)).toString(16)).slice(-2),
          B = ('0'+(Math.round(b)).toString(16)).slice(-2);
      points.push([x+w,y+w,"#"+R+G+B,RADIUS+pet(RADIUS/2)])
    }
  }
  // filter points that are too close togeteher
  points = shuffle(points)
  let filteredpoints = []
  let maxpoints = points.length * percent
  i = 0
  for (; i < maxpoints; i++) {
    if (i == 0 || distance(points[i-1][0], points[i-1][1], points[i][0], points[i][1] ) > 90)
      filteredpoints.push(points[i])
  }
  i = 0
  for (; i < filteredpoints.length; i++) {
    if (FLARE)
      flareAt(filteredpoints[i][0],filteredpoints[i][1],filteredpoints[i][3],filteredpoints[i][2],ctx.globalAlpha/5,offctx, offsets)
    else
      bokehAt(filteredpoints[i][0], filteredpoints[i][1], filteredpoints[i][3], filteredpoints[i][2], ctx.globalAlpha/10, offctx)
  }
  ctx.drawImage(off, 0, 0)
}

function sampleImageDataR () { // darkness
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  off.width = canvas.width
  off.height = canvas.height
  let offctx = off.getContext("2d")
  offctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let grunge = document.getElementById("grungy").checked
  // set above as in rectify
  let W = 0.5 + Math.floor(document.getElementById("featuresize").value/2)
  //invert range of W [2- 102] => [102 - 2]
  W = 251 - W + 0.5
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, x = 0, y = 0
  let ox = 0, oy = -w*2
  let numsquares = (1+wdivs) * (1+hdivs)
  let radius = w, j = 0, linecount = 0
  let lightness = 0
  for (;j < numsquares; j++) {
    let imgData = ctx.getImageData(x, y, w, h)
    let threshold = 127 - document.getElementById("opacity").value * 1.27
    let pixels = imgData.data
    let i = 0, lightness = 0
    for (; i < pixels.length; i += 4) {
      lightness += parseInt((pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3)
    }
    lightness /= (pixels.length/4) //avg = 0 to 255
    // invert scale
    lightness = 255 - lightness
    radius = lightness/255 * w/2
    offctx.beginPath()
    offctx.arc(x+w/2, y+h/2-oy, radius, 0, Math.PI*2)
    offctx.closePath()
    offctx.fill()
    x += w
   
    oy += h
    if (oy > h*2)
      oy = 0
    
    if (x >= (wdivs)*w) {
      linecount++
      if (!grunge && linecount % 2 == 1)
        x = -w/2
      else
        x = 0
      y += h
    }
  }
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(off, 0, 0)
}

function sampleImageData () { // darkness
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  off.width = canvas.width
  off.height = canvas.height
  let offctx = off.getContext("2d")
  offctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let grunge = document.getElementById("grungy").checked
  // set above as in rectify
  let W = 0.5 + Math.floor(document.getElementById("featuresize").value/2)
  //invert range of W [2- 102] => [102 - 2]
  W = 251 - W + 0.5
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, x = 0, y = 0
  let numsquares = (1+wdivs) * (1+hdivs)
  let radius = w, j = 0, linecount = 0
  let lightness = 0
  // outer loop
  for (;j < numsquares; j++) {
    let imgData = ctx.getImageData(x, y, w, h)
    let threshold = 127 - document.getElementById("opacity").value * 1.27
    let pixels = imgData.data
    let i = 0, lightness = 0
    for (; i < pixels.length; i += 4) {
      lightness += parseInt((pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3)
    }
    lightness /= (pixels.length/4) //avg = 0 to 255
    // invert scale
    lightness = 255 - lightness
    radius = lightness/255 * w/2
    offctx.beginPath()
    offctx.arc(x+w/2, y+h/2, radius, 0, Math.PI*2)
    offctx.closePath()
    offctx.fill()
    x += w
    if (x >= (wdivs)*w) {
      linecount++
      if (!grunge && linecount % 2 == 1)
        x = -w/2
      else
        x = 0
      y += h
    }
  }
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(off, 0, 0)
}

function coloretch () {
  etch(true)
}

function etch (color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  off.width = canvas.width
  off.height = canvas.height
  let offctx = off.getContext("2d")
  offctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  offctx.lineCap = "square"
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let grunge = document.getElementById("grungy").checked
  // set above as in rectify
  let W = 0.5 + Math.floor(document.getElementById("featuresize").value/2)
  //invert range of W [2- 102] => [102 - 2]
  W = 251 - W + 0.5
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, j = 0, x = 0, y = 0, ct = 1+ Math.floor(Math.random() * 5)
  let angle = Math.PI * 2 * Math.random()
  let d = h
  let numsquares = (1+wdivs) * (1+hdivs) * 1.2
  let radius = w/6, linecount = 0
  let r0 = radius
  let D = 0
  let lightness = 0
  let points = [], vals = []
  for (;j < numsquares; j++) {
    points[j] = [x, y]
    x += w
    if (x >= (wdivs)*w) {
      linecount++
      if (linecount % 2 === 1)
        x = 0
      y += h/2
    }
  }
  points = shuffle(points) // do this later. before drawing
  let D8 = D/8
  j = 0
  let h2 = 0, w2 = w
  let ORIENT = Math.random()>0.5
  let P = h2
  for (;j < points.length; j++) {
    if (Math.random() > 0.8)
      P = h+h*Math.random()*1.5
    x = points[j][0]
    y = points[j][1]
    let imgData = ctx.getImageData(x, y, w, h)
   // let threshold = 127 - document.getElementById("opacity").value * 1.27
    let pixels = imgData.data
    let i = 0, lightness = 0, r = 0, g = 0, b = 0
    for (; i < pixels.length; i += 4) {
      r += parseInt(pixels[i])
      g += parseInt(pixels[i+1])
      b += parseInt(pixels[i+2])
      lightness += parseInt((pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3)
    }
    if (color) {
      r /= pixels.length/4
      g /= pixels.length/4
      b /= pixels.length/4
      let R = ('0'+(Math.round(r)).toString(16)).slice(-2),
        G = ('0'+(Math.round(g)).toString(16)).slice(-2),
        B = ('0'+(Math.round(b)).toString(16)).slice(-2);
      offctx.strokeStyle = "#"+R+G+B
    }
    lightness /= (pixels.length/4) //avg = 0 to 255
    // invert scale
    lightness = 255 - lightness
    radius = lightness/255 * h
    if(color)
      radius = h
    if (radius > 0.5) {
      offctx.lineWidth = radius*0.8
      offctx.beginPath()
      if (ORIENT)
        offctx.moveTo(x,y+P)
      else
        offctx.moveTo(x,y-P)
      if (ORIENT)
        offctx.lineTo(x+w2, y-P)
      else
        offctx.lineTo(x+w2, y+P)
      offctx.stroke()
    }
  }
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(off, 0, 0)
}

function hatchescolor() {
  hatches(true)
}

function hatches (color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  off.width = canvas.width
  off.height = canvas.height
  let offctx = off.getContext("2d")
  offctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let grunge = document.getElementById("grungy").checked
  // set above as in rectify
  let W = 0.5 + Math.floor(document.getElementById("featuresize").value/2)
  //invert range of W [2- 102] => [102 - 2]
  W = 251 - W + 0.5
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, j = 0, x = 0, y = 0, ct = 1+ Math.floor(Math.random() * 5)
  let angle = Math.PI * 2 * Math.random()
  let d = h/ct
  let numsquares = (1+wdivs) * (1+hdivs)
  let radius = w/6, linecount = 0
  let r0 = radius
  let D = radius * 6
  let lightness = 0
  let p = 0
  let points = []
  for (;j < numsquares; j++) {
    points[j] = [x, y]
    x += w
    if (x >= (wdivs)*w) {
      linecount++
      if (linecount % 2 == 1)
        x = -w/2
      else
        x = 0
      y += h
    }
  }
  if (grunge) {
    x = 0, y = 0
    j = 0, linecount = 0
    for (;j < numsquares; j++) {
      points.push([x, y])
      x += w
      if (x >= (wdivs)*w) {
        linecount++
        if (linecount % 2 == 1)
          x = -w/2
        else
          x = 0
        y += h
      }
    }
  }
  points = shuffle(points)
  let D8 = D/8
  j = 0
  let h2 = h
  let xf = 0, yf = 0
  if (Math.random() > 0.95)
        h2 *= -1
  for (;j < points.length; j++) {
    x = points[j][0]
    y = points[j][1]
    let imgData = ctx.getImageData(x, y, w, h)
    let threshold = 127 - document.getElementById("opacity").value * 1.27
    let pixels = imgData.data
    let i = 0, lightness = 0, r = 0, g = 0, b = 0
    for (; i < pixels.length; i += 4) {
      r += parseInt(pixels[i])
      g += parseInt(pixels[i+1])
      b += parseInt(pixels[i+2])
      lightness += parseInt((pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3)
    }
    if (color) {
      r /= pixels.length/4
      g /= pixels.length/4
      b /= pixels.length/4
      let R = ('0'+(Math.round(r)).toString(16)).slice(-2),
        G = ('0'+(Math.round(g)).toString(16)).slice(-2),
        B = ('0'+(Math.round(b)).toString(16)).slice(-2);
      offctx.strokeStyle = "#"+R+G+B
    }
    lightness /= (pixels.length/4) //avg = 0 to 255
    // invert scale
    lightness = 255 - lightness
    radius = lightness/255 * w/2
    if (color)
      radius = w/2
    if (radius > 0) {
      if (j % 2 == 0)
        h2 *= -1
      offctx.lineWidth = radius
      offctx.beginPath()
      offctx.moveTo(x,y+pet(D)-p)
      //xf = x+h2
      //yf = y-h+pet(D)
     // offctx.bezierCurveTo(x+pet(D), y+pet(D), xf+pet(D), yf+pet(D), xf, yf)
      //offctx.quadraticCurveTo(x+pet(D/2), y+pet(D/2), xf, yf)
      offctx.lineTo(x+h2, y-h+pet(D)+p)
      offctx.stroke()
    }
  }
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(off, 0, 0)
}

function stipple () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  off.width = canvas.width
  off.height = canvas.height
  let offctx = off.getContext("2d")
  offctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let grunge = document.getElementById("grungy").checked
  // set above as in rectify
  let W = 0.5 + Math.floor(document.getElementById("featuresize").value/2)
  //invert range of W [2- 102] => [102 - 2]
  W = 251 - W + 0.5
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, x = 0, y = 0
  let numsquares = (1+wdivs) * (1+hdivs)
  let radius = w/6, linecount = 0
  let r0 = radius
  let D = radius * 6
  let lightness = 0
  
  let points = [], j = 0
  for (;j < numsquares; j++) {
    points[j] = [x, y]
    x += w
    if (x >= (wdivs)*w) {
      linecount++
      if (linecount % 2 == 1)
        x = -w/2
      else
        x = 0
      y += h
    }
  }
  if (grunge) {
    x = 0, y = 0
    j = 0, linecount = 0
    for (;j < numsquares; j++) {
      points.push([x, y])
      x += w
      if (x >= (wdivs)*w) {
        linecount++
        if (linecount % 2 == 1)
          x = -w/2
        else
          x = 0
        y += h
      }
    }
  }
  points = shuffle(points)
  let D8 = D/8
  j = 0
  for (;j < points.length; j++) {
    x = points[j][0]
    y = points[j][1]
    let imgData = ctx.getImageData(x, y, w, h)
    let threshold = 127 - document.getElementById("opacity").value * 1.27
    let pixels = imgData.data
    let i = 0, lightness = 0
    for (; i < pixels.length; i += 4) {
      lightness += parseInt((pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3)
    }
    lightness /= (pixels.length/4) //avg = 0 to 255
    // invert scale
    lightness = 255 - lightness
    radius = lightness/255 * w/2
    if (radius > 0) {
      offctx.beginPath()
      offctx.arc(x+w/2+pet(D), y+h/2+pet(D), radius+Math.random()*D8, 0, Math.PI*2)
      offctx.closePath()
      offctx.fill()
    }
  }
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(off, 0, 0)
}

function mosaic () { // 4 sided
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  off.width = canvas.width
  off.height = canvas.height
  let offctx = off.getContext("2d")
  offctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let grunge = document.getElementById("grungy").checked
  ctx.globalAlpha = document.getElementById("opacity").value/100
  // set above as in rectify
  let W = 2 + Math.floor(document.getElementById("featuresize").value/4)
  //invert range of W [2 - W] => [W - 2]
  W = 128 - W + 2
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, x = 0, y = 0
  let numsquares = (1+wdivs) * (1+hdivs)
  let radius = w*0.475, j = 0
  let linecount = 0
  let r = 0, g = 0, b = 0
  let D = radius * 1
  let r0 = radius
  let points = []
  for (;j < numsquares; j++) {
    points[j] = [x, y]
    x += w
    if (x >= (wdivs)*w) {
      linecount++
      if (linecount % 2 == 1)
        x = -w/2
      else
        x = 0
      y += h
    }
  }
  points = shuffle(points)
  let angle = Math.random() * 2 * Math.PI
  j = 0
  for (;j < points.length; j++) {
    x = points[j][0]
    y = points[j][1]
    let imgData = ctx.getImageData(x, y, w, h)
    let threshold = 127 - document.getElementById("opacity").value * 1.27
    let pixels = imgData.data
    let i = 0, r = 0, g = 0, b = 0
    for (; i < pixels.length; i += 4) {
      r += parseInt(pixels[i])
      g += parseInt(pixels[i+1])
      b += parseInt(pixels[i+2])
    }
    r /= pixels.length/4
    g /= pixels.length/4
    b /= pixels.length/4
    let R = ('0'+(Math.round(r)).toString(16)).slice(-2),
      G = ('0'+(Math.round(g)).toString(16)).slice(-2),
      B = ('0'+(Math.round(b)).toString(16)).slice(-2);
    offctx.fillStyle = "#"+R+G+B
    offctx.beginPath()
    let k = 0
    let x1 = x+w/2+pet(D)
    let y1 = y+h/2+pet(D)
    let sides = 4 + Math.floor(Math.random() * 2) // 4 or 5
    let inc = Math.PI/(sides/2)
    
    radius = r0 + Math.random()*D/2
    angle = Math.random() * 2 * Math.PI
    for (; k < sides; k++) {
      x = x1 + radius * Math.cos(angle);
      y = y1 + radius * Math.sin(angle);
      offctx.lineTo(x, y)
      angle += inc
    }
    offctx.closePath()
    offctx.fill()
  }
  //if (grunge)
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(off, 0, 0)
}


function pointillism2 () { // multi sided
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  off.width = canvas.width
  off.height = canvas.height
  let offctx = off.getContext("2d")
  offctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let grunge = document.getElementById("grungy").checked
  ctx.globalAlpha = document.getElementById("opacity").value/100
  // set above as in rectify
  let W = 2 + Math.floor(document.getElementById("featuresize").value/2)
  //invert range of W [2- 102] => [102 - 2]
  W = 252 - W + 8
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, x = 0, y = 0
  let numsquares = (1+wdivs) * (1+hdivs)
  let radius = w/4, j = 0
  let linecount = 0
  let r = 0, g = 0, b = 0
  let D = radius * 5
  let r0 = radius
  // outer loop
  let points = []
  for (;j < numsquares; j++) {
    points[j] = [x, y]
    x += w
    if (x >= (wdivs)*w) {
      linecount++
      x = 0
      y += h
    }
  }
  points = shuffle(points)
  let inc = Math.PI/2.5
  let angle = Math.random() * 2 * Math.PI
  j = 0
  for (;j < points.length; j++) {
    x = points[j][0]
    y = points[j][1]
    let imgData = ctx.getImageData(x, y, w, h)
    let threshold = 127 - document.getElementById("opacity").value * 1.27
    let pixels = imgData.data
    let i = 0, r = 0, g = 0, b = 0
    for (; i < pixels.length; i += 4) {
      r += parseInt(pixels[i])
      g += parseInt(pixels[i+1])
      b += parseInt(pixels[i+2])
    }
    r /= pixels.length/4
    g /= pixels.length/4
    b /= pixels.length/4
    let R = ('0'+(Math.round(r)).toString(16)).slice(-2),
      G = ('0'+(Math.round(g)).toString(16)).slice(-2),
      B = ('0'+(Math.round(b)).toString(16)).slice(-2);
    offctx.fillStyle = "#"+R+G+B
    //radius = w/2
    offctx.beginPath()
    
    let k = 0
    let x1 = x+w/2+pet(D)
    let y1 = y+h/2+pet(D)
    radius = r0 + Math.random()*D
    angle = Math.random() * 2 * Math.PI
    // draw blobs here
    let maxradius = 2 + radius*0.5;
   
    let np = 5 + Math.floor(Math.random()*7)
    let increase = Math.PI * 2/np*0.98;
    let rc = radius
    for (; k < np; k++) {
      rc = radius + pet(maxradius)
      x = x1 + rc * Math.cos(angle);
      y = y1 + rc * Math.sin(angle);
      offctx.lineTo(x, y)
      angle += increase
      
    }
    offctx.closePath()
    offctx.fill()
  }
  if (grunge)
    ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(off, 0, 0)
}

function pointillismE () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  off.width = canvas.width
  off.height = canvas.height
  let offctx = off.getContext("2d")
  offctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let grunge = document.getElementById("grungy").checked
  ctx.globalAlpha = document.getElementById("opacity").value/100
  // set above as in rectify
  let W = 2 + Math.floor(document.getElementById("featuresize").value/2)
  //invert range of W [2- 102] => [102 - 2]
  W = 251 - W + 2
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, x = 0, y = 0
  let numsquares = (1+wdivs) * (1+hdivs)
  let radius = w/4, j = 0
  let lightness = 0, linecount = 0
  let r = 0, g = 0, b = 0
  let D = radius * 5
  // outer loop
  let points = []
  for (;j < numsquares; j++) {
    points[j] = [x, y]
    x += w
    if (x >= (wdivs)*w) {
      linecount++
      x = 0
      y += h
    }
  }
  points = shuffle(points)
  j = 0
  let rot =  Math.random()*6.18, r1 = radius+Math.random()*D*2, r2 = r1/1.7//radius+Math.random()*D
  for (;j < points.length; j++) {
    x = points[j][0]
    y = points[j][1]
    let imgData = ctx.getImageData(x, y, w, h)
    let threshold = 127 - document.getElementById("opacity").value * 1.27
    let pixels = imgData.data
    let i = 0, r = 0, g = 0, b = 0
    for (; i < pixels.length; i += 4) {
      r += parseInt(pixels[i])
      g += parseInt(pixels[i+1])
      b += parseInt(pixels[i+2])
    }
    r /= pixels.length/4
    g /= pixels.length/4
    b /= pixels.length/4
    let R = ('0'+(Math.round(r)).toString(16)).slice(-2),
      G = ('0'+(Math.round(g)).toString(16)).slice(-2),
      B = ('0'+(Math.round(b)).toString(16)).slice(-2);
    offctx.fillStyle = "#"+R+G+B
    //radius = w/2
    offctx.beginPath()
   // offctx.arc(x+w/2+pet(D), y+h/2+pet(D), radius+Math.random()*D/2, 0, Math.PI*2)
    ellipse1 (offctx, x+w/2+pet(D), y+h/2+pet(D), r1, r2+pet(h/2), rot+pet(0.9))
    offctx.closePath()
    offctx.fill()
  }
  if (grunge)
    ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(off, 0, 0)
}

function pointillism () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  off.width = canvas.width
  off.height = canvas.height
  let offctx = off.getContext("2d")
  offctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let grunge = document.getElementById("grungy").checked
  ctx.globalAlpha = document.getElementById("opacity").value/100
  // set above as in rectify
  let W = 2 + Math.floor(document.getElementById("featuresize").value/2)
  //invert range of W [2- 102] => [102 - 2]
  W = 251 - W + 2
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, x = 0, y = 0
  let numsquares = (1+wdivs) * (1+hdivs)
  let radius = w/4, j = 0
  let lightness = 0, linecount = 0
  let r = 0, g = 0, b = 0
  let D = radius * 5
  // outer loop
  let points = []
  for (;j < numsquares; j++) {
    points[j] = [x, y]
    x += w
    if (x >= (wdivs)*w) {
      linecount++
      x = 0
      y += h
    }
  }
  points = shuffle(points)
  j = 0
  for (;j < points.length; j++) {
    x = points[j][0]
    y = points[j][1]
    let imgData = ctx.getImageData(x, y, w, h)
    let threshold = 127 - document.getElementById("opacity").value * 1.27
    let pixels = imgData.data
    let i = 0, r = 0, g = 0, b = 0
    for (; i < pixels.length; i += 4) {
      r += parseInt(pixels[i])
      g += parseInt(pixels[i+1])
      b += parseInt(pixels[i+2])
    }
    r /= pixels.length/4
    g /= pixels.length/4
    b /= pixels.length/4
    let R = ('0'+(Math.round(r)).toString(16)).slice(-2),
      G = ('0'+(Math.round(g)).toString(16)).slice(-2),
      B = ('0'+(Math.round(b)).toString(16)).slice(-2);
    offctx.fillStyle = "#"+R+G+B
    //radius = w/2
    offctx.beginPath()
    offctx.arc(x+w/2+pet(D), y+h/2+pet(D), radius+Math.random()*D/2, 0, Math.PI*2)
    offctx.closePath()
    offctx.fill()
  }
  if (grunge)
    ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(off, 0, 0)
}

function dotmosaic () {
  let off = document.createElement('CANVAS')
  let offctx = off.getContext('2d')
  let canvas = document.getElementById('myCanvas')
  off.width = canvas.width
  off.height = canvas.height
  let ctx = canvas.getContext('2d'),
      cw = canvas.width,
      ch = canvas.height
      
  let W = 2 + Math.floor(document.getElementById("featuresize").value/25)
  //invert range of W [2 - W] => [W - 2]
  W = 50 - W + 2
  let wdivs = W
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, x = 0, y = 0
  let dotCount = (1+wdivs) * (1+hdivs)
  let dotRadius = w/2
  let halfRadius = dotRadius/2
  let twoPi = Math.PI * 2,
      dotColor = '#0AA594',
      samples = 33, // candidate dots attempted, higher is better
      placedDots = [], // a dot is represented as [x, y]
      initialize = function () {
        let dotsDrawn = 0,
        interval = setInterval(function () {
            placeNewDot();
            dotsDrawn++;
            if (dotsDrawn === dotCount) {
              clearInterval(interval);
              ctx.clearRect(0,0,canvas.width,canvas.height)
              ctx.drawImage(off,0,0)
            }
        }, 0);
      },

      generateRandomPosition = function () {
        return [
        Math.round(Math.random() * cw),
        Math.round(Math.random() * ch),
        1];
      },

      getDistanceToNearestDot = function (dot) {
        let shortest;
        for (let i = placedDots.length - 1; i >= 0; i--) {
          let distance = getDistance(placedDots[i], dot);
          if (!shortest || distance < shortest)
            shortest = distance;
        }
        return shortest;
      },

      getDistance = function (dot1, dot2) {
        let xDistance = Math.abs(dot1[0] - dot2[0]),
            yDistance = Math.abs(dot1[1] - dot2[1]),
            distance = Math.sqrt(Math.pow(xDistance, 2) + Math.pow(yDistance, 2));
        return Math.floor(distance);
      },

      generateBestDot = function () {
        var bestDot, bestDotDistance;
        for (var i = 0; i < samples; i++) {
          var candidateDot = generateRandomPosition(),
              distance;
          if (!placedDots.length) return candidateDot;
          distance = getDistanceToNearestDot(candidateDot);
          if (!bestDot || distance > bestDotDistance) {
              bestDot = candidateDot;
              bestDotDistance = distance;
          }
        }
        bestDot[2] = dotRadius
        return bestDot;
      },

      placeNewDot = function () {
        var dot = generateBestDot();
        placedDots.push(dot);
        drawDot(dot);
      },

      drawDot = function (dot) {
        offctx.beginPath();
        offctx.arc(dot[0], dot[1], dotRadius+pet(halfRadius), 0, twoPi);
        offctx.fillStyle = sampleRectColor(dot, ctx)//randomColor()
        offctx.fill();
      };
      
    initialize();
}

function neighbors (points, canvas) {
  let i = 0, j = 0
  let min_dist = 5//Math.sqrt(canvas.height * canvas.width)/50
  for (; i < points.length; i++) {
    j = 0
    let close = 1000000// +canvas.height * +canvas.width
    for (; j < points.length; j++) {
      if (i !== j) {
        let d = distance (points[i][0], points[i][1], points[j][0], points[j][1])
        if (d < close) {
          points[i][2] = d * 0.84
          close = d
        }
      }
    }
  }
  /*
  let points2 = []
  i = 0
  for (; i < points.length; i++) {
    if (points[i][2] > min_dist) {
      points2.push(points[i])
    }
  }
  i = 0
  for (; i < points2.length; i++) {
    j = 0
    let close = 1000000// +canvas.height * +canvas.width
    for (; j < points2.length; j++) {
      if (i !== j) {
        let d = distance (points2[i][0], points2[i][1], points2[j][0], points2[j][1])
        if (d < close) {
          points2[i][2] = d
          close = d
        }
      }
    }
  }*/
  return points//2
}

function sampleRectColor (p, ctx) {
  let x = p[0], y = p[1], w = p[2], h = w
  let imgData = ctx.getImageData(x, y, w, h)
  let pixels = imgData.data
  let i = 0, r = 0, g = 0, b = 0
  for (; i < pixels.length; i += 4) {
    r += parseInt(pixels[i])
    g += parseInt(pixels[i+1])
    b += parseInt(pixels[i+2])
  }
  r /= pixels.length/4
  g /= pixels.length/4
  b /= pixels.length/4
  let R = ('0'+(Math.round(r)).toString(16)).slice(-2),
    G = ('0'+(Math.round(g)).toString(16)).slice(-2),
    B = ('0'+(Math.round(b)).toString(16)).slice(-2);
  return ("#"+R+G+B)
}
    

function nearest () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  off.width = canvas.width
  off.height = canvas.height
  let offctx = off.getContext("2d")
  offctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let grunge = document.getElementById("grungy").checked
  ctx.globalAlpha = document.getElementById("opacity").value/100
  // set above as in rectify
  let W = 2 + Math.floor(document.getElementById("featuresize").value/4)
  //invert range of W [2 - W] => [W - 2]
  W = 128 - W + 2
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, x = 0, y = 0
  let numsquares = (1+wdivs) * (1+hdivs)
  let radius = w/4, j = 0
  let lightness = 0, linecount = 0
  let r = 0, g = 0, b = 0
  let D = radius * 5
  let angle = Math.random() * 2 * Math.PI
  // outer loop
  let points = []
  for (;j < numsquares; j++) {
    points[j] = [x+Math.random()*D/3, y+Math.random()*D/3, r]
    x += w
    if (x >= (wdivs)*w) {
      linecount++
      if (linecount % 2 == 1)
        x = -w/2
      else
        x = 0
      y += h
    }
  }
  points = neighbors(points, canvas)
  j = 0
  for (;j < points.length; j++) {
    x = points[j][0]
    y = points[j][1]
    radius = points[j][2]*0.9
    let imgData = ctx.getImageData(x, y, w, h)
    let threshold = 127 - document.getElementById("opacity").value * 1.27
    let pixels = imgData.data
    let i = 0, r = 0, g = 0, b = 0
    for (; i < pixels.length; i += 4) {
      r += parseInt(pixels[i])
      g += parseInt(pixels[i+1])
      b += parseInt(pixels[i+2])
    }
    r /= pixels.length/4
    g /= pixels.length/4
    b /= pixels.length/4
    let R = ('0'+(Math.round(r)).toString(16)).slice(-2),
      G = ('0'+(Math.round(g)).toString(16)).slice(-2),
      B = ('0'+(Math.round(b)).toString(16)).slice(-2);
    offctx.fillStyle = "#"+R+G+B
    offctx.beginPath()
    let sides = 4 //+ Math.floor(Math.random() * 2) // 4 or 5
    let inc = Math.PI/(sides/2)
    let x1 = x, y1 = y
    let k = 0
    for (; k < sides; k++) {
      x = x1 + radius * Math.cos(angle);
      y = y1 + radius * Math.sin(angle);
      offctx.lineTo(x, y)
      angle += inc
    }
    offctx.closePath()
    offctx.fill()
  }
 // if (grunge)
    ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(off, 0, 0)
}
/*
function randomBokeh () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  let offctx = off.getContext("2d")
  off.width = canvas.width
  off.height = canvas.height
  let alpha = document.getElementById("opacity").value/100
  let grunge = document.getElementById("grungy").checked
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "lighten"
  let baser = 4 + Math.floor(document.getElementById("featuresize").value/4)
  let W = 500
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, x = 0, y = 0
  let numsquares = ((1+wdivs) * (1+hdivs))/4
  let radius = w, j = 0
  let lightness = 0, linecount = 0
  let r = 0, g = 0, b = 0
  let flares = []
  let threshold = 170
  if (grunge)
    threshold = 140
  for (;j < numsquares; j++) {
    let imgData = ctx.getImageData(x, y, w, h)
    let threshold = 127 - document.getElementById("opacity").value * 1.27
    let pixels = imgData.data
    let i = 0, r = 0, g = 0, b = 0
    for (; i < pixels.length; i += 4) {
      r += parseInt(pixels[i])
      g += parseInt(pixels[i+1])
      b += parseInt(pixels[i+2])
    }
    r /= pixels.length/4
    g /= pixels.length/4
    b /= pixels.length/4
    let R = ('0'+(Math.round(r)).toString(16)).slice(-2),
      G = ('0'+(Math.round(g)).toString(16)).slice(-2),
      B = ('0'+(Math.round(b)).toString(16)).slice(-2);
    let IN = (r+g+b)/3
    if (Math.random() > 0.90 && IN > threshold) {
      flares.push([x+w/2+pet(21), y+h/2+pet(21) ,baser*IN/40,"#"+R+G+B])
    }
    x += w * 2
    if (x >= (wdivs)*w) {
      linecount++
      if (!grunge && linecount % 2 == 1)
        x = -w/2
      else
        x = 0
      y += h * 2
    }
    if (y > ch)
      break
  }
  flares = shuffle(flares)
  i = 0
  for ( ; i < flares.length; i++)
    bokehAt(flares[i][0], flares[i][1], flares[i][2], flares[i][3], alpha, offctx)
  ctx.drawImage(off, 0, 0)
  ctx.globalCompositeOperation = mode
}
*/

function bricks () { //lego
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  off.width = canvas.width
  off.height = canvas.height
  let offctx = off.getContext("2d")
  offctx.fillStyle = "#000000"//randomPick(getCurrentPalette()) // was paintcolor
  let grunge = document.getElementById("grungy").checked
  // set above as in rectify
  let W = 4 + Math.floor(document.getElementById("featuresize").value/5)
  //invert range of W [2- 102] => [102 - 2]
  W = 105 - W + 2
  let text = ""
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, x = 0, y = 0
  let numsquares = (1+wdivs) * (1+hdivs) * 1.2
  let radius = w, j = 0
  let lightness = 0, linecount = 0
  let r = 0, g = 0, b = 0
  offctx.shadowBlur = radius/6
  offctx.shadowColor = "#202020"
  offctx.shadowOffsetX = radius/10
  offctx.shadowOffsetY  = radius/10
  offctx.lineWidth = radius * 0.025
  offctx.lineCap = "round"
  offctx.strokeStyle = "#ffffff"
  for (;j < numsquares; j++) {
    let imgData = ctx.getImageData(x, y, w, h)
    let threshold = 127 - document.getElementById("opacity").value * 1.27
    let pixels = imgData.data
    let i = 0, r = 0, g = 0, b = 0
    for (; i < pixels.length; i += 4) {
      r += parseInt(pixels[i])
      g += parseInt(pixels[i+1])
      b += parseInt(pixels[i+2])
    }
    r /= pixels.length/4
    g /= pixels.length/4
    b /= pixels.length/4
    let R = ('0'+(Math.round(r)).toString(16)).slice(-2),
      G = ('0'+(Math.round(g)).toString(16)).slice(-2),
      B = ('0'+(Math.round(b)).toString(16)).slice(-2);
    offctx.fillStyle = "#"+R+G+B
    radius = w/1.8
    offctx.fillRect(x, y, w, h)
    
    
    offctx.beginPath()
    offctx.arc(x+w/2, y+h/2, radius/2, 0, Math.PI*2)
    offctx.closePath()
    offctx.fill()
    
    offctx.globalAlpha = 0.5
    offctx.beginPath()
    offctx.arc(x+w/2, y+h/2, radius/2, Math.PI, Math.PI*1.5)
    offctx.stroke()
    offctx.globalAlpha = 1.0

    //offctx.shadowBlur = 0

    x += w
    if (x >= (wdivs)*w) {
      linecount++
      x = 0
      y += h
    }
    if (y+h > canvas.height)
      ;//break;
  }
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(off, 0, 0)
  ctx.shadowBlur = 0
  ctx.shadowOffsetY = 0
  ctx.shadowOffsetX = 0
}

function nicksmith () {
  if (document.getElementById("grungy").checked) {
    nicksmithWords()
    return
  }
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  off.width = canvas.width
  off.height = canvas.height
  let offctx = off.getContext("2d")
  offctx.fillStyle = "#000000"//randomPick(getCurrentPalette()) // was paintcolor
  let grunge = document.getElementById("grungy").checked
  // set above as in rectify
  let W = 4 + Math.floor(document.getElementById("featuresize").value/5)
  //invert range of W [2- 102] => [102 - 2]
  W = 105 - W + 2
  let text = ""
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, x = 0, y = 0
  let numsquares = (1+wdivs) * (1+hdivs) * 1.2
  let radius = w, j = 0
  let lightness = 0, linecount = 0
  let r = 0, g = 0, b = 0
  h *= 1.25
  // outer loop
  for (;j < numsquares; j++) {
    let imgData = ctx.getImageData(x, y, w, h)
    let threshold = 127 - document.getElementById("opacity").value * 1.27
    let pixels = imgData.data
    let i = 0, r = 0, g = 0, b = 0
    for (; i < pixels.length; i += 4) {
      r += parseInt(pixels[i])
      g += parseInt(pixels[i+1])
      b += parseInt(pixels[i+2])
    }
    r /= pixels.length/4
    g /= pixels.length/4
    b /= pixels.length/4
    let R = ('0'+(Math.round(r)).toString(16)).slice(-2),
      G = ('0'+(Math.round(g)).toString(16)).slice(-2),
      B = ('0'+(Math.round(b)).toString(16)).slice(-2);
    offctx.fillStyle = "#"+R+G+B
    radius = w/2
    offctx.fillRect(x, y, w*0.9, h*0.9)
    x += w
    if (x >= (wdivs)*w) {
      linecount++
      x = 0
      y += h
    }
    if (y+h > canvas.height)
      ;//break;
  }
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(off, 0, 0)
}

function nicksmithWords () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  off.width = canvas.width
  off.height = canvas.height
  let offctx = off.getContext("2d")
  offctx.fillStyle = "#000000"//randomPick(getCurrentPalette()) // was paintcolor
  let grunge = document.getElementById("grungy").checked
  // set above as in rectify
  let W = 2 + Math.floor(document.getElementById("featuresize").value/10)
  //invert range of W [2- 102] => [102 - 2]
  W = 54 - W + 2
  let usertext = document.getElementById("points").value.split(/\s/g)
  let text = ""
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, x = 0, y = 0
  let numsquares = (1+wdivs) * (1+hdivs)
  let radius = w, j = 0
  let lightness = 0, linecount = 0
  let r = 0, g = 0, b = 0
  //h*= 1.2
  let fs = w/12, cnt = 0
  for (;j < numsquares; j++) {
    let imgData = ctx.getImageData(x, y, w, h)
    let threshold = 127 - document.getElementById("opacity").value * 1.27
    let pixels = imgData.data
    let i = 0, r = 0, g = 0, b = 0
    for (; i < pixels.length; i += 4) {
      r += parseInt(pixels[i])
      g += parseInt(pixels[i+1])
      b += parseInt(pixels[i+2])
    }
    r /= pixels.length/4
    g /= pixels.length/4
    b /= pixels.length/4
    let R = ('0'+(Math.round(r)).toString(16)).slice(-2),
      G = ('0'+(Math.round(g)).toString(16)).slice(-2),
      B = ('0'+(Math.round(b)).toString(16)).slice(-2);
    //offctx.fillStyle = "#"+R+G+B
    let closest = closestColor("#"+R+G+B)
    offctx.fillStyle = closest[0]
    radius = w/2
    offctx.fillRect(x+randomPick([1,1,2,3]), y+randomPick([1,1,2,3]), w, h*0.8)
    
    text = closest[1]//offctx.fillStyle//randomWordPT()
    if (usertext.length > 1)
      text = usertext[cnt%usertext.length]
    let face = "Arial"
    offctx.font = "100 "+(fs)+"pt " + face
  //let width = ctx.measureText(text).width
    offctx.fillStyle = "#000000"
    offctx.fillText(text, x+8, y+h-fs*0.6)
    x += w
    if (x >= (wdivs)*w) {
      linecount++
      x = 0
      y += h
    }
    if (y+h > canvas.height)
      break;
    
    cnt++
  }
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(off, 0, 0)
}

function namedcolorWords () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  off.width = canvas.width
  off.height = canvas.height
  let offctx = off.getContext("2d")
  offctx.fillStyle = "#000000"//randomPick(getCurrentPalette()) // was paintcolor
  let grunge = document.getElementById("grungy").checked
  // set above as in rectify
  let W = 2 + Math.floor(document.getElementById("featuresize").value/10)
  //invert range of W [2- 102] => [102 - 2]
  W = 54 - W + 2
  let usertext = document.getElementById("points").value.split(/\s/g)
  let text = ""
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, x = 0, y = 0
  let numsquares = (1+wdivs) * (1+hdivs)
  let radius = w, j = 0
  let lightness = 0, linecount = 0
  let r = 0, g = 0, b = 0
  //h*= 1.2
  let fs = w/12, cnt = 0
  for (;j < numsquares; j++) {
    let imgData = ctx.getImageData(x, y, w, h)
    let threshold = 127 - document.getElementById("opacity").value * 1.27
    let pixels = imgData.data
    let i = 0, r = 0, g = 0, b = 0
    for (; i < pixels.length; i += 4) {
      r += parseInt(pixels[i])
      g += parseInt(pixels[i+1])
      b += parseInt(pixels[i+2])
    }
    r /= pixels.length/4
    g /= pixels.length/4
    b /= pixels.length/4
    let R = ('0'+(Math.round(r)).toString(16)).slice(-2),
      G = ('0'+(Math.round(g)).toString(16)).slice(-2),
      B = ('0'+(Math.round(b)).toString(16)).slice(-2);
    //offctx.fillStyle = "#"+R+G+B
    let closest = closestHTMLColor("#"+R+G+B)
    offctx.fillStyle = closest[0]
    radius = w/2
    offctx.fillRect(x+randomPick([1,1,2,3]), y+randomPick([1,1,2,3]), w, h*0.8)
    
    text = closest[1]//offctx.fillStyle//randomWordPT()
    if (usertext.length > 1)
      text = usertext[cnt%usertext.length]
    let face = "Arial"
    offctx.font = "100 "+(fs)+"pt " + face
  //let width = ctx.measureText(text).width
    offctx.fillStyle = "#000000"
    offctx.fillText(text, x+8, y+h-fs*0.6)
    x += w
    if (x >= (wdivs)*w) {
      linecount++
      x = 0
      y += h
    }
    if (y+h > canvas.height)
      break;
    cnt++
  }
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(off, 0, 0)
}

function sampleImageDataColor () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  off.width = canvas.width
  off.height = canvas.height
  let offctx = off.getContext("2d")
  offctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let grunge = document.getElementById("grungy").checked
  // set above as in rectify
  let W = 2 + Math.floor(document.getElementById("featuresize").value/2)
  //invert range of W [2- 102] => [102 - 2]
  W = 251 - W + 2
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, x = 0, y = 0
  let numsquares = (1+wdivs) * (1+hdivs)
  let radius = w, j = 0
  let lightness = 0, linecount = 0
  let r = 0, g = 0, b = 0
  // outer loop
  for (;j < numsquares; j++) {
    let imgData = ctx.getImageData(x, y, w, h)
    let threshold = 127 - document.getElementById("opacity").value * 1.27
    let pixels = imgData.data
    let i = 0, r = 0, g = 0, b = 0
    for (; i < pixels.length; i += 4) {
      r += parseInt(pixels[i])
      g += parseInt(pixels[i+1])
      b += parseInt(pixels[i+2])
    }
    r /= pixels.length/4
    g /= pixels.length/4
    b /= pixels.length/4
    let R = ('0'+(Math.round(r)).toString(16)).slice(-2),
      G = ('0'+(Math.round(g)).toString(16)).slice(-2),
      B = ('0'+(Math.round(b)).toString(16)).slice(-2);
    offctx.fillStyle = "#"+R+G+B
    radius = w/2
    offctx.beginPath()
    offctx.arc(x+w/2, y+h/2, radius, 0, Math.PI*2)
    offctx.closePath()
    offctx.fill()
    x += w
    if (x >= (wdivs)*w) {
      linecount++
      if (!grunge && linecount % 2 == 1)
        x = -w/2
      else
        x = 0
      y += h
    }
  }
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(off, 0, 0)
}

function cymk () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let w2 = canvas.width/2
  let h2 = canvas.height/2
  let mode = ctx.globalCompositeOperation
  let targets = shuffle(["#FF00FF", "#00FFFF", "#FFFF00"])
  let i = 0
  let offs = []
  for (;i < targets.length; i++)
    offs.push(sampleAColor(targets[i]))
  let black = sampleAColor("#000000", true)
  ctx.globalAlpha = 1.0
  ctx.clearRect(0,0,canvas.width,canvas.height)
 // ctx.globalCompositeOperation = "color"
  let W = 1 + Math.floor(document.getElementById("featuresize").value/2)
  //invert range of W [2- 102] => [102 - 2]
  W = 251 - W + 1
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs * 2
  i = 0
  offs = shuffle(offs)
  for (;i < offs.length; i++) {
    if (i == 0) {
      ctx.save()
      ctx.translate(w2, h2);
      ctx.rotate(Math.random()/30);
      ctx.translate(-w2, -h2);
      ctx.drawImage(offs[i], pet(w),pet(w))
      ctx.restore()
    }
    if (i == 1) {
      ctx.drawImage(offs[i], pet(w),pet(w))
    }
    if (i == 2) {
      ctx.save()
      ctx.translate(w2, h2);
      ctx.rotate(-(Math.random()/30));
      ctx.translate(-w2, -h2);
      ctx.drawImage(offs[i], pet(w),pet(w))
      ctx.restore()
    }
  }
  ctx.globalCompositeOperation = "destination-over"
  ctx.save()
  ctx.translate(w2, h2);
  ctx.rotate(Math.random()/30);
  ctx.translate(-w2, -h2);
  ctx.drawImage(black, pet(w),pet(w))
  ctx.restore()
  ctx.fillStyle = "#FFFFFF"
  ctx.fillRect(0,0,canvas.width,canvas.height)
  ctx.globalCompositeOperation = mode
}

function sampleAColor (targetcolor, small) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  off.width = canvas.width
  off.height = canvas.height
  let offctx = off.getContext("2d")
  offctx.fillStyle = targetcolor
  offctx.globalAlpha = 1.0
  let tr = hexToR(targetcolor)
  let tg = hexToG(targetcolor)
  let tb = hexToB(targetcolor)
  let targ = [tr,tg,tb]
  let maxdist = 441// dist3d([0,0,0], [255,255,255])
  let grunge = document.getElementById("grungy").checked
  let radiusmultiplier = (grunge)? 1.7: 1.2;
  // set above as in rectify
  let W = 2 + Math.floor(document.getElementById("featuresize").value/2)
  //invert range of W [2- 102] => [102 - 2]
  W = 251 - W + 2
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs * 1.3
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, x = 0, y = 7
  let numsquares = (1+wdivs) * (1+hdivs)
  let radius = w, j = 0
  let lightness = 0, linecount = 0, dist = 0, wdist = 0
  let r = 0, g = 0, b = 0
  for (;j < numsquares; j++) {
    let imgData = ctx.getImageData(x, y, w, h)
    let pixels = imgData.data
    let i = 0, r = 0, g = 0, b = 0, dist = 0, wdist = 0
    for (; i < pixels.length; i += 4) { // compare colors w/ target
      dist += dist3d(targ, [pixels[i], pixels[i+1], pixels[i+2]])
      wdist += dist3d([pixels[i], pixels[i+1], pixels[i+2]], [255,255,255])
    }
    dist /= pixels.length/4
    wdist /= pixels.length/4
    offctx.fillStyle = targetcolor
    radius = w/2 * (1-(dist/maxdist))
    radius *= wdist/(0.5*maxdist)
    if (small)
      radius *= 0.7
    if (radius > 0) {
      radius *= radiusmultiplier
      offctx.beginPath()
      offctx.arc(x+w/2, y+h/2, radius, 0, Math.PI*2)
      offctx.closePath()
      offctx.fill()
    }
    x += w
    if (x >= (wdivs)*w) {
      linecount++
      if (linecount % 2 == 1)
        x = -w/2
      else
        x = 0
      y += h
    }
  }
  return off
}

function sampleImageDataColor2 () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  off.width = canvas.width
  off.height = canvas.height
  let offctx = off.getContext("2d")
  offctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let targetcolor = randomPick(getCurrentPalette()) // was paintcolor
  let tr = hexToR(targetcolor)
  let tg = hexToG(targetcolor)
  let tb = hexToB(targetcolor)
  let targ = [tr,tg,tb]
  let maxd = []
  if (tr > 127)
    maxd.push(0)
  else
    maxd.push(255)
  if (tg > 127)
    maxd.push(0)
  else
    maxd.push(255)
  if (tb > 127)
    maxd.push(0)
  else
    maxd.push(255)
  let maxdist = dist3d(maxd, targ)
  let grunge = document.getElementById("grungy").checked
  // set above as in rectify
  let W = 2 + Math.floor(document.getElementById("featuresize").value/2)
  //invert range of W [2- 102] => [102 - 2]
  W = 251 - W + 2
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, x = 0, y = 0
  let numsquares = (1+wdivs) * (1+hdivs)
  let radius = w, j = 0
  let lightness = 0, linecount = 0, dist = 0
  let r = 0, g = 0, b = 0
  // outer loop
  for (;j < numsquares; j++) {
    let imgData = ctx.getImageData(x, y, w, h)
    let pixels = imgData.data
    let i = 0, r = 0, g = 0, b = 0, dist = 0
    for (; i < pixels.length; i += 4) { // compare colors w/ target
      dist += dist3d(targ, [pixels[i], pixels[i+1], pixels[i+2]])
    }
    dist /= pixels.length/4
    offctx.fillStyle = targetcolor
    radius = w/2 * (1-(dist/maxdist))
    if (radius < 0)
      radius = 0.01
    if (radius > 0) {
      offctx.beginPath()
      offctx.arc(x+w/2, y+h/2, radius, 0, Math.PI*2)
      offctx.closePath()
      offctx.fill()
    }
    x += w
    if (x >= (wdivs)*w) {
      linecount++
      if (!grunge && linecount % 2 == 1)
        x = -w/2
      else
        x = 0
      y += h
    }
  }
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(off, 0, 0)
}

function filterGrays () {
  let ctx = document.getElementById("myCanvas").getContext("2d")
  let op = document.getElementById("opacity").value
  //document.getElementById("opacity").value = 42
  alphaBlack()
  //document.getElementById("opacity").value = 63
  alphaWhite()
  document.getElementById("opacity").value = op
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "destination-over"
  if (document.getElementById("grungy").checked)
    fill()
  ctx.globalCompositeOperation = mode
  refreshMode()
}

function filterGrays2 () {
  let ctx = document.getElementById("myCanvas").getContext("2d")
  let op = document.getElementById("opacity").value
  let oc = randomPick(getCurrentPalette()) // was paintcolor
 // document.getElementById("opacity").value = 50
  randomPick(getCurrentPalette()) // was paintcolor = "#000000"
  colorFilterOut()
 // document.getElementById("opacity").value = 50
  randomPick(getCurrentPalette()) // was paintcolor = "#7f7f7f"
  colorFilterOut()
  randomPick(getCurrentPalette()) // was paintcolor = "#ffffff"
  colorFilterOut()
  document.getElementById("opacity").value = op
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "destination-over"
  if (document.getElementById("grungy").checked)
    fill()
  ctx.globalCompositeOperation = mode
  refreshMode()
  randomPick(getCurrentPalette()) // was paintcolor = oc
}

function alphaBlack (t) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height)
  let threshold = 127 - document.getElementById("opacity").value * 1.27
  if (t)
    threshold = t
  let pixels = imgData.data
  let i = 0
  for (; i < pixels.length; i += 4) {
    let lightness = parseInt((pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3)
    if (lightness < threshold)
      pixels[i+3] = lightness/255
  }
  ctx.putImageData(imgData, 0, 0)
}

function alphaWhite () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let threshold = 127 + document.getElementById("opacity").value * 1.27
  let pixels = imgData.data
  let i = 0
  for (; i < pixels.length; i += 4) {
    let lightness = parseInt((pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3)
    if (lightness > threshold)
      pixels[i+3] = 1-lightness/255
  }
  ctx.putImageData(imgData, 0, 0)
  return true
}

function filterRed () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let pixels = imgData.data
  let i = 0
  for (; i < pixels.length; i += 4) {
    //pixels[i] *= 1.0
    pixels[i+1] *= 0
    pixels[i+2] *= 0
  }
  ctx.putImageData(imgData, 0, 0)
}

function filterGreen () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let pixels = imgData.data
  let i = 0
  for (; i < pixels.length; i += 4) {
    pixels[i] *= 0
    pixels[i+2] *= 0
  }
  ctx.putImageData(imgData, 0, 0)
}

function filterBlue () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let pixels = imgData.data
  let i = 0
  for (; i < pixels.length; i += 4) {
    pixels[i] *= 0
    pixels[i+1] *= 0
  }
  ctx.putImageData(imgData, 0, 0)
}

function featuresizeChange () {
  let a = document.getElementById("featuresize").value
  pushFunction('setFeaturesize', a)
}

function setFeaturesize (a) {
  document.getElementById("featuresize").value = a
}

function paintcolorChange () {
  let p = getCurrentPalette()
  p[0] = document.getElementById("paintcolor").value
  updateExtraColors(p)
  pushFunction('setPaintColor')
}

function setPaintColor (a) {
  randomPick(getCurrentPalette()) // was paintcolor = a
}

function numberChange () {
  let a = document.getElementById("number").value
  pushFunction('setNumber', a)
}

function setNumber (a) {
  document.getElementById("number").value = a
}

function opacityChange () {
  let a = document.getElementById("opacity").value
  pushFunction('setOpacity', a)
}

function setOpacity (a) {
  document.getElementById("opacity").value = a
  document.getElementById("myCanvas").getContext("2d").globalAlpha = a/100
}

function modeChange () {
  let a = document.getElementById("mode").value
  pushFunction('setMode', a)
}

function setMode (a) {
  document.getElementById("mode").value = a
  document.getElementById("myCanvas").getContext("2d").globalCompositeOperation = a
  
}

function paletteChange () {
  let a = document.getElementById("palettechoice").value
  pushFunction('setPalette', a)
}

function setPalette (a) {
  document.getElementById("palettechoice").value = a
  loadPalette()
}

function recordSettings () {
  let a = document.getElementById("number").value
  pushFunction('setNumber', a)
  a = document.getElementById("opacity").value
  pushFunction('setOpacity', a)
  a = document.getElementById("featuresize").value
  pushFunction('setFeaturesize', a)
  a = randomPick(getCurrentPalette()) // was paintcolor
  pushFunction('setPaintColor', a)
  a = document.getElementById("mode").value
  pushFunction('setMode', a)
  a = document.getElementById("palettechoice").value
  pushFunction('setPalette', a)
}

let RECORDING = false
let LATESTFUNCTION = ""
let functionStack = []

function stackToCode () {
  if (functionStack.length <= 0)
    return
  let buff = "function macro () {\n"
  let i = 0
  let quoteme = ["setPalette", "setMode", "setPaintColor"]
  for (; i < functionStack.length;i++) {
    buff += "  "+functionStack[i][0] +"("
    if (functionStack[i][1]) {
      if (quoteme.includes(functionStack[i][0]))
        buff += "\""+functionStack[i][1]+"\""
      else
        buff += functionStack[i][1]
    }
    buff += ")\n"
  }
  buff += "}"
  console.log(buff)
  alert(buff)
}

function pushFunction (f,args) {
  if (!RECORDING)
    return false
  if (functionStack.length > 0 && (f === "setPaintColor" || f === "setOpacity"  || f === "setNumber"  || f === "setFeaturesize") && functionStack[functionStack.length-1][0] === f) {
    functionStack[functionStack.length-1] = [f,args] // replace with final color choice
  } else
    functionStack.push([f,args])
}

function togglerecord () {
  if (!RECORDING) {
    record()
  } else {
    stopRecording()
  }
}
function record () {
  document.getElementById("recordsvg").style.fill="#ff0000"
  document.getElementById("playsvg").style.fill="#707070"
  document.getElementById("codesvg").style.fill="#707070"
  clearFunctionStack()
  RECORDING = true
  //recordSettings()
}

function stopRecording () {
  RECORDING = false
  document.getElementById("recordsvg").style.fill="#000000"
  if (functionStack.length > 0) {
    document.getElementById("playsvg").style.fill="#ff0000"
    document.getElementById("codesvg").style.fill="#000000"
}
}

function playFunctions () {
  RECORDING = false
  document.getElementById("recordsvg").style.fill="#000000"
  if (functionStack.length > 0) {
    document.getElementById("playsvg").style.fill="#ff0000"
    document.getElementById("codesvg").style.fill="#000000"
  }
  playAllFunctions()
}

function clearFunctionStack () {
  functionStack = []
}

function playAllFunctions () {
  let i = 0
  for (; i < functionStack.length; i++) {
    window[functionStack[i][0]](functionStack[i][1])
  }
}

function testImage (id) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let gco = ctx.globalCompositeOperation
  let sga = document.getElementById("opacity").value/100
  let f = document.getElementById(id).value
  window[f]()
  LATESTFUNCTION = f
  pushFunction(f,0)
 // document.getElementById("last").title = "repeat: "+f
  // after function call check slider agreement with context values
  let sel = document.getElementById("mode").value
  let cga = ctx.globalAlpha
  ctx.globalCompositeOperation = sel
  ctx.globalAlpha = sga
}

function lastNFunctions () {
  functionStack = functionStack.slice(-10, functionStack.length)
  document.getElementById("nfunctions").setAttribute('title', functionStack.join("\n"))
  N = document.getElementById("nfunctions").value
  if (N == 0) {
    clearFunctionStack()
    return
  }
  let i = 0
  let end = functionStack.slice(-N, functionStack.length)
  for (; i < end.length; i++) {
    window[end[i]]()
  }
}

function doAgain () {
  if (LATESTFUNCTION.length > 0)
    window[LATESTFUNCTION]()
}

async function invertColors (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  ctx.willReadFrequently = true
  let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height)
  let pixels = imgData.data
  let i = 0
  for (; i < pixels.length; i += 4) {
    var r = pixels[i]; // Red color lies between 0 and 255
    var g = pixels[i + 1]; // Green color lies between 0 and 255
    var b = pixels[i + 2]; // Blue color lies between 0 and 255
    var a = pixels[i + 3]; // Transparency lies between 0 and 255
    var invertedRed = 255 - r
    var invertedGreen = 255 - g
    var invertedBlue = 255 - b
    pixels[i] = invertedRed
    pixels[i + 1] = invertedGreen
    pixels[i + 2] = invertedBlue
  }
  await ctx.putImageData(imgData, 0, 0)
  return true
}

function multileak () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  off.width = canvas.width, off.height = canvas.height
  let offctx = off.getContext("2d")
  let alpha = document.getElementById("opacity").value
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let colors = getCurrentPalette()
  let alt = document.getElementById("grungy").checked
  offctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor//randomGradient(canvas, randomColorMedium())
  let cw = canvas.width, ch  = canvas.height
  let y = 0//ch/5
  
  offctx.globalAlpha = alpha/1000
  let j = 0
  for (; j < 9; j++) {
    let i = 0
    for (; i < 5; i++) {
      if (!alt)
        color = randomPick(colors)
      offctx.fillStyle = randomGradient(canvas, color)
      ellipseFill(offctx, cw/2 + pet(cw/3), y+pet(100), cw+cw/2*Math.random(), ch/10*Math.random())
    }
    y += canvas.height/7
  }
  document.getElementById("rednumber").value = 4
  document.getElementById("opacity").value = 9
  saturationScale(5, off)
  motionblur(off)
  motionblur(off)
  ctx.drawImage(off,0+pet(21),0+pet(21),canvas.width, canvas.height)
  document.getElementById("opacity").value = alpha
}


function lightleak () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  off.width = canvas.width, off.height = canvas.height
  let offctx = off.getContext("2d")
  let alpha = document.getElementById("opacity").value
  offctx.fillStyle = randomGradient(canvas, randomColorMedium())
  let cw = canvas.width, ch  = canvas.height
  let y = ch/4*Math.random(), x = 0
  if (Math.random() > 0.5)
    y = ch-y/3
  offctx.globalAlpha = 0.1
  if (document.getElementById("grungy").checked)
    offctx.globalAlpha = 0.2
  let i = 0
  for (; i < 5; i++) {
    offctx.fillStyle = randomGradient(canvas, randomColorLight())
    ellipseFill(offctx, cw/2 + pet(cw/3), y+pet(100), cw+cw/2*Math.random(), ch/10*Math.random())
  }
  document.getElementById("rednumber").value = 4
  document.getElementById("opacity").value = 9
  saturationScale(5, off)
  motionblur(off)
  motionblur(off)
  ctx.drawImage(off,0+pet(21),0+pet(21),canvas.width, canvas.height)
  document.getElementById("opacity").value = alpha
}

function ellipseFill (ctx, x, y, rx, ry) {
  let r = (Math.random() - 0.5)/5
  ctx.beginPath()
 // ctx.moveTo(p1_x, p1_y);
  ctx.ellipse(x, y, rx, ry, r, 0, Math.PI*2);
  ctx.closePath()
  ctx.fill()
}
/*
function ellipseFill (ctx, x, y, rx, ry) {
  ry*=4/3;
  let p1_x=x-rx, p1_y=y,
      p2_x=x+rx, p2_y=y,
      cp1_x, cp1_y,
      cp2_x, cp2_y,
      cp3_x, cp3_y,
      cp4_x, cp4_y,
      p1n_x, p1n_y, dx, dy;
  
  cp1_x=p1_x;
  cp1_y=p1_y-ry;
  cp4_x=p1_x;
  cp4_y=p1_y+ry;
  //
  cp2_x=p2_x;
  cp2_y=p2_y-ry;
  cp3_x=p2_x;
  cp3_y=p2_y+ry;
  
  ctx.beginPath()
  ctx.moveTo(p1_x, p1_y);
  ctx.bezierCurveTo(cp1_x, cp1_y, cp2_x, cp2_y, p2_x, p2_y);
  ctx.bezierCurveTo(cp3_x, cp3_y, cp4_x, cp4_y, p1_x, p1_y);
  ctx.closePath()
  ctx.fill()
}*/


function ellipse1 (ctx, x, y, rx, ry, rot) {
  ry*=4/3;
  var p1_x=x-rx, p1_y=y,
      p2_x=x+rx, p2_y=y,
      cp1_x, cp1_y,
      cp2_x, cp2_y,
      cp3_x, cp3_y,
      cp4_x, cp4_y,
      p1n_x, p1n_y, dx, dy;
  //
  if (rot) {
      //
      p1n_x=rx*Math.cos(rot) + x;
      p1n_y=rx*Math.sin(rot) + y;
      //
      p2_x-=p1n_x-p1_x;
      p2_y-=p1n_y-p1_y;
      //
      p1_x=p1n_x;
      p1_y=p1n_y;
      //
      dx=ry*Math.sin(rot);
      dy=ry*Math.cos(rot);
      //
      cp1_x=p1_x+dx;
      cp1_y=p1_y-dy;
      cp4_x=p1_x-dx;
      cp4_y=p1_y+dy;
      //
      cp2_x=p2_x+dx;
      cp2_y=p2_y-dy;
      cp3_x=p2_x-dx;
      cp3_y=p2_y+dy;
  } else {
      cp1_x=p1_x;
      cp1_y=p1_y-ry;
      cp4_x=p1_x;
      cp4_y=p1_y+ry;
      //
      cp2_x=p2_x;
      cp2_y=p2_y-ry;
      cp3_x=p2_x;
      cp3_y=p2_y+ry;
  }
  ctx.moveTo(p1_x, p1_y);
  ctx.bezierCurveTo(cp1_x, cp1_y, cp2_x, cp2_y, p2_x, p2_y);
  ctx.bezierCurveTo(cp3_x, cp3_y, cp4_x, cp4_y, p1_x, p1_y);
}

function dotted (canvas, source, jaggy, dir) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let grunge = document.getElementById("grungy").checke
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let ch = canvas.height, cw = canvas.width
  let dir2 = dir + Math.PI/2
  // calculate h based on canvas dims
  let minsize = cw/200
  if (ch > cw) {
    minsize = ch/200
  }
  if (minsize < 4)
    minsize = 4
  if (dir)
    minsize *= 2
  let h = 4 + Math.floor(document.getElementById("featuresize").value/10)
  h = Math.floor(minsize/4 * h)
  let w = h
  let off = h/3
  let r = w/1.2
  let t = w*2
  let rd2 = r/3, rt2 = r*2, wd4 = w/4, wt4 = w*9
  ctx.save()
  ctx.beginPath()
  let count = canvas.height/h * canvas.width/w
  let newline = Math.floor(canvas.width/w)
  let counter = 0
  let x = w/3 + pet(11), y = h/3 + pet(11)
  let xo = 0, yo = 0, i = 0
  let inc = Math.PI*2/5, a = Math.random()*Math.PI*2
  ctx.save()
  ctx.beginPath()
  for (;i < count; i++) {
    x0 = x+w/2+pet(t)
    y0 = y+h/2+pet(t)
    ctx.moveTo(x0, y0)
    if (dir) {
      ellipse1(ctx, x0, y0, rd2, rt2, dir)
    } else
    if (jaggy) {
      ctx.arc(x0+pet(w),y0+pet(w),r,a,a+Math.PI/2)
      a += inc
    } else
       ctx.arc(x0+pet(w),y0+pet(w),r+pet(w),0,Math.PI*2)
    x += w*1.3
    xo += w
    counter++
    if (i > 0 && newline == counter) {
      counter = 0
      x = w
      y += 1.3*h
      off *= -1
      x =+ off
    }
  }
  ctx.closePath()
  ctx.clip()
  ctx.drawImage(source, pet(r*3), pet(r*3), canvas.width, canvas.height)
  ctx.restore()
  refreshMode()
}

function dottedhalo (canvas, source, jaggy, dir) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let grunge = document.getElementById("grungy").checked
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let ch = canvas.height, cw = canvas.width
  let cx = cw/2, cy = ch/2
  cx = LASTCLICK[0]
  cy = LASTCLICK[1]
  let dir2 = dir + Math.PI/2
  // calculate h based on canvas dims
  let minsize = cw/200
  if (ch > cw) {
    minsize = ch/200
  }
  if (minsize < 4)
    minsize = 4
  if (dir)
    minsize *= 2
  let h = 4 + Math.floor(document.getElementById("featuresize").value/10)
  h = Math.floor(minsize/4 * h)
  let w = h
  let off = h/3
  let r = w/1.2
  let t = w
  let rd2 = r/3, rt2 = r*2, wd4 = w/4, wt4 = w*9
  ctx.save()
  ctx.beginPath()
  let count = canvas.height/h * canvas.width/w * 2
  let newline = Math.floor(canvas.width/w) + w
  let counter = 0
  let x = w/2//w/3 + pet(11),
  let y = 0// h/3 + pet(11)
  let xo = 0, yo = 0, i = 0
  let inc = 5, a = Math.random()*Math.PI*2
  ctx.save()
  ctx.beginPath()
  let dist = 0, max_dist = distance(cx, cy, 0, 0), r0 = r
  while (y < canvas.height) {
    x0 = x + w/2+pet(t)
    y0 = y + h/2+pet(t)
    ctx.moveTo(x0,y0)
    dist = distance(x0, y0, cx, cy)/max_dist
    r = r0 * dist
    a = Math.random() * 6.28
    if (dist * Math.random() > 0.02) {

      if (dir) {
        ellipse1(ctx, x0, y0, rd2, rt2, dir)
      } else
      if (jaggy) {
        ctx.arc(x0+pet(w),y0+pet(w),r,a,a+Math.PI/2)
       // a += inc
      } else
         ctx.arc(x0+pet(w),y0+pet(w),r,0,Math.PI*2)
    }
    x += w*1.3
    xo += w
    counter++
    if (i > 0 && newline == counter) {
      counter = 0
      x = 0
      y += 1.3*h
      off *= -1
      x =+ off
    }
    i++
  }
  ctx.closePath()
  ctx.clip()
  ctx.drawImage(source, pet(r*3), pet(r*3), canvas.width, canvas.height)
  ctx.restore()
  refreshMode()
}

function qBlur () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  ctx.drawImage(canvas, 0, 0, canvas.width / 4, canvas.height / 4);
  ctx.drawImage(canvas, 0, 0, canvas.width / 4, canvas.height / 4, 0, 0, canvas.width, canvas.height);
}

function jaggyblur (canvas) {
  let jaggy = true
  dotblur(canvas, jaggy, false)
}

function dirblur (canvas) {
  let jaggy = false
  let dir = Math.random() * Math.PI * 2
  dotblur(canvas, jaggy, dir)
}

function halojaggy () {
  let jaggy = true
  haloblur(jaggy)
}

function haloblur (jaggy, dir) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  let offctx = off.getContext("2d")
  off.height = canvas.height
  off.width = canvas.width
  let grunge = document.getElementById("grungy").checked
  offctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let i = 0
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height)
  if (grunge)
    ctx.clearRect(0,0,canvas.width, canvas.height)
  for (; i < 3; i++) {
    offctx.clearRect(0,0,canvas.width, canvas.height)
    offctx.putImageData(imgData, pet(17), pet(17))
    dottedhalo(canvas, off, jaggy, dir)
  }
  refreshMode()
}

function dotblur (canvas, jaggy, dir) {
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  let offctx = off.getContext("2d")
  off.height = canvas.height
  off.width = canvas.width
  let grunge = document.getElementById("grungy").checked
  offctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let i = 0
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height)
 // if (grunge)
  //  ctx.clearRect(0,0,canvas.width, canvas.height)
  for (; i < 3; i++) {
    offctx.clearRect(0,0,canvas.width, canvas.height)
    offctx.putImageData(imgData, pet(17), pet(17))
    dotted(canvas, off, jaggy, dir)
  }
  refreshMode()
}

function rgbDistance () {
  let c1 = document.getElementById("pal1").value
  let c2 = document.getElementById("pal2").value
  
  let r1 = hexToR(c1)
  let g1 = hexToG(c1)
  let b1 = hexToB(c1)
  
  let r2 = hexToR(c2)
  let g2 = hexToG(c2)
  let b2 = hexToB(c2)
  
  let hsv1 = rgbtohsv(r1,g1,b1)
  let hsv2 = rgbtohsv(r2,g2,b2)
  let hdistance = Math.round(Math.sqrt(Math.pow(hsv1[0] - hsv2[0], 2) + Math.pow(hsv1[1] - hsv2[1], 2) + Math.pow(hsv1[2] - hsv2[2], 2)))
  
  let distance = Math.round(Math.sqrt(Math.pow(r1 - r2, 2) + Math.pow(g1 - g2, 2) + Math.pow(b1 - b2, 2)))
  maxdistance = 442 // = distance (0,0,0, 255,255,255)
  let threshold = Math.round(+document.getElementById("opacity").value * 4.42)
  threshold = 443 - threshold
  
  alert("distance: "+ distance+"\nthreshold:"+threshold+"\n"+r1+", "+g1+", "+b1+"\n"+r2+", "+g2+", "+b2)
}

function colorFilterOut () { // filter unselected color
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height)
  let target = randomPick(getCurrentPalette()) // was paintcolor
  let threshold = Math.round(+document.getElementById("opacity").value * 4.42)
  threshold = 443 - threshold
  let grunge = document.getElementById("grungy").checked
  let mode = ctx.globalCompositeOperation
  let r = hexToR(target)
  let g = hexToG(target)
  let b = hexToB(target)
  let pixels = imgData.data
  let i = 0
  let d = imgData.data
  let dist = 0
  for( ;i < d.length; i +=4) {
    dist = Math.sqrt(Math.pow(d[i] - r, 2) + Math.pow(d[i+1] - g, 2) + Math.pow(d[i+2] - b, 2))
    
    if (dist <= threshold) {
      if (grunge) {
        d[i + 3] *= 0.8
      } else
        d[i + 3] = 0.0
    }
  }
  ctx.putImageData(imgData, 0, 0)
  refreshMode()
}
/*
function colorFilterOff () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let off = document.createElement('CANVAS')
  let offctx = off.getContext("2d")
  off.height = canvas.height
  off.width = canvas.width
  let off2 = document.createElement('CANVAS')
  let off2ctx = off2.getContext("2d")
  off2.height = canvas.height
  off2.width = canvas.width
  offctx.globalAlpha = 0.8
  off2ctx.globalAlpha = 0.8
  // red
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height)
  let target = "#ff5555"//randomPick(getCurrentPalette()) // was paintcolor
  let threshold = document.getElementById("opacity").value
  let tclose = threshold * 0.95
  let r = hexToR(target)
  let g = hexToG(target)
  let b = hexToB(target)
  let pixels = imgData.data
  let i = 0
  let d = imgData.data
  let dist = 0
  for( ;i < d.length; i +=4) {
    dist = 0
    dist += Math.abs(d[i] - r)
    dist += Math.abs(d[i+1] - g)
    dist += Math.abs(d[i+2] - b)
    let lightness = parseInt((d[i] + d[i + 1] + d[i + 2]) / 3);
    
    if (dist/3 > threshold) {
        d[i + 3] = 0.0
    }
  }
  offctx.clearRect(0,0,canvas.width, canvas.height)
  offctx.putImageData(imgData, 0, 0)
  offctx.globalCompositeOperation = "destination-out"
  dashes(off)
  offctx.globalCompositeOperation = "source-over"
  off2ctx.drawImage(off, -6,6,off2.width,off2.height)
  
  // blue
  imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height)
  target = "#5555ff"//randomPick(getCurrentPalette()) // was paintcolor
  threshold = document.getElementById("opacity").value
  tclose = threshold * 0.95
  r = hexToR(target)
  g = hexToG(target)
  b = hexToB(target)
  pixels = imgData.data
  i = 0
  d = imgData.data
  dist = 0
  for( ;i < d.length; i +=4) {
    dist = 0
    dist += Math.abs(d[i] - r)
    dist += Math.abs(d[i+1] - g)
    dist += Math.abs(d[i+2] - b)
  //  let lightness = parseInt((d[i] + d[i + 1] + d[i + 2]) / 3);
    if (dist/3 > threshold) {
        d[i + 3] = 0.0
    }
  }
  offctx.clearRect(0,0,canvas.width, canvas.height)
  offctx.putImageData(imgData, 0, 0)
  offctx.globalCompositeOperation = "destination-out"
  dashes(off)
  offctx.globalCompositeOperation = "source-over"
  off2ctx.drawImage(off, 0,6,off2.width,off2.height)
  
  // green
  imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height)
  target = "#55ff55"//randomPick(getCurrentPalette()) // was paintcolor
  threshold = document.getElementById("opacity").value
  tclose = threshold * 0.95
  r = hexToR(target)
  g = hexToG(target)
  b = hexToB(target)
  pixels = imgData.data
  i = 0
  d = imgData.data
  dist = 0
  for( ;i < d.length; i +=4) {
    dist = 0
    dist += Math.abs(d[i] - r)
    dist += Math.abs(d[i+1] - g)
    dist += Math.abs(d[i+2] - b)
    let lightness = parseInt((d[i] + d[i + 1] + d[i + 2]) / 3);
    if (dist/3 > threshold) {
        d[i + 3] = 0.0
    }
  }
  offctx.clearRect(0,0,canvas.width, canvas.height)
  offctx.putImageData(imgData, 0, 0)
  offctx.globalCompositeOperation = "destination-out"
  dashes(off)
  offctx.globalCompositeOperation = "source-over"
  refreshMode()
  off2ctx.drawImage(off, -6,0,off2.width,off2.height)
  
  ctx.clearRect(0,0,canvas.width, canvas.height)
  ctx.drawImage(off2, 0,0,off2.width,off2.height)
}*/

function colorFilter () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height)
  let target = randomPick(getCurrentPalette()) // was paintcolor
  let threshold = +document.getElementById("opacity").value * 4.42
  let grunge = document.getElementById("grungy").checked
  let r = hexToR(target)
  let g = hexToG(target)
  let b = hexToB(target)
  let pixels = imgData.data
  let i = 0, ct = 0
  let d = imgData.data
  let dist = 0, lightness
  for( ;i < d.length; i +=4) {
    dist = Math.sqrt(Math.pow(d[i] - r, 2) + Math.pow(d[i+1] - g, 2) + Math.pow(d[i+2] - b, 2))
    if (dist >= threshold) {
      if (grunge) {
        lightness = parseInt((d[i] + d[i + 1] + d[i + 2]) / 3);
        d[i] = lightness
        d[i + 1] = lightness
        d[i + 2] = lightness
      } else
        d[i + 3] = 0.0
    }
  }
  ctx.putImageData(imgData, 0, 0)
}

function highContrast () {
  let canvas = document.getElementById("myCanvas")
  greyScale(canvas)
  contrastImage(40, canvas, false)
  adjustBrightness(-30, canvas,false)
  if (document.getElementById("grungy").checked) {
    sharpenCanvas()
  }
}

function mapRanges (start, end, startF, endF, val) { // F is full range 0 to 255*3
 // r = (endF - startF)/(end - start)
  return(((val-start)*(endF-startF))/(end-start) + startF)
}

function retro () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let alpha = document.getElementById("opacity").value
  let feature_size = document.getElementById("featuresize").value
  let number = document.getElementById("number").value
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alt = document.getElementById("grungy").checked
  let pal = getCurrentPalette(true)
  let ga = ctx.globalAlpha
  document.getElementById("number").value = 1500 + pet(500)
  document.getElementById("opacity").value = 100
  LASTCLICK[0] = canvas.width/2
  LASTCLICK[1] = canvas.height/2
  increaseGrain()
  
  let type = document.getElementById("palettechoice").value
  document.getElementById("palettechoice").value = "rainbow"
  loadPalette()
  palettetint()
  contrastImage(-5,canvas,false)
  adjustBrightness(5,canvas,false)
  
  yellowedEdges()
  yellowedEdges()
  if (Math.random() > 0.3 && alt) {
    ctx.save()
    clipIrregular()
    lightleak()
    ctx.restore()
  }
  if (Math.random() > 0.3 && alt) {
    randomPick(getCurrentPalette()) // was paintcolor = randomPick(["#d4f595", "#80dfff", "#ffee80", "#ff80aa", "#45de45"])
    document.getElementById("opacity").value = 25 + Math.random() * 10
    haze()
  }
  if (Math.random() > 0.3 && alt) {
    randomPick(getCurrentPalette()) // was paintcolor = randomPick(["#7f7e60", "#707060", "#507070", "#505070"])
    document.getElementById("opacity").value = 30
    document.getElementById("number").value = 6000
    document.getElementById("featuresize").value = 300
    if (Math.random() > 0.5)
      smudgewatercolor()
    else
      fog()
    yellowedEdges()
  }
  if (Math.random() > 0.3 && alt) {
    ctx.save()
    clipIrregular()
    randomPick(getCurrentPalette()) // was paintcolor = "#ffffff"
    document.getElementById("opacity").value = 70 + Math.random() * 20
    document.getElementById("number").value = 3000 + Math.random() * 3000
    document.getElementById("featuresize").value = 400
    let r = Math.random()
    if (r > 0.67)
      rays()
    else
    if (r > 0.33 && r < 0.67)
      smudgestreaks()
    else
    if (r <= 0.33)
      smudgestars()
    ctx.restore()
  }
  //restorePalette(pal)
  ctx.globalAlpha = alpha/100
  document.getElementById("opacity").value = alpha
  document.getElementById("featuresize").value = feature_size
  document.getElementById("number").value = number
  randomPick(getCurrentPalette()) // was paintcolor = color
  document.getElementById("palettechoice").value = type
  loadPalette()
}


function resturePalette (pal) {
  updateExtraColors(pal)
}

function enhanceExposure (n, canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  let brightness = 0, maxb = -1, minb = 100000, avg = 0
  let ctx = canvas.getContext("2d");
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let pixels = imgData.data;
  let i = 0
  for (; i < pixels.length; i += 4) {
    brightness = (pixels[i]+pixels[i+1]+pixels[i+2])/3
    maxb = (maxb > brightness)? maxb : brightness;
    minb = (minb < brightness)? minb : brightness;
    avg += brightness
  }
  avg /= pixels.length/4
  if (minb > 0 || avg > 127 * 1.2) {
    adjustBrightness(-10,canvas,false)
    contrastImage(10)
  }
  if (maxb < 255 || avg < 0.8 * 127) {
    adjustBrightness(10,canvas,false)
    contrastImage(10)
  }
}

function contrastImage (contrast, canvas, PUSH) {  //input range [-100..100]
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height)
  let pixels = imgData.data
  let i = 0
  let d = imgData.data
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  let brightness = 0
  contrast = (contrast/100) + 1;  //convert to decimal & shift range: [0..2]
  let intercept = 128 * (1 - contrast)
  for( ;i < d.length; i +=4){   //r,g,b,a
    brightness = (d[i]+d[i+1]+d[i+2])/(255*3)
    if (brightness >= lowest && brightness <= highest) {
      d[i] =   d[i]*contrast + intercept
      d[i+1] = d[i+1]*contrast + intercept
      d[i+2] = d[i+2]*contrast + intercept
    }
  }
  ctx.putImageData(imgData, 0, 0)
  if (PUSH)
    pushFunction("contrastImage", contrast)
}

function openFileExtract () {
  let canvas = document.createElement('CANVAS')
  let ctx = canvas.getContext('2d')
  let mode = ctx.globalCompositeOperation
  document.getElementById('openextract').click();
  ctx.globalCompositeOperation = mode
}


function openFile () {
  let canvas = document.getElementById('myCanvas')
  let ctx = canvas.getContext('2d')
  let mode = ctx.globalCompositeOperation
  document.getElementById('uploadimage').click();
  ctx.globalCompositeOperation = mode
}

function OGImage() {
  if (IMG) {
    let ctx = document.getElementById('myCanvas').getContext('2d')
    ctx.drawImage(IMG, 0, 0);
  }
}

function extractFile () {
  let canvas = document.createElement('CANVAS')
  let ctx = canvas.getContext('2d')
  let IMG = new Image()
  let f = document.getElementById("openextract").files[0]
  let url = window.URL || window.webkitURL
  let src = url.createObjectURL(f);
  IMG.src = src;
  ctx.globalAlpha = 1.0
  ctx.globalCompositeOperation = "source-over"
  IMG.onload = function() {
    canvas.height = this.height
    canvas.width = this.width
    if (canvas.height > 1000 && canvas.width > 1000) {
      canvas.height = Math.round(canvas.height/1.6)
      canvas.width = Math.round(canvas.width/1.6)
    }
    ctx.drawImage(IMG, 0, 0, canvas.width, canvas.height);
    url.revokeObjectURL(src);
    LASTCLICK[0] = canvas.width/2
    LASTCLICK[1] = canvas.height/2
    extractPalette(canvas)
  }
  document.getElementById("openextract").value = ""
}

function drawFile () {
  let canvas = document.getElementById('myCanvas')
  let ctx = canvas.getContext('2d')
  let SHRINK = document.getElementById("grungy").checked
  let IMG = new Image()
  let f = document.getElementById("uploadimage").files[0]
  let url = window.URL || window.webkitURL
  let src = url.createObjectURL(f);
  IMG.src = src;
  let imgwidth = 0, imgheight = 0
  ctx.globalAlpha = 1.0
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "source-over"
  IMG.onload = function() {
    imgheight = this.height
    imgwidth = this.width
    canvas.height = this.height
    canvas.width = this.width
    if (SHRINK) {
      // fit to current canvas size w/o changing aspect ratio
      
      canvas.height = Math.round(canvas.height/1.2)
      canvas.width = Math.round(canvas.width/1.2)
    }
    syncBackground(canvas)
    //document.getElementById("canvaswidth").value = canvas.width
    //document.getElementById("canvasheight").value = canvas.height
    ctx.imageSmoothingEnabled = true
    ctx.imageSmoothingQuality = "high"
    ctx.drawImage(IMG, 0, 0, canvas.width, canvas.height);
    url.revokeObjectURL(src);
    LASTCLICK[0] = canvas.width/2
    LASTCLICK[1] = canvas.height/2
    ctx.globalCompositeOperation = mode
    syncMarker()
  }
  document.getElementById("uploadimage").value = ""
  ctx.globalCompositeOperation = mode
}

function resizeTo1080 () { // &clip if needed zoom_neg
  let ocanvas = document.createElement('CANVAS')
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let CH = canvas.height, CW = canvas.width
  let ratio = 1
  ocanvas.height = canvas.height
  ocanvas.width = canvas.width
  octx.drawImage(canvas, 0, 0)
  let ar = canvas.width/canvas.height
  if (/*canvas.width > 1080 &&*/ CH > CW) {
    canvas.width = 1080
    canvas.height = Math.floor(canvas.height * 1080/CW)
    syncBackground(canvas)
  } else
  if (/*canvas.width > 1080 &&*/ CW > CH) {
    canvas.height = 1080
    canvas.width = Math.floor(canvas.width * 1080/CH)
    syncBackground(canvas)
  } else {
    canvas.height = 1080
    canvas.width = 1080
    syncBackground(canvas)
  }
  ctx.drawImage(ocanvas,0,0,canvas.width,canvas.height)
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  cropSquare(true) // from top
  syncMarker()
}

function stack_clearOff () {
  clearOff()
  pushFunction('clearOff',0)
}

function stack_copyToOff () {
  copyToOff()
  pushFunction('copyToOff',0)
}

function stack_swapWithOff () {
  swapWithOff()
  pushFunction('swapWithOff',0)
}

function stack_pasteFromOff () {
  pasteFromOff()
  pushFunction('pasteFromOff',0)
}

function clearOff () {
 let OC = document.getElementById('OC')
 let octx = OC.getContext('2d')
 octx.clearRect(0, 0, OC.width, OC.height)
 let canvas = document.getElementById("myCanvas")
 OC.width = canvas.width, OC.height = canvas.height
 OCISCLEAR = true
 return true
}

async function copyToOff () {
  let OC = document.getElementById('OC')
  let canvas = document.getElementById('myCanvas')
  if (isCanvasBlank(OC)) {
    OC.height = canvas.height
    OC.width = canvas.width
    OCISCLEAR = false
  }
  let ctx = canvas.getContext('2d')
  let OCctx = OC.getContext('2d')
  OCctx.willReadFrequently = true
  ctx.willReadFrequently = true
  ctx.globalAlpha = 1.0
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "source-over"
  OCctx.globalAlpha = 1.0
  OCctx.globalCompositeOperation = "source-over"
  await OCctx.drawImage(canvas, 0, 0)
  ctx.globalCompositeOperation = mode
  OCISCLEAR = false
  return true
}

function swapWithOff () {
  let OC = document.getElementById('OC')
  let canvas = document.getElementById('myCanvas')
  if (isCanvasBlank(OC)) {
    OC.height = canvas.height
    OC.width = canvas.width
    OCISCLEAR = false
  }
  let mode = document.getElementById("mode").value
  if (OC && OC.width > 0) {
    let ctx = canvas.getContext('2d')
    ctx.globalCompositeOperation = "source-over"
    let OCctx = OC.getContext('2d')
    OCctx.globalCompositeOperation = "source-over"
    OCctx.globalAlpha = 1
    ctx.globalAlpha = 1
    let temp = document.createElement('CANVAS')
    let tempctx = temp.getContext('2d')
    temp.width = canvas.width
    temp.height = canvas.height
    tempctx.globalAlpha = 1//document.getElementById("opacity").value/100
    tempctx.drawImage(canvas,0,0)
    ctx.clearRect(0,0,canvas.width,canvas.height)
    ctx.drawImage(OC, 0, 0)
    OCctx.clearRect(0,0,canvas.width,canvas.height)
    OCctx.drawImage(temp,0,0)
    ctx.globalCompositeOperation = mode

  }
  ctx.globalCompositeOperation = mode
  return true
}

document.getElementById("uploadimage").addEventListener("change", drawFile, true)
document.getElementById("openextract").addEventListener("change", extractFile, true)

function pushColor (c) {
  randomPick(getCurrentPalette()) // was paintcolor = c
}

function randomPickColor() {
  randomPick(getCurrentPalette()) // was paintcolor = randomColor()
}

function updateColor () {
  let uc = document.getElementById("usercolor").value
  randomPick(getCurrentPalette()) // was paintcolor = uc
}

function randn_bm (min, max, skew) {
  let u = 0, v = 0;
  while(u === 0) u = Math.random() //Converting [0,1) to (0,1)
  while(v === 0) v = Math.random()
  let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v )
  num = num / 10.0 + 0.5 // Translate to 0 -> 1
  if (num > 1 || num < 0)
   num = randn_bm(min, max, skew) // resample between 0 and 1 if out of range
  else{
    num = Math.pow(num, skew) // Skew
    num *= max - min // Stretch to fill range
    num += min // offset to min
  }
  return num
}

function randomColor() {
  let r = ('0'+(randomFromTo(10,256)).toString(16)).slice(-2),
  g = ('0'+(randomFromTo(10,256)).toString(16)).slice(-2),
  b = ('0'+(randomFromTo(10,256)).toString(16)).slice(-2);
  return '#' +r+g+b;
}

function randomColorMedium() {
  let r = ('0'+(randomFromTo(100,200)).toString(16)).slice(-2),
  g = ('0'+(randomFromTo(100,200)).toString(16)).slice(-2),
  b = ('0'+(randomFromTo(100,200)).toString(16)).slice(-2);
  return '#' +r+g+b;
}

function randomColorLight() {
  let r = ('0'+(randomFromTo(127,256)).toString(16)).slice(-2),
  g = ('0'+(randomFromTo(127,256)).toString(16)).slice(-2),
  b = ('0'+(randomFromTo(127,256)).toString(16)).slice(-2);
  return '#' +r+g+b;
}

function randomColorVLight() {
  let r = ('0'+(randomFromTo(192,256)).toString(16)).slice(-2),
  g = ('0'+(randomFromTo(192,256)).toString(16)).slice(-2),
  b = ('0'+(randomFromTo(192,256)).toString(16)).slice(-2);
  return '#' +r+g+b;
}

function randomColorDark() {
  let r = ('0'+(randomFromTo(10,128)).toString(16)).slice(-2),
  g = ('0'+(randomFromTo(10,128)).toString(16)).slice(-2),
  b = ('0'+(randomFromTo(10,128)).toString(16)).slice(-2);
  return '#' +r+g+b;
}

function randomColorVDark() {
  let r = ('0'+(randomFromTo(10,92)).toString(16)).slice(-2),
  g = ('0'+(randomFromTo(0,92)).toString(16)).slice(-2),
  b = ('0'+(randomFromTo(0,92)).toString(16)).slice(-2);
  return '#' +r+g+b;
}

function randomColorWarm() {
  let r = ('0'+(randomFromTo(120,256)).toString(16)).slice(-2),
  g = ('0'+(randomFromTo(50,190)).toString(16)).slice(-2),
  b = ('0'+(randomFromTo(10,50)).toString(16)).slice(-2);
  return '#' +r+g+b;
}

function randomColorCool() {
  let r = ('0'+(randomFromTo(10,50)).toString(16)).slice(-2),
  g = ('0'+(randomFromTo(50,190)).toString(16)).slice(-2),
  b = ('0'+(randomFromTo(120,256)).toString(16)).slice(-2);
  return '#' +r+g+b;
}

function randomFromTo(from, to) {
  return Math.floor(Math.random() * (to - from + 1) + from);
}

function randomPick (array) {
  return array[Math.floor((array.length) * Math.random())]
}

function clipIrregular () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  let angle = Math.random() * 2 * Math.PI;
  let edges = Math.floor(19 * Math.random() + 4)
  edges *= 4
  let maxradius = Math.max(W,H)/10
  let radius = W/5
  let increase = Math.PI * 2/edges * 0.9
  let x = 0
  let y = 0
  let cx = W/2 + pet(220)
  let cy = H/2 + pet(220)
  let points = [], i = 0
  for (; i < edges; i++) {  // blobAt
    radius += (Math.random() - 0.3) * maxradius
    x = cx + radius * Math.cos(angle);
    y = cy + radius * Math.sin(angle);
    points.push([x, y]);
    angle += increase;
  }
  ctx.beginPath()
  i = 0;
  for (; i < points.length; i++) {
    if (i == 0) {
      ctx.moveTo(x, y);
    } else
    if (i % 3 == 0)
      ctx.bezierCurveTo(points[i-2][0], points[i-2][1], points[i-1][0], points[i-1][1], points[i][0], points[i][1]);
  }
  ctx.closePath()
  ctx.clip()
}

function clip () {
  alert ("clip is no longer supported")
  return
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width
  let H = canvas.height
  let len = W/2, maxy = H/2
  ctx.save()
  //let dist = document.getElementById("distro").value
  {
    ctx.beginPath();
    ctx.arc(len, len, len, 0, 2*Math.PI, false);
    ctx.closePath()
    ctx.clip()
  }
}

function drips () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  //ctx.save()
  //clip()
  let W = canvas.width
  let c = W/2
  let margin = W/20
  let w4 = (W-2*margin)/(2+Math.floor(Math.random() * 10))*8////document.getElementById("rows").value
  ctx.globalAlpha = document.getElementById("opacity").value/750
  let colors = shuffle(['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let grunge = document.getElementById("grungy").checked
  let scale = 7+document.getElementById("featuresize").value/5
  let parts = Math.floor(W/(scale*2-1)) *1.8
  let rule = true
  if (Math.random() > 0.5)
    rule = false
  if (!grunge) {
    let t = 0
    colors = []
    for (; t < 21; t++)
      colors.push(randomColor())
  }
  let x = scale, y = 71 + pet(41)
  let i = 0, r = scale/2
  let d = 0, drift = 0
  for (; i < parts; i++) {
    let x1 = x
    let xf = 20 + Math.random() * 100
    let yf = 0.001 + Math.random()/3 * 0.002
    r = scale/2 + pet(scale/4)
    while (y < 1400) {
      d = (x1-c)
      if (d < 1)
        d += -1
      drift = xf/(d+0.01)
      if (rule) {
        if (x1 > c)
          drift -= y * yf
        else
          drift += y * yf
      } else {
        if (x1 < c)
          drift -= y * yf
        else
          drift += y * yf
      }
      x1 += drift
      y += 2
      x1 += pet(1.25)
      if (r < 0.5)
        r = 0.5
      ctx.beginPath();
      ctx.moveTo(x1, y)
      ctx.arc(x1,y,1+r+pet(2) ,0,2*Math.PI)
      ctx.closePath()
      ctx.fillStyle = colors[i%colors.length]
      ctx.fill()
      r*= 0.998
    }
    x += scale * 1.05
    y = 41 + pet(41)
  }
  ctx.restore()
}

function swingset () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let C = W/2 + (Math.random() - 0.5) * W/4
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let grunge = document.getElementById("grungy").checked
  ctx.lineWidth = 10+document.getElementById("featuresize").value/5
  ctx.lineCap = "square"
  ctx.fillStyle = colors[0]
  let pad = 74, x = 0, y = 0, vpad = 190
  let dh = (W - 2*pad)/7
  
  x = pad, y = H-vpad
  ctx.beginPath()
  ctx.moveTo(x,y)
  x += dh
  y = vpad
  ctx.lineTo(x, y)
  ctx.stroke()

  y = vpad
  ctx.beginPath()
  ctx.moveTo(x, y)
  x += dh
  y = H - vpad
  ctx.lineTo(x,y)
  ctx.stroke()
  
  ctx.beginPath() //top bad
  x -= dh
  y = vpad
  ctx.moveTo(x,y)
  x = W-pad-dh
  ctx.lineTo(x, y)
  ctx.stroke()
  
  ctx.beginPath()
  x -= dh
  y = H-vpad
  ctx.moveTo(x,y)
  x += dh
  y = vpad
  ctx.lineTo(x, y)
  ctx.stroke()
  
  //x += dh
  y = vpad
  ctx.beginPath()
  ctx.moveTo(x,y)
  x += dh
  y = H-vpad
  ctx.lineTo(x, y)
  ctx.stroke()
  
 

}

function swingfill () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let C = W/2 + (Math.random() - 0.5) * W/4
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let color = randomPick(getCurrentPalette())
  let grunge = document.getElementById("grungy").checked
  ctx.lineWidth = 10+document.getElementById("featuresize").value/5
  ctx.lineCap = "square"
  ctx.strokeStyle = color
  let pad = 74, x = 0, y = 0, vpad = 190 // /\---/\
  let dh = (W - 2*pad)/7
  
  x = pad, y = H-vpad
  ctx.beginPath()
  ctx.moveTo(x,y)
  x += dh
  y = vpad
  ctx.lineTo(x, y)
  //ctx.stroke()

  y = vpad
 // ctx.beginPath()
  ctx.moveTo(x, y)
  x += dh
  y = H - vpad
  ctx.lineTo(x,y)
  ctx.stroke()
  
 // ctx.beginPath() //top bad
  x -= dh
  y = vpad
  ctx.moveTo(x,y)
  x = W-pad-dh
  ctx.lineTo(x, y)
  ctx.stroke()
  
  ctx.beginPath()
  x -= dh
  y = H-vpad
  ctx.moveTo(x,y)
  x += dh
  y = vpad
  ctx.lineTo(x, y)
  ctx.stroke()
  
  //x += dh
  y = vpad
  ctx.beginPath()
  ctx.moveTo(x,y)
  x += dh
  y = H-vpad
  ctx.lineTo(x, y)
  ctx.stroke()
  
  // swingd
  y = vpad
  x = pad + 2*dh
  ctx.beginPath()
  ctx.moveTo(x, y)
  y = H - vpad*2
  ctx.lineTo(x,y)
  x += dh
  ctx.lineTo(x,y)
  y = vpad
  ctx.lineTo(x,y)
  ctx.stroke()
  y = vpad
  
  x = pad + 4*dh
  ctx.beginPath()
  ctx.moveTo(x, y)
  y = H - vpad*2
  ctx.lineTo(x,y)
  x += dh
  ctx.lineTo(x,y)
  y = vpad
  ctx.lineTo(x,y)
  ctx.stroke()
  
  ctx.beginPath()
  x = pad + dh/2
  y = H/2
  ctx.moveTo(x,y)
  x += dh
  ctx.lineTo(x,y)
  ctx.stroke()
  
  ctx.beginPath()
  x = W - (pad + dh*1.5)
  ctx.moveTo(x,y)
  x += dh
  ctx.lineTo(x,y)
  ctx.stroke()
}

function box () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/10
  let pad = 40 //+ Math.random() *40,
  let x = W/2, y = pad
  let sqrW = W/2 + pad/2 -(2*pad), sqrH = sqrW
  let d = (W-2*pad)/2
  d *= 1.3
  let da = randomPick([2.1,3,5,8,13,100,200])
  let div = d/da
  
  ctx.fillStyle = "red"//(colors[0])
  ctx.beginPath()
  ctx.moveTo(x,y) // top center
  ctx.lineTo(x,y+d/d) // bottom center (dowm)
  ctx.lineTo(x,y+d-div)
  ctx.lineTo(x-d/2,y+d/2)
  ctx.lineTo(x,y+div)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = (colors[3])
  ctx.beginPath()
  ctx.moveTo(x,y+div)
  ctx.lineTo(x+d/2,y+d/2)
  ctx.lineTo(x,y+d-div)
  ctx.lineTo(x,y+d/2)
  ctx.lineTo(x,y+div)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = (colors[1])
  ctx.beginPath()
  x = W/2-d/2, y = pad + d/2
  ctx.moveTo(x,y)         // top left
  ctx.lineTo(x+d/2,y+d/2-div) // top right
  ctx.lineTo(x+d/2,y+d-div) // bottom right
  ctx.lineTo(x,y+d/2)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = (colors[2])
  ctx.beginPath()
  x = W/2, y = pad + d
  ctx.moveTo(x,y-div)
  ctx.lineTo(x+d/2,y-d/2)
  ctx.lineTo(x+d/2,y)
  ctx.lineTo(x,y+d/2-div)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.fill()
}

function monocube () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/10
  let pad = 150 //+ Math.random() *40,
  if (!alt) {
    ctx.shadowBlur = 10 + Math.random() * 50
    ctx.shadowColor = colors[0]
    ctx.shadowOffsetX = (Math.random()-0.5) * 28
    ctx.shadowOffsetY  = (Math.random()-0.5) * 28
  }
  /* like this
         ___
        /   |
       /    |
      |    /
      |___/
  */
  let N = 2, D = 3
  let x = pad, y = H-pad
  ctx.fillStyle = (colors[0])
  ctx.beginPath()
  ctx.moveTo(x,y)
  x = N*W/D
  ctx.lineTo(x,y)
  x = W - pad, y = N*H/D
  ctx.lineTo(x,y)
  y = pad
  ctx.lineTo(x,y)
  x = W/D
  ctx.lineTo(x,y)
  x = pad, y = H/D
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.fill()
  ctx.shadowBlur = 0
  ctx.shadowOffsetY = 0
  ctx.shadowOffsetX = 0
}

function treeStorm () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette(true,13))
  let w = 14 + document.getElementById("number").value/100
  let i = 0
  for (; i < 31; i++) {
    x = Math.random() * W
    y = Math.random() * (H - w)
    //y += (H-y)*Math.random()
    //x += (W/2-x) * Math.random()
    treeAt (x, y ,w + pet (w/2),randomPick(colors))
  }
}

function chairStorm () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette(true,13))
  let w = 14 + document.getElementById("number").value/100
  let i = 0
  for (; i < 31; i++) {
    x = Math.random() * W
    y = Math.random() * H
    y += (H-y)*Math.random()
    x += (W/2-x) * Math.random()
    chairAt (x, y ,w + pet (w/2),randomPick(colors))
  }
}

function drArray () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let N = randomPick([4,5,6,9])
  let pad = 40
  let delta = Math.round(W/N) - pad*1
  let colors = getCurrentPalette()
  let x = pad/2, y = pad/2, i = 0
  let cnt = 0
  for (; i < N*N; i++) {
    drAt (x,y,delta,randomPick (colors),i + 2)
    x += delta+pad
    cnt++
    if (cnt > 1 && cnt%N === 0) {
      x = pad/2
      y += delta+pad
    }
  }
}

function drAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  if (Math.random() > 0.5) {
    //duck
    ctx.beginPath()
    ctx.moveTo(x+0*W/10, y+10*H/10)
    cpx = x+0*W/10
    cpy = y+6*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+3*W/10, y+6*H/10)
    cpx = x+4*W/10
    cpy = y+6*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+4*W/10, y+4*H/10)
    cpx = x+0*W/10
    cpy = y+4*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+0*W/10, y+5*H/10)
    cpx = x+0*W/10
    cpy = y+2*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+4*W/10, y+2*H/10)
    cpx = x+4*W/10
    cpy = y+0*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+0*H/10)
    cpx = x+8*W/10
    cpy = y+0*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+8*W/10, y+2*H/10)
    cpx = x+7*W/10
    cpy = y+5*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+8*W/10, y+6*H/10)
    cpx = x+10*W/10
    cpy = y+6*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+10*W/10, y+10*H/10)
    ctx.stroke()
    ctx.beginPath()
    ctx.moveTo(x+4*W/10, y+3*H/10)
    cpx = x+0*W/10
    cpy = y+3*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+0*W/10, y+5*H/10)
    ctx.stroke()
    ctx.beginPath()
    ctx.moveTo(x+6*W/10, y+1*H/10)
    cpx = x+7*W/10
    cpy = y+1*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+7*W/10, y+2*H/10)
    cpx = x+7*W/10
    cpy = y+3*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+3*H/10)
    cpx = x+5*W/10
    cpy = y+3*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+2*H/10)
    cpx = x+5*W/10
    cpy = y+1*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+1*H/10)
    ctx.stroke()
  } else {
    // rabbit
    ctx.beginPath()
    ctx.moveTo(x+0*W/10, y+0*H/10)
    cpx = x+4*W/10
    cpy = y+0*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+4*W/10, y+3*H/10)
    cpx = x+4*W/10
    cpy = y+4*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+4*H/10)
    cpx = x+6*W/10
    cpy = y+4*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+4*H/10)
    cpx = x+6*W/10
    cpy = y+0*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+0*H/10)
    cpx = x+8*W/10
    cpy = y+0*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+8*W/10, y+4*H/10)
    cpx = x+10*W/10
    cpy = y+4*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+10*W/10, y+6*H/10)
    cpx = x+10*W/10
    cpy = y+8*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+8*W/10, y+8*H/10)
    cpx = x+5*W/10
    cpy = y+7*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+4*W/10, y+8*H/10)
    cpx = x+4*W/10
    cpy = y+10*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+0*W/10, y+10*H/10)
    ctx.stroke()
    ctx.beginPath()
    ctx.moveTo(x+7*W/10, y+4*H/10)
    cpx = x+7*W/10
    cpy = y+0*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+0*H/10)
    ctx.stroke()
    ctx.beginPath()
    ctx.moveTo(x+8*W/10, y+5*H/10)
    cpx = x+9*W/10
    cpy = y+5*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+9*W/10, y+6*H/10)
    cpx = x+9*W/10
    cpy = y+7*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+8*W/10, y+7*H/10)
    cpx = x+7*W/10
    cpy = y+7*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+7*W/10, y+6*H/10)
    cpx = x+7*W/10
    cpy = y+5*H/10
    ctx.quadraticCurveTo(cpx, cpy, x+8*W/10, y+5*H/10)
    ctx.stroke()
  }
}

function treeAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+4*W/8, y+4*H/8)
  cpx = x+4*W/8
  cpy = y+5*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/8, y+5*H/8)
  cpx = x+2*W/8
  cpy = y+5*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/8, y+4*H/8)
  cpx = x+2*W/8
  cpy = y+5*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/8, y+5*H/8)
  cpx = x+0*W/8
  cpy = y+5*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/8, y+4*H/8)
  cpx = x+0*W/8
  cpy = y+3*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/8, y+3*H/8)
  cpx = x+1*W/8
  cpy = y+2*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/8, y+2*H/8)
  cpx = x+2*W/8
  cpy = y+1*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/8, y+1*H/8)
  cpx = x+3*W/8
  cpy = y+0*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/8, y+0*H/8)
  cpx = x+5*W/8
  cpy = y+0*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/8, y+1*H/8)
  cpx = x+6*W/8
  cpy = y+1*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/8, y+2*H/8)
  cpx = x+7*W/8
  cpy = y+2*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/8, y+3*H/8)
  cpx = x+8*W/8
  cpy = y+3*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/8, y+4*H/8)
  cpx = x+8*W/8
  cpy = y+5*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/8, y+5*H/8)
  cpx = x+6*W/8
  cpy = y+5*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/8, y+4*H/8)
  cpx = x+6*W/8
  cpy = y+5*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/8, y+5*H/8)
  cpx = x+4*W/8
  cpy = y+5*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/8, y+4*H/8)
  ctx.lineTo(x+4*W/8, y+8*H/8)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+3*W/8, y+5*H/8)
  ctx.lineTo(x+4*W/8, y+6*H/8)
  ctx.lineTo(x+5*W/8, y+5*H/8)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+1*W/8, y+5*H/8)
  ctx.lineTo(x+4*W/8, y+6*H/8)
  ctx.lineTo(x+7*W/8, y+5*H/8)
  ctx.stroke()
}

function treeAtog (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  //y += W/4
  let H = W
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "butt"
  ctx.lineJoin = "round"
  let p = 0
 // if (alt)
 //   p = 11
  x += W/2
  let x0 = x, y0 = y
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x,y+H+pet(p))
  ctx.closePath()
  ctx.stroke()
  let UP = Math.random() > 0.5
  let i = 1, d = W/6, wt = 1, d0 = d
  d = 0
  for (; i < 7; i++) {
   // y += d0
     
    if (UP) {
      ctx.beginPath()
      ctx.moveTo(x,y+pet(p))
      ctx.lineTo(x+d,y-d+pet(p))
      ctx.closePath()
      ctx.stroke()
      
      ctx.beginPath()
      ctx.moveTo(x,y+pet(p))
      ctx.lineTo(x-d,y-d+pet(p))
      ctx.closePath()
      ctx.stroke()
    } else {
      ctx.beginPath()
      ctx.moveTo(x,y+pet(p))
      ctx.lineTo(x+d,y+pet(p))
      ctx.closePath()
      ctx.stroke()
      
      ctx.beginPath()
      ctx.moveTo(x,y+pet(p))
      ctx.lineTo(x-d,y+pet(p))
      ctx.closePath()
      ctx.stroke()
    }
    d += (1+i) * d0/11
    y += d0
  }
}

function chairAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  W *= 0.9
  y += W/4
  let H = W
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  let pad = 0 //+ Math.random() *40,
  ctx.strokeStyle = color
  ctx.lineCap = "butt"
  ctx.lineJoin = "round"
  let d = (W-2*pad)/2
  d *= 1.3
  let da = randomPick([3,5,8,13,24])
  let div = d/da
  x += W/2
  let x0 = x, y0 = y
  ctx.beginPath()
  ctx.moveTo(x,y+div)
  ctx.lineTo(x+d/2,y+d/2)
  ctx.lineTo(x,y+d-div)
  ctx.lineTo(x-d/2,y+d/2)
  ctx.lineTo(x,y+div)
  ctx.closePath()
  ctx.stroke()
  
  ctx.beginPath()
  x -= d/2, y += d/2
  ctx.moveTo(x,y)         // top left
  ctx.lineTo(x,y+d/2) // bottom right

  ctx.stroke()
  x += d
  ctx.moveTo(x,y)         // top left
  ctx.lineTo(x,y+d/2) // bottom right
  ctx.stroke()
  
  x -= d/2, y += d/2
  ctx.moveTo(x,y-div)         // top left
  ctx.lineTo(x,y+d/2-div) // bottom right
  ctx.stroke()
  
  if (Math.random() > 0.5) {
    // right back of chair
    ctx.beginPath()
    y = (y0+div-d/2)
    ctx.moveTo(x,y)         // top left
    ctx.lineTo(x+d/2,y+d/2-div) // top right
    ctx.lineTo(x+d/2,y+d-div) // bottom right
    ctx.lineTo(x,y+d/2)
    ctx.lineTo(x,y)
    ctx.closePath()
    ctx.stroke()
  } else {
    // left side
    ctx.fillStyle = (colors[2])
    ctx.beginPath()
    x = x0-d/2, y = (y0+div)
    ctx.moveTo(x,y-div)
    ctx.lineTo(x+d/2,y-d/2)
    ctx.lineTo(x+d/2,y)
    ctx.lineTo(x,y+d/2-div)
    ctx.lineTo(x,y)
    ctx.closePath()
    ctx.stroke()
  }
}


function stairs () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width
  let color = randomPick(getCurrentPalette())
  let pad = 40
  stairsAt (pad,pad,W-pad*2,color)
}

function leafAt (x,y,W,color,n) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  //ctx.strokeStyle = "#ff0000"
  //ctx.strokeRect(x,y,W,H)
  ctx.strokeStyle = color
  let x0 = x, y0 = y, off = W/10
  let r = W/4
  y += H
  ctx.beginPath()
  ctx.moveTo(x+W/2, y)
  ctx.lineTo(x+W/2, y0)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+W/2, y)
  let cpx1 = x + 4/6*W, cpx2 = x + 5/6*W // right
  let cpy1 = y0 + 5/6*H, cpy2 = y0 + 4/6*H
  ctx.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x+W/2 + 2/6*W, y-H/2)
  cpx1 = x + W/2+2/6*W, cpx2 = x +W/2
  cpy1 = y0 + 1/6*H, cpy2 = y0 + 1/6*H
  ctx.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x+W/2, y0)
  ctx.stroke()
  
  // left side
  ctx.beginPath()
  ctx.moveTo(x+W/2, y)
  cpx1 = x + 2/6*W, cpx2 = x + 1/6*W
  cpy1 = y0 + 5/6*H, cpy2 = y0 + 4/6*H
  ctx.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x+W/2 - 2/6*W, y-H/2)
  cpx1 = x + W/2-2/6*W, cpx2 = x + W/2
  cpy1 = y0 + 1/6*H, cpy2 = y0 + 1/6*H
  ctx.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x+W/2, y0)
  ctx.stroke()
}


function stairsAt (x,y,W,color,n) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, points = []
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "butt"
  ctx.lineJoin = "round"
  let x0 = x, y0 = y
  let N = n || randomPick([3,4,5,6,7,8,9,11,17,19])
  let sh = H/N, i = 0
  let xo,yo // offsets
  ctx.beginPath()
  ctx.moveTo(x+W,y+sh)
points.push(x+W,y+sh)
  ctx.lineTo(x+W,y+H)
points.push(x+W,y+H)
  ctx.lineTo(x+sh,y+H)
points.push(x+sh,y+H)
  ctx.stroke()
  
  xo = 0, yo = 0
  for (; i < (N-1)*2; i++) {
    ctx.lineTo(x +sh + (-xo), y+H-yo)
points.push(x +sh + (-xo), y+H-yo)
    if (i % 2 === 1)
      xo -= sh
    if (i % 2 === 0)
      yo += sh
  }
  ctx.closePath()
  ctx.stroke()
  
  // offet stairs
  y = y0, x = x0
  ctx.beginPath()
  ctx.moveTo(x, y+H - sh)
points.push(x, y+H - sh)
  xo = 0, yo = sh*2, i = 0
  for (; i < (N-1)*2; i++) {
    ctx.lineTo(x + (-xo), y+H-yo)
points.push(x + (-xo), y+H-yo)
    if (i % 2 === 0)
      xo -= sh
    if (i % 2 === 1)
      yo += sh
  }
  ctx.stroke()
 
  // lines between edges
  i = 0, y = y0+H, x = x0
  x += sh
  for (; i < (N); i++) {
    ctx.beginPath()
    ctx.moveTo(x, y)
points.push(x, y)
    ctx.lineTo(x-sh, y-sh)
points.push(x-sh, y-sh)
      x += sh
      y -= sh
    ctx.stroke()
  }
  i = 0, y = y0+H-sh, x = x0+sh
  for (; i < (N-1); i++) {
    ctx.beginPath()
    ctx.moveTo(x, y)
points.push(x, y)
    ctx.lineTo(x-sh, y-sh)
points.push(x-sh, y-sh)
      x += sh
      y -= sh
    ctx.stroke()
  }
  drawStars(x,y,W,points,0.6)
}

function stairsAtog (x,y,W,color,n) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "butt"
  ctx.lineJoin = "round"
  let x0 = x, y0 = y
  let N = n || randomPick([3,4,5,6,7,8,9,11,17,19]), i = 0
  let sh = H/N
  let xo,yo // offsets
  ctx.beginPath()
  ctx.moveTo(x,y+sh)
  ctx.lineTo(x,y+H)
  ctx.lineTo(x + (W-sh), y+H)
  xo = sh, yo = 0
  for (; i < (N-1)*2; i++) {
    ctx.lineTo(x + (W-xo), y+H-yo)
    if (i % 2 === 1)
      xo += sh
    if (i % 2 === 0)
      yo += sh
  }
  ctx.closePath()
  ctx.stroke()
  // offet stairs
  y = y0, x = x0
  ctx.beginPath()
  ctx.moveTo(x + W, y+H - sh)
  xo = 0, yo = sh*2, i = 0
  for (; i < (N-1)*2; i++) {
    ctx.lineTo(x + (W-xo), y+H-yo)
    if (i % 2 === 0)
      xo += sh
    if (i % 2 === 1)
      yo += sh
  }
  ctx.stroke()
  // lines between edges
  i = 0, y += sh
  let x2 = x+sh, y2 = y-sh
  for (; i < (N-1)*2 + 1; i++) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    if (i % 2 === 0)
      x += sh
    if (i % 2 === 1)
      y += sh
    ctx.lineTo(x2, y2)
    if (i % 2 === 0)
      x2 += sh
    if (i % 2 === 1)
      y2 += sh
    ctx.stroke()
  }
}

function ladderArray () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let N = randomPick([4,5,6,9,13])
  let pad = 40
  let delta = Math.round(W/N) - pad*1
  let colors = getCurrentPalette(13,true)
  let x = pad/2, y = pad/2, i = 0
  let cnt = 0
  for (; i < N*N; i++) {
    ladderAt (x,y,delta,randomPick (colors))
    x += delta+pad
    cnt++
    if (cnt > 1 && cnt%N === 0) {
      x = pad/2
      y += delta+pad
    }
  }
}

function ladder () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width
  let color = randomPick(getCurrentPalette())
  let pad = 40
  ladderAt (pad,pad,W-pad*2,color)
}

function ladderAt (x,y,W,color,n) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = "#0000ff"
 // ctx.strokeRect(x,y,W,H)
  ctx.strokeStyle = color
  ctx.lineCap = "butt"
  ctx.lineJoin = "round"
  let x0 = x, y0 = y
  let N = n || randomPick([3,4,5,7,9,11]), i = 0
  let sh = H/N
  let xo,yo // offsets
  ctx.beginPath()
  ctx.moveTo(x,y+H)
  ctx.lineTo(x+W/3,y)
  ctx.lineTo(x + (2*W/3), y+H)
  ctx.stroke()
 
  ctx.beginPath()
  ctx.moveTo(x+W/3,y+H)
  ctx.lineTo(x+2*W/3,y)
  ctx.lineTo(x + (W), y+H)
  ctx.stroke()
  // steps: use sh but with offset from top
  ctx.beginPath() // top rung
  ctx.moveTo(x+W/3,y)
  ctx.lineTo(x + (2*W/3), y)
  ctx.stroke()
  x = x+W/3+ ctx.lineWidth, y = y + sh + ctx.lineWidth*2
  for (; i < N-1; i++) {
    x += sh/3
    ctx.beginPath() // top rung
    ctx.moveTo(x,y)
    ctx.lineTo(x + W/3, y)
    ctx.stroke()
    y += sh
  }
  i = 0
  x = x0 , y = y0
  x = x+W/3, y = y + sh
  for (; i < N-1; i++) {
    x -= sh/3
    ctx.beginPath() // top rung
    ctx.moveTo(x,y)
    ctx.lineTo(x + W/3, y)
    ctx.stroke()
    y += sh
  }
}

function factoryAt (x,y,W,color,n) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = "#0000ff"
  //ctx.strokeRect(x,y,W,H)
  ctx.strokeStyle = color
  ctx.lineCap = "butt"
  ctx.lineJoin = "round"
  let x0 = x, y0 = y, points = []
  let r = W/12
  ctx.beginPath()
  ctx.moveTo(x, y+3*H/4)
points.push(x, y+3*H/4)
  ctx.lineTo(x, y+H)
points.push(x, y+H)
  ctx.lineTo(x+W, y+H)
points.push(x+W, y+H)
  ctx.lineTo(x+W, y+3*H/4)
points.push(x+W, y+3*H/4)
  ctx.lineTo(x, y+3*H/4)
points.push(x, y+3*H/4)
  ctx.lineTo(x + W/3-r*3.5, y+3*H/4-r*2)
points.push(x + W/3-r*3.5, y+3*H/4-r*2)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+W, y+3*H/4)
points.push(x+W, y+3*H/4)
  ctx.lineTo(x+W-r*3.5+3*r, y+3*H/4-r*2)
points.push(x+W-r*3.5+3*r, y+3*H/4-r*2)
  ctx.stroke()
  
  ctx.beginPath() // back line left
  ctx.moveTo(x + W/3 -r/2, y+3*H/4-r*2)
points.push(x + W/3 -r/2, y+3*H/4-r*2)
  ctx.lineTo(x + W/3 +r/2, y+3*H/4-r*2)
points.push(x + W/3 +r/2, y+3*H/4-r*2)
  ctx.stroke()
  ctx.beginPath() // back line right
  ctx.moveTo(r*4+x + W/3 -r/2, y+3*H/4-r*2)
  ctx.lineTo(r*4+x + W/3 +r/2, y+3*H/4-r*2)
  ctx.stroke()
  
  //let cpx = x + W/3, cpy = y + H/3
  ctx.beginPath() // left stack
  ctx.arc(x + W/3-r*2, y + r, r, 0, Math.PI*2)
points.push(x + W/3-r*2, y + r)
  ctx.arc(x + W/3-r*2, y+3*H/4-r*2, r*1.5, 0, Math.PI)
points.push(x + W/3-r*2, y+3*H/4-r*2)
  cpx = x + W/3-r*4, cpy = y + H/3
  ctx.lineTo(x + W/3-(r*3), y+r)
points.push(x + W/3-(r*3), y+r)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.arc(x +2* W/3-r*2, y + r, r, 0, Math.PI*2)
points.push(x +2* W/3-r*2, y + r)
  ctx.arc(x + 2*W/3-r*2, y+3*H/4-r*2, r*1.5, 0, Math.PI)
points.push(x + 2*W/3-r*2, y+3*H/4-r*2)
  ctx.lineTo(x +2* W/3-r*3, y+r)
points.push(x +2* W/3-r*3, y+r)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.arc(x +3* W/3-r*2, y + r, r, 0, Math.PI*2)
points.push(x +3* W/3-r*2, y + r)
  ctx.arc(x + 3*W/3-r*2, y+3*H/4-r*2, r*1.5, 0, Math.PI)
points.push(x + 3*W/3-r*2, y+3*H/4-r*2)
  ctx.lineTo(x +3* W/3-r*3, y+r)
points.push(x +3* W/3-r*3, y+r)
  ctx.stroke()
  
  // door
  r *= 0.8
  ctx.beginPath()
  ctx.moveTo(x+W/2-r, y+H)
points.push(x+W/2-r, y+H)
  ctx.arc(x+W/2, y+H-1.5*r, r, Math.PI, Math.PI*2)
points.push(x+W/2, y+H-1.5*r)
  ctx.lineTo(x+W/2+r, y+H)
points.push(x+W/2+r, y+H)
  ctx.stroke()
  drawStars(x,y,W,points)
}

function birdhouseAt (x,y,W,color,n) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, points = []
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = "#0000ff"
  //ctx.strokeRect(x,y,W,H)
  ctx.strokeStyle = color
  ctx.lineCap = "butt"
  ctx.lineJoin = "round"
  let x0 = x, y0 = y
  let r = W/12
  ctx.beginPath()
  ctx.moveTo(x, y+H/2)
points.push(x, y+H/2)
  ctx.lineTo(x, y+H)
points.push(x, y+H)
  ctx.lineTo(x+W, y+H)
points.push(x+W, y+H)
  ctx.lineTo(x+W, y+H/2)
points.push(x+W, y+H/2)
  ctx.lineTo(x+3*W/4, y)
points.push(x+3*W/4, y)
  ctx.lineTo(x+W/4, y)
points.push(x+W/4, y)
  ctx.lineTo(x, y+H/2)
points.push(x, y+H/2)
  ctx.lineTo(x+W/2, y+H/2)
points.push(x+W/2, y+H/2)
  ctx.lineTo(x+W/2, y+H)
points.push(x+W/2, y+H)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+W/2, y+H/2)
points.push(x+W/2, y+H/2)
  ctx.lineTo(x+3*H/4, y)
points.push(x+3*H/4, y)
  ctx.stroke()

  ctx.beginPath()
  ctx.arc(x+3*W/4, y+H/2, r, 0, Math.PI*2)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.arc(x+3*W/4, y+H/2+r*2, r/3, Math.PI*1.5, Math.PI/2, true)
  ctx.arc(x+3*W/4+r*2, y+H/2+r*2, r/3, Math.PI/2, Math.PI*1.5)
  ctx.closePath()
  ctx.stroke()
  
  ctx.beginPath()
  ctx.arc(x+3*W/4+r*2, y+H/2+r*2, r/3, Math.PI *1.5, Math.PI*0.5)
  ctx.stroke()
  drawStars(x,y,W,points,0.1)
}

function swing () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width
  let color = randomPick(getCurrentPalette())
  let pad = 40
  swingAt (pad,pad,W-pad*2,color)
}

function swingArray () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let N = randomPick([4,5,6,9,13])
  let pad = 40
  let delta = Math.round(W/N) - pad*1
  let colors = getCurrentPalette(13,true)
  let x = pad/2, y = pad/2, i = 0
  let cnt = 0
  for (; i < N*N; i++) {
    swingAt (x,y,delta,randomPick (colors))
    x += delta+pad
    cnt++
    if (cnt > 1 && cnt%N === 0) {
      x = pad/2
      y += delta+pad
    }
  }
}

function spiderAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+9*H/12)
points.push(x+6*W/12, y+9*H/12)
  cpx = x+8*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+7*H/12)
  cpx = x+8*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+5*H/12)
  cpx = x+4*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+7*H/12)
  cpx = x+4*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+9*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+5*H/12)
points.push(x+6*W/12, y+5*H/12)
  cpx = x+7*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+4*H/12)
  cpx = x+7*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+3*H/12)
  cpx = x+5*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+4*H/12)
  cpx = x+5*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+5*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+4*H/12)
points.push(x+5*W/12, y+4*H/12)
  ctx.lineTo(x+5*W/12, y+2*H/12)
points.push(x+5*W/12, y+2*H/12)
  ctx.lineTo(x+3*W/12, y+0*H/12)
points.push(x+3*W/12, y+0*H/12)
  ctx.lineTo(x+1*W/12, y+0*H/12)
points.push(x+1*W/12, y+0*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+4*H/12)
points.push(x+7*W/12, y+4*H/12)
  ctx.lineTo(x+7*W/12, y+2*H/12)
points.push(x+7*W/12, y+2*H/12)
  ctx.lineTo(x+9*W/12, y+0*H/12)
points.push(x+9*W/12, y+0*H/12)
  ctx.lineTo(x+11*W/12, y+0*H/12)
points.push(x+11*W/12, y+0*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+4*H/12)
points.push(x+5*W/12, y+4*H/12)
  ctx.lineTo(x+3*W/12, y+2*H/12)
points.push(x+3*W/12, y+2*H/12)
  ctx.lineTo(x+1*W/12, y+2*H/12)
points.push(x+1*W/12, y+2*H/12)
  ctx.lineTo(x+0*W/12, y+5*H/12)
points.push(x+0*W/12, y+5*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+4*H/12)
points.push(x+7*W/12, y+4*H/12)
  ctx.lineTo(x+9*W/12, y+2*H/12)
points.push(x+9*W/12, y+2*H/12)
  ctx.lineTo(x+11*W/12, y+2*H/12)
points.push(x+11*W/12, y+2*H/12)
  ctx.lineTo(x+12*W/12, y+5*H/12)
points.push(x+12*W/12, y+5*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+5*H/12)
points.push(x+5*W/12, y+5*H/12)
  ctx.lineTo(x+3*W/12, y+4*H/12)
points.push(x+3*W/12, y+4*H/12)
  ctx.lineTo(x+0*W/12, y+7*H/12)
points.push(x+0*W/12, y+7*H/12)
  ctx.lineTo(x+1*W/12, y+8*H/12)
points.push(x+1*W/12, y+8*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+5*H/12)
points.push(x+7*W/12, y+5*H/12)
  ctx.lineTo(x+9*W/12, y+4*H/12)
points.push(x+9*W/12, y+4*H/12)
  ctx.lineTo(x+12*W/12, y+7*H/12)
points.push(x+12*W/12, y+7*H/12)
  ctx.lineTo(x+11*W/12, y+8*H/12)
points.push(x+11*W/12, y+8*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+5*H/12)
points.push(x+7*W/12, y+5*H/12)
  ctx.lineTo(x+10*W/12, y+6*H/12)
points.push(x+10*W/12, y+6*H/12)
  ctx.lineTo(x+8*W/12, y+11*H/12)
points.push(x+8*W/12, y+11*H/12)
  ctx.lineTo(x+9*W/12, y+12*H/12)
points.push(x+9*W/12, y+12*H/12)
  ctx.lineTo(x+10*W/12, y+12*H/12)
points.push(x+10*W/12, y+12*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+5*H/12)
points.push(x+5*W/12, y+5*H/12)
  ctx.lineTo(x+2*W/12, y+6*H/12)
points.push(x+2*W/12, y+6*H/12)
  ctx.lineTo(x+4*W/12, y+11*H/12)
points.push(x+4*W/12, y+11*H/12)
  ctx.lineTo(x+3*W/12, y+12*H/12)
points.push(x+3*W/12, y+12*H/12)
  ctx.lineTo(x+2*W/12, y+12*H/12)
points.push(x+2*W/12, y+12*H/12)
  ctx.stroke()
  drawStars(x,y,W,points, 0.5)
}

function swingAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  let C = W/2 + (Math.random() - 0.5) * W/4
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let grunge = document.getElementById("grungy").checked
  ctx.lineWidth = 1+document.getElementById("featuresize").value/50
  ctx.lineCap = "butt"
  ctx.strokeStyle = color

  let pad = 0, vpad = 0
  let x0 = x, y0 = y
  //   /\
  //  /
  // /\
  let dh = W/7
  
  y += H // lower left A
  ctx.beginPath()
  ctx.moveTo(x,y)
  x += dh
  y -= H/2
  ctx.lineTo(x, y)
  x += dh
  y += H/2
  ctx.lineTo(x,y)
  ctx.stroke()
  
//top bar
  x -= dh
  y -= H/2
  ctx.moveTo(x,y)
  x += 5*dh
  ctx.lineTo(x, y0)
  ctx.stroke()
  
  // right upper A
  y = y0
  ctx.beginPath()
  x -= 1*dh
  y += H/2
  ctx.moveTo(x,y)
  x += dh
  y -= H/2
  ctx.lineTo(x, y)
  x += dh
  y += H/2
  ctx.lineTo(x, y)
  ctx.stroke()
  
  y = y0, x = x0
  // swings
  y += H/2 - H/10
  x += 2*dh
  ctx.beginPath()
  ctx.moveTo(x, y)
  y += 3.5*H/10
  ctx.lineTo(x,y)
  x += dh
  y -= H/10
  ctx.lineTo(x,y)
  y -= 3.5*H/10
  ctx.lineTo(x,y)
  ctx.stroke()
  
  y = y0
  // swings
  y += H/2 - 3*H/10
  x += dh
  ctx.beginPath()
  ctx.moveTo(x, y)
  y += 3.5*H/10
  ctx.lineTo(x,y)
  x += dh
  y -= H/10
  ctx.lineTo(x,y)
  y -= 3.5*H/10
  ctx.lineTo(x,y)
  ctx.stroke()
  
  x = x0, y = y0
  // 2 A bars
  ctx.beginPath()
  x += dh/2
  y += 3*H/4
  ctx.moveTo(x,y)
  x += dh
  ctx.lineTo(x,y)
  ctx.stroke()
  
  ctx.beginPath()
  x += 4*dh
  y -= H/2
  ctx.moveTo(x,y)
  x += dh
  ctx.lineTo(x,y)
  ctx.stroke()
}

function jumpropeAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  let C = W/2 + (Math.random() - 0.5) * W/4
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let grunge = document.getElementById("grungy").checked
  ctx.lineWidth = 1+document.getElementById("featuresize").value/50
  ctx.lineCap = "butt"
  ctx.strokeStyle = "#0000FF"
 // ctx.strokeRect(x,y,W,H)
  ctx.strokeStyle = color
  let pad = 0, vpad = 0
  let x0 = x, y0 = y, r = W/10, points = []
  ctx.beginPath()
  ctx.arc(x+r, y+r, r/1.5, 0, Math.PI*2)
  ctx.arc(x+r, y+2*H/5, r/2, 0, Math.PI)
  ctx.arc(x+r, y+r, r/1.5, Math.PI, Math.PI*2)
  ctx.arc(x+r, y+2*H/5, r/2, 0, Math.PI/2)
  ctx.arc(x+W/5, y+4*W/5, r, Math.PI, 0, true)
  ctx.arc(x+2*W/5, y+W/5, r, Math.PI, Math.PI*2)
  ctx.arc(x+3*W/5, y+4*W/5, r, Math.PI, 0, true)
  ctx.arc(x+4*W/5, y+W/5, r, Math.PI, Math.PI*2)
  ctx.arc(x+4*W/5+r, y+3*W/5, r/2, Math.PI*1.5, Math.PI*2)
  ctx.arc(x+W-r, y+H-r, r/1.5, 0, Math.PI*2)
  ctx.arc(x+W-r, y+H-r, r/1.5, 0, Math.PI)
  ctx.arc(x+4*W/5+r, y+3*W/5, r/2, Math.PI, Math.PI *1.5)
  ctx.stroke()
}

function slide () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width
  let color = randomPick(getCurrentPalette())
  let pad = 40
  slideAt (pad,pad,W-pad*2,color)
}

function slideArray () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let N = randomPick([4,5,6,9,13])
  let pad = 40
  let delta = Math.round(W/N) - pad*1
  let colors = getCurrentPalette(13,true)
  let x = pad/2, y = pad/2, i = 0
  let cnt = 0
  for (; i < N*N; i++) {
    if (i%2 === 0)
      slideAt (x,y,delta,randomPick (colors))
    else
      ladderAt (x,y,delta,randomPick (colors))
    x += delta+pad
    cnt++
    if (cnt > 1 && cnt%N === 0) {
      x = pad/2
      y += delta+pad
    }
  }
}

function slideAt (x,y,W,color,n) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = "#0000ff"
  //ctx.strokeRect(x,y,W,H)
  ctx.strokeStyle = color
  ctx.lineCap = "butt"
  ctx.lineJoin = "round"
  let x0 = x, y0 = y
  let N = n || randomPick([3,4,5,7,9,11]), i = 0
  let sh = H/N
  let xo,yo // offsets
  let points = []
  ctx.beginPath()
  ctx.moveTo(x,y+H)
points.push(x,y+H)
  ctx.lineTo(x+W/4,y)
points.push(x+W/4,y)
  let cpx1 = x+W/2, cpy1 = y
  let cpx2 = x+W/2, cpy2 = y + H/3
  ctx.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x+W/2,y+(H-(H/5))/2)
  
  cpx1 = x+W/2, cpy1 = y + H/2
  cpx2 = x+W/2, cpy2 = y + 3*H/4
  ctx.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x+3*W/4,y+4*H/5)
  ctx.lineTo(x+3*W/4,y+H)
points.push(x+3*W/4,y+H)
  ctx.stroke()
 
  // rightmodr slide
  ctx.beginPath()
  ctx.moveTo(x+W/2,y)
 // ctx.lineTo(x+W/4,y)
  cpx1 = x+3*W/4, cpy1 = y
  cpx2 = x+3*W/4, cpy2 = y + H/3
  ctx.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x+3*W/4,y+(H-(H/5))/2)
  
  cpx1 = x+3*W/4, cpy1 = y + H/2
  cpx2 = x+3*W/4, cpy2 = y + 3*H/4
  ctx.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x+W,y+4*H/5)
  ctx.lineTo(x+W,y+H)
points.push(x+W,y+H)
  ctx.stroke()
  
  ctx.beginPath() // bottom of slide horz
  ctx.moveTo(x+3*W/4,y+4*H/5)
points.push(x+3*W/4,y+4*H/5)
  ctx.lineTo(x+W,y+4*H/5)
points.push(x+W,y+4*H/5)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+W/4,y+H)
points.push(x+W/4,y+H)
  ctx.lineTo(x+W/2,y)
points.push(x+W/2,y)
  ctx.stroke()
  
  // steps: use sh but with offset from top
  ctx.beginPath() // top rung
  ctx.moveTo(x+W/4,y)
points.push(x+W/4,y)
  ctx.lineTo(x + (W/2), y)
points.push(x + (W/2), y)
  ctx.stroke()

  i = 0
  x = x0 , y = y0
  x = x+W/4, y = y + sh
  for (; i < N-1; i++) {
    x -= sh/4
    ctx.beginPath() // top rung
    ctx.moveTo(x,y)
points.push(x,y)
    ctx.lineTo(x + W/4, y)
points.push(x + W/4, y)
    ctx.stroke()
    y += sh
  }
  drawStars(x,y,W,points)
}

function abirdhouse () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width
  let color = randomPick(getCurrentPalette())
  let pad = 40
  birdhouseAt (pad,pad,W-pad*2,color)
}

function lamp () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width
  let color = randomPick(getCurrentPalette())
  let pad = 40
  lampAt (pad,pad,W-pad*2,color)
}

function lampArray () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let N = randomPick([4,5,6,9,13])
  let pad = 40
  let delta = Math.round(W/N) - pad*1
  let colors = getCurrentPalette(13,true)
  let x = pad/2, y = pad/2, i = 0
  let cnt = 0
  for (; i < N*N; i++) {
    if (i%2 === 0)
      lampAt (x,y,delta,randomPick (colors))
    else
      lampAt (x,y,delta,randomPick (colors))
    x += delta+pad
    cnt++
    if (cnt > 1 && cnt%N === 0) {
      x = pad/2
      y += delta+pad
    }
  }
}

function lampAt (x,y,W,color,n) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  let points = []
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = "#0000ff"
  //ctx.strokeRect(x,y,W,H)
  ctx.strokeStyle = color
  ctx.lineCap = "butt"
  ctx.lineJoin = "round"
  let x0 = x, y0 = y
  let N = n || randomPick([3,4,5,7,9,11]), i = 0
  let sh = H/N
  let xo,yo // offsets
  // base
  ctx.beginPath()
  ctx.ellipse(x+W/2, y+H-H/10, W/5, W/10,0,0,Math.PI*2)
  ctx.stroke()
  
  // wide bottom
  ctx.beginPath()
  ctx.ellipse(x+W/2, y+H/2, W/3, W/6, 0 ,0, Math.PI)
  ctx.ellipse(x+W/2, y+H/10, W/5, W/10, 0, Math.PI, Math.PI *2)
  ctx.closePath()
  ctx.stroke()
  
  ctx.beginPath()
  ctx.ellipse(x+W/2, y+H/10, W/5, W/10, 0, 0, Math.PI *2)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.ellipse(x+W/2, y+H/10, W/20, W/40, 0, 0, Math.PI *2)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.ellipse(x+W/2, y+H-H/10, W/20, W/40, 0, 0, Math.PI *2)
  ctx.stroke()
  // line up from base
  ctx.beginPath()
  ctx.moveTo(x+W/2, y+H-H/10)
  ctx.lineTo(x+W/2, y+H/2 + W/6)
  ctx.stroke()
  // spoke straight down
  ctx.beginPath()
  ctx.moveTo(x+W/2, y+H/10)
  ctx.lineTo(x+W/2, y+2*W/10)
  ctx.stroke()
  
  // spoke to left
  let xc = x+W/2, yc = y + H/10
  let angle = Math.PI + Math.PI/6
  ctx.beginPath()
  ctx.moveTo(xc, yc)
  xc = W/6.6 * Math.cos(angle)+xc;
  yc = W/6.6 * Math.sin(angle)+yc;
  ctx.lineTo(xc,yc)
  ctx.stroke()
  // spoke to right
  xc = x+W/2, yc = y + H/10
  angle = Math.PI * 2 - Math.PI/6
  ctx.beginPath()
  ctx.moveTo(xc, yc)
  xc = W/6.6 * Math.cos(angle)+xc;
  yc = W/6.6 * Math.sin(angle)+yc;
  ctx.lineTo(xc,yc)
  ctx.stroke()
}

function thought () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width
  let color = randomPick(getCurrentPalette())
  let pad = 40
  thoughtAt (pad,pad,W-pad*2,color)
}

function thoughtArray () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let N = randomPick([4,5,6,9,13])
  let pad = 40
  let delta = Math.round(W/N) - pad*1
  let colors = getCurrentPalette(13,true)
  let x = pad/2, y = pad/2, i = 0
  let cnt = 0
  for (; i < N*N; i++) {
    thoughtAt (x,y,delta,randomPick (colors))
    x += delta+pad
    cnt++
    if (cnt > 1 && cnt%N === 0) {
      x = pad/2
      y += delta+pad
    }
  }
}

function thoughtAt (x,y,W,color,n) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  //ctx.strokeStyle = "#0000ff"
  //ctx.strokeRect(x,y,W,H)
  ctx.strokeStyle = color
  ctx.lineCap = "butt"
  ctx.lineJoin = "round"
  let x0 = x, y0 = y
  let divs = randomPick([7,9,11])
  let a = (Math.PI * 2)/divs/3, angle = Math.PI * Math.random()
  let r = W/2, cx = x + W/2 + W/20, cy = y + H/2 - H/18
  ctx.beginPath()
  x = r/1.3 * Math.cos(angle)+cx;
  y = r/1.3 * Math.sin(angle)+cy
  ctx.moveTo(x,y)
  let i = 0
  for (; i < divs; i++) {
    angle += a
    x = r * Math.cos(angle)+cx
    y = r * Math.sin(angle)+cy
    let cpx1 = x, cpy1 = y
    angle += a
    x = r * Math.cos(angle)+cx
    y = r * Math.sin(angle)+cy
    let cpx2 = x, cpy2 = y
    angle += a
    x = r/1.3 * Math.cos(angle)+cx
    y = r/1.3 * Math.sin(angle)+cy
    ctx.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x,y)
  }
  ctx.stroke()
  x = x0, y = y0
  ctx.beginPath()
  ctx.arc(x+W/20, y+H-H/20, W/24, 0, Math.PI*2)
  ctx.stroke()
  ctx.beginPath()
  ctx.arc(x+W/5, y+H-H/8, W/14, 0, Math.PI*2)
  ctx.stroke()
}

function flatchairAt (x,y,W,color,n) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  let points = []
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  //ctx.strokeStyle = "#0000ff"
  //ctx.strokeRect(x,y,W,H)
  ctx.strokeStyle = color
  ctx.lineCap = "butt"
  ctx.lineJoin = "round"
  let x0 = x, y0 = y

  ctx.beginPath()
  ctx.moveTo(x,y+2*H/3)
points.push(x,y+2*H/3)
  ctx.lineTo(x+W/2,y)
points.push(x+W/2,y)
  ctx.lineTo(x+W,y)
points.push(x+W,y)
  ctx.lineTo(x+3*W/4,y+H/3)
points.push(x+3*W/4,y+H/3)
  ctx.lineTo(x+W,y+2*H/3)
points.push(x+W,y+2*H/3)
  ctx.lineTo(x+3*W/4,y+H)
points.push(x+3*W/4,y+H)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+W/4,y+H)
points.push(x+W/4,y+H)
  ctx.lineTo(x+W/2,y+2*H/3)
points.push(x+W/2,y+2*H/3)
  ctx.lineTo(x+W/4,y+H/3)
points.push(x+W/4,y+H/3)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+W/2,y+2*H/3)
points.push(x+W/2,y+2*H/3)
  ctx.lineTo(x+W,y+2*H/3)
points.push(x+W,y+2*H/3)
  ctx.stroke()
  
  // optional?
  ctx.beginPath()
  ctx.moveTo(x+W/4,y+H/3)
points.push(x+W/4,y+H/3)
  ctx.lineTo(x+3*W/4,y+H/3)
points.push(x+3*W/4,y+H/3)
  ctx.stroke()
  drawStars(x,y,W,points,0.1)
}

function pointhouseAt (x,y,W,color,n) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = "#ff0000"
  //ctx.strokeRect(x,y,W,H)
  ctx.strokeStyle = color
  ctx.lineCap = "butt"
  ctx.lineJoin = "round"
  let x0 = x, y0 = y

  ctx.beginPath()
  ctx.moveTo(x, y+W/4)
  ctx.lineTo(x+2*W/5, y+H/4)
  ctx.lineTo(x+3*W/5, y)
  ctx.lineTo(x+4*W/5, y+H/4)
  ctx.lineTo(x+W, y+H/4)
  ctx.lineTo(x+W, y+H)
  ctx.lineTo(x+W/5, y+H)
  ctx.lineTo(x, y+4*H/5)
  ctx.closePath()
  ctx.stroke()

  ctx.beginPath()
  ctx.moveTo(x+W/5,y+H/4)
  ctx.lineTo(x+2*W/5,y)
  ctx.lineTo(x+3*W/5,y)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+W/5,y+H)
  ctx.lineTo(x+W/5,y+H/4)
  ctx.stroke()
  // door
  let dw = W/15
  ctx.beginPath()
  ctx.moveTo(x+3*W/5-dw,y+H)
  ctx.lineTo(x+3*W/5-dw,y+H-dw*4)
  ctx.lineTo(x+3*W/5+dw,y+H-dw*4)
  ctx.lineTo(x+3*W/5+dw,y+H)
  ctx.stroke()
}

function breadAt (x,y,W,color,n) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = "#ff0000"
  //ctx.strokeRect(x,y,W,H)
  ctx.strokeStyle = color
  ctx.lineCap = "butt"
  ctx.lineJoin = "round"
  let x0 = x, y0 = y, r = 2*W/5

  ctx.beginPath()
  ctx.moveTo(x, y+H)
  ctx.lineTo(x, y+H/2)
  ctx.arc(x+2*W/5, y +r, r,Math.PI, Math.PI*2)
  ctx.lineTo(x+4*W/5, y+H)
  ctx.lineTo(x, y+H)
  ctx.closePath()
  ctx.stroke()
  //shadow right
  ctx.beginPath()
  ctx.moveTo(x+4*W/5, y+H)
  ctx.lineTo(x+W, y+H)
  ctx.lineTo(x+W, y+H/2)
  ctx.arc(x+3*W/5, y +r, r,Math.PI*2, Math.PI*1.5, true)
  ctx.lineTo(x+2*W/5, y)
  ctx.stroke()
  
  // door
  let dw = W/17
  ctx.beginPath()
  ctx.moveTo(x+2*W/5-dw,y+H)
  ctx.lineTo(x+2*W/5-dw,y+H-dw*4)
  ctx.lineTo(x+2*W/5+dw,y+H-dw*4)
  ctx.lineTo(x+2*W/5+dw,y+H)
  ctx.stroke()
}

function cityAt (x,y,W,color,n) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = "#ff0000"
  ctx.strokeRect(x,y,W,H)
  ctx.strokeStyle = color
  ctx.lineCap = "butt"
  ctx.lineJoin = "round"
  let x0 = x, y0 = y

  ctx.beginPath()
  ctx.moveTo(x, y)
  ctx.lineTo(x+W/2, y+H/4)
  ctx.lineTo(x+W/4, y+H/2)
  ctx.lineTo(x+W/2, y+3*H/4-H/8)
  ctx.lineTo(x+3*H/4, y+H/2-H/8)
  ctx.stroke()

  ctx.beginPath()
  ctx.moveTo(x+W/4,y+H/2)
  ctx.lineTo(x+W/4,y+H)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+W/2,y+H/2+H/8)
  ctx.lineTo(x+W/2,y+H)
  ctx.lineTo(x+3*W/4, y+3*H/4)
  ctx.lineTo(x+W,y+H - H/8)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x, y+H/2)
  ctx.lineTo(x+W/4,y+3*H/4 - H/8)
  
  ctx.stroke()
  
  // door
  let dw = W/20
  ctx.beginPath()
  ctx.moveTo(x+W/8-dw,y+H/2+dw*0.75)
  ctx.lineTo(x+W/8-dw,y+H/2-dw*3)
  ctx.lineTo(x+W/8+dw,y+H/2-dw*2)
  ctx.lineTo(x+W/8+dw,y+H/2+dw*1.75)
  ctx.stroke()
}

function bird2At (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  let cpx = x, cpy = y
  ctx.beginPath()
  ctx.moveTo(x+0*W/13, y+13*H/13)
  ctx.lineTo(x+3*W/13, y+10*H/13)
  
  //ctx.lineTo(x+9*W/13, y+10*H/13)
  //ctx.lineTo(x+9*W/13, y+5*H/13)
  cpx = x+9*W/13, cpy = y+9*W/13
  ctx.quadraticCurveTo(cpx,cpy,x+9*W/13, y+5*H/13)
  //ctx.lineTo(,)
  
  ctx.lineTo(x+11*W/13, y+3*H/13)
  ctx.lineTo(x+13*W/13, y+2*H/13)
  ctx.lineTo(x+11*W/13, y+1*H/13)
  ctx.lineTo(x+11*W/13, y+0*H/13)
  ctx.lineTo(x+7*W/13, y+0*H/13)
  ctx.lineTo(x+6*W/13, y+3*H/13)
  ctx.lineTo(x+0*W/13, y+5*H/13)
  ctx.lineTo(x+2*W/13, y+8*H/13)
  ctx.lineTo(x+0*W/13, y+9*H/13)
  ctx.lineTo(x+0*W/13, y+13*H/13)
  ctx.stroke()
  // feet
  ctx.beginPath()
  ctx.moveTo(x+7*W/13, y+10*H/13)
  ctx.lineTo(x+9*W/13, y+12*H/13)
  ctx.lineTo(x+9*W/13, y+13*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+9*W/13, y+12*H/13)
  ctx.lineTo(x+10*W/13, y+12*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/13, y+10*H/13)
  ctx.lineTo(x+6*W/13, y+13*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/13, y+12*H/13)
  ctx.lineTo(x+5*W/13, y+13*H/13)
  ctx.stroke()
}

function flathouseAt (x,y,W,color,n) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  let x0 = x, y0 = y
  let points = []
  ctx.beginPath()
  ctx.moveTo(x, y+H)
points.push(x, y+H)
  ctx.lineTo(x, y+H/2)
points.push(x, y+H/2)
  ctx.lineTo(x+W/3, y+H/4)
points.push(x+W/3, y+H/4)
  ctx.lineTo(x+2*W/3, y+H/2)
points.push(x+2*W/3, y+H/2)
  ctx.lineTo(x+2*W/3, y+W)
points.push(x+2*W/3, y+W)
  ctx.lineTo(x, y+W)
points.push(x, y+W)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+W/3,y+H/4)
points.push(x+W/3,y+H/4)
  ctx.lineTo(x+2*W/3,y)
points.push(x+2*W/3,y)
  ctx.lineTo(x+W,y+H/4)
points.push(x+W,y+H/4)
  ctx.lineTo(x+W, y+H)
points.push(x+W, y+H)
  ctx.lineTo(x+2*W/3, y+H)
points.push(x+2*W/3, y+H)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+2*W/3,y+H/2)
points.push(x+2*W/3,y+H/2)
  ctx.lineTo(x+W,y+H/4)
points.push(x+W,y+H/4)
  ctx.stroke()
  
  // door
  let dw = W/12
  ctx.beginPath()
  ctx.moveTo(x+W/3-dw,y+H)
points.push(x+W/3-dw,y+H)
  ctx.lineTo(x+W/3-dw,y+H-dw*3)
points.push(x+W/3-dw,y+H-dw*3)
  ctx.lineTo(x+W/3+dw,y+H-dw*3)
points.push(x+W/3+dw,y+H-dw*3)
  ctx.lineTo(x+W/3+dw,y+H)
points.push(x+W/3+dw,y+H)
  ctx.stroke()
  
  //chimney
  ctx.beginPath()
  ctx.moveTo(x+W/3-dw,y+H/4+dw*0.75)
points.push(x+W/3-dw,y+H/4+dw*0.75)
  ctx.lineTo(x+W/3-dw,y+H/4-dw*2)
points.push(x+W/3-dw,y+H/4-dw*2)
  ctx.moveTo(x+W/3+dw,y+H/4-dw*2)
points.push(x+W/3+dw,y+H/4-dw*2)
  ctx.lineTo(x+W/3+dw,y+H/4-dw*0.75)
points.push(x+W/3+dw,y+H/4-dw*0.75)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+W/3-dw, y+H/4-dw*2)
points.push(x+W/3-dw, y+H/4-dw*2)
  ctx.lineTo(x+W/3, y+H/4-dw*3)
points.push(x+W/3, y+H/4-dw*3)
  ctx.lineTo(x+W/3+dw, y+H/4-dw*2)
points.push(x+W/3+dw, y+H/4-dw*2)
  ctx.lineTo(x+W/3, y+H/4-dw*1)
points.push(x+W/3, y+H/4-dw*1)
  ctx.closePath()
  ctx.stroke()
  
  drawStars(x,y,W,points)
}

function rowhousesAt (x,y,W,color,n) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = "#0000ff"
 // ctx.strokeRect(x,y,W,H)
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.lineJoin = "round"
  let x0 = x, y0 = y

  ctx.beginPath()
  ctx.moveTo(x+3*H/8, y) // left peak
  ctx.lineTo(x, y+H/4)
  ctx.lineTo(x, y+H)
  ctx.lineTo(x+H/4, y+H)
  ctx.lineTo(x+W, y+3*H/4)
  ctx.lineTo(x+W, y+H/4)
  
  ctx.lineTo(x+W-W/8, y)
  ctx.lineTo(x+W-2*W/8, y+H/4)
  ctx.lineTo(x+W-3*W/8, y)
  ctx.lineTo(x+W-4*W/8, y+H/4)
  ctx.lineTo(x+W-5*W/8, y)
  ctx.lineTo(x+W-6*W/8, y+H/4)
  ctx.lineTo(x+W/4, y+H)
  ctx.stroke()
  
  ctx.beginPath() // right peak tp left
  ctx.moveTo(x+W-W/8, y)
  ctx.lineTo(x+W-2.5*W/8, y+1*H/8)
  ctx.stroke()
  
  ctx.beginPath() // middle peak tp left
  ctx.moveTo(x+W-3*W/8, y)
  ctx.lineTo(x+W-4.5*W/8, y+1*H/8)
  ctx.stroke()
  
  ctx.beginPath() // right wall
  ctx.moveTo(x+W-2*W/8, y+H/4)
  ctx.lineTo(x+W-2*W/8, y+3*H/4+H/4/3)
  ctx.stroke()
  
  ctx.beginPath() // middle wall
  ctx.moveTo(x+W-4*W/8, y+H/4)
  ctx.lineTo(x+W-4*W/8, y+3*H/4+2*H/4/3)
  ctx.stroke()

  
  // door right
  let dw = W/24
  let bump = (3*W/4) / 12
  ctx.beginPath()
  ctx.moveTo(x+W-W/8-dw,y+H-3.1*bump)
  ctx.lineTo(x+W-W/8-dw,y+H-dw*3-3.1*bump)
  ctx.lineTo(x+W-W/8+dw,y+H-dw*3-3.6*bump)
  ctx.lineTo(x+W-W/8+dw,y+H-3.6*bump)
  ctx.stroke()
  
  // door middle
  ctx.beginPath()
  ctx.moveTo(x+W-3*W/8-dw,y+H-1.76*bump)
  ctx.lineTo(x+W-3*W/8-dw,y+H-dw*3-1.76*bump)
  ctx.lineTo(x+W-3*W/8+dw,y+H-dw*3-2.25*bump)
  ctx.lineTo(x+W-3*W/8+dw,y+H-2.25*bump)
  ctx.stroke()

  // door left
  ctx.beginPath()
  ctx.moveTo(x+W-5*W/8-dw, y+H-bump/2)
  ctx.lineTo(x+W-5*W/8-dw, y+H-dw*3-bump/2)
  ctx.lineTo(x+W-5*W/8+dw, y+H-dw*3-bump)
  ctx.lineTo(x+W-5*W/8+dw, y+H-bump)
  ctx.stroke()

  ctx.beginPath()
  ctx.moveTo(x, y+H/4)
  ctx.lineTo(x+W/4, y+H/4)
  ctx.stroke()
}

function skullAt (x,y,W,color,n) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, points = []
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "butt"
  ctx.lineJoin = "round"
  let x0 = x, y0 = y
  let p = W/30
  let divs = randomPick([7,9])
  let r = W/3
  // top
  ctx.beginPath()
  ctx.arc(x+W/2, y+r, r+pet(p), Math.PI *0.8, Math.PI*2.2)
  
  // bottom jaw
  ctx.arc(x+W/2, y+H-r*0.9, r*0.8+pet(p), Math.PI *0.1, Math.PI*0.9)
  ctx.closePath()
  ctx.stroke()
  
  // mouth
  ctx.beginPath()
  ctx.arc(x+W/2, y+H-r*1.36, r*0.8, Math.PI *0.2, Math.PI*0.8)
  ctx.stroke()
  
  // teeth
  let N = randomPick([8,10,12])
  let th = H/20
  let a = (Math.PI * 0.6)/N, angle = Math.PI*0.2
  let cx = x+W/2, cy = y+H-r*1.36
  let i = 0
  for (; i < N+1; i++) {
    x = r*0.8 * Math.cos(angle)+cx
    y = r*0.8 * Math.sin(angle)+cy
    ctx.beginPath()
    ctx.moveTo(x, y - th)
points.push(x, y - th)
    ctx.lineTo(x, y + th)
points.push(x, y + th)
    ctx.stroke()
    angle += a
  }
  x = x0, y = y0
  r = W/11
  // eyes
  let r2 = r + pet(p/2)
  ctx.beginPath()
  ctx.arc(x+W/2-r*1.5, y+H/2-r/3, r2, 0, Math.PI*2)
points.push(x+W/2-r*1.5, y+H/2-r/3)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.arc(x+W/2+r*1.5, y+H/2-r/3, r2, 0, Math.PI*2)
points.push(x+W/2+r*1.5, y+H/2-r/3)
  ctx.stroke()
  
  // nose
  ctx.beginPath()
  ctx.moveTo(x+W/2, y+H/2)
points.push(x+W/2, y+H/2)
  ctx.lineTo(x+W/2+r/2, y +H/2+r*1.5)
points.push(x+W/2+r/2, y +H/2+r*1.5)
  ctx.lineTo(x+W/2-r/2, y +H/2+r*1.5)
points.push(x+W/2-r/2, y +H/2+r*1.5)
  ctx.closePath()
  ctx.stroke()
  drawStars(x,y,W,points, 0.5)
}

function prayer () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width
  let color = randomPick(getCurrentPalette())
  let pad = 40
  prayerAt (pad,pad,W-pad*2,color)
}

function prayerArray () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let N = randomPick([4,5,6,9,13])
  let pad = 40
  let delta = Math.round(W/N) - pad*1
  let colors = getCurrentPalette(13,true)
  let x = pad/2, y = pad/2, i = 0
  let cnt = 0
  for (; i < N*N; i++) {
    if (i % 2 === 0)
      thoughtAt (x,y,delta,randomPick (colors))
    else
      prayerAt (x,y,delta,randomPick (colors))
    x += delta+pad
    cnt++
    if (cnt > 1 && cnt%N === 0) {
      x = pad/2
      y += delta+pad
    }
  }
}

function prayerAt (x,y,W,color,n) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "butt"
  ctx.lineJoin = "round"
  let x0 = x, y0 = y
  let divs = randomPick([7,9,11])
  let cx = x + W/2 + W/20, cy = y + H/2 - H/18
  
  // hand
  let r = H*0.25, xo = r/10
  ctx.beginPath()
  ctx.arc(x+W/2, y+W-r, r, 0, Math.PI)
  ctx.lineTo(x+W/2 - r, y+H/2)
  ctx.stroke()
  
  x += W/2-r+xo*2
  ctx.arc(x, y+H/2, xo*2, Math.PI, Math.PI*2) // thumb
  x += xo*2
  ctx.lineTo(x, y+H/2 + H/8)
  ctx.lineTo(x, y+H/5)
  x += xo*2
  ctx.arc(x, y+H/5, xo*2, Math.PI, Math.PI*2) // index
  
  x += xo*2
  ctx.lineTo(x, y+H/2)
  ctx.lineTo(x, y+H/7)
  x += xo*2
  ctx.arc(x, y+H/7, xo*2, Math.PI, Math.PI*2) // middle

  x += xo*2
  ctx.lineTo(x, y+H/2)
  ctx.lineTo(x, y+H/5.5)
  x += xo*2
  ctx.arc(x, y+H/5.5, xo*2, Math.PI, Math.PI*2) // ring
  
  x += xo*2
  ctx.lineTo(x, y+H/2 + H/20)
  ctx.lineTo(x, y+H/3)
  x += xo*2
  ctx.arc(x, y+H/3, xo*2, Math.PI, Math.PI*2) // pinkey
  x += xo*2
  y = y0
  ctx.lineTo(x, y+W-r)
  ctx.stroke()
  
  // second hand (left rear)
  //ctx.strokeStyle = "#0000ff"
  x = x0 - xo*2, y = y0 - xo*2
  ctx.beginPath()
  ctx.arc(x+W/2, y+W-r, r, Math.PI * 0.7, Math.PI)
  ctx.lineTo(x+W/2 - r, y+H/2)
  
  x += W/2-r+xo*2
  ctx.arc(x, y+H/2, xo*2, Math.PI, Math.PI*2) // thumb
  ctx.stroke()
  x += xo*2
  x += xo*2
  ctx.arc(x, y+H/5, xo*2, Math.PI, Math.PI*2) // index
  x += xo*4
  ctx.arc(x, y+H/7, xo*2, Math.PI, Math.PI*2) // middle
  x += xo*4
  ctx.stroke()
  ctx.beginPath()
  ctx.arc(x, y+H/5.5, xo*2, Math.PI*1.25, Math.PI*2) // ring
  ctx.stroke()
  
  x += xo*4
  ctx.stroke()
  ctx.beginPath()
  ctx.arc(x, y+H/3, xo*2, Math.PI*1.5, Math.PI*2) // pinkey
  ctx.stroke()
}

function birdAt (x,y,W,color,n) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = "#0000ff"
  //ctx.strokeRect(x,y,W,H)
  ctx.strokeStyle = color
  ctx.lineCap = "butt"
  ctx.lineJoin = "round"
  let x0 = x, y0 = y
  let N = n || randomPick([3,4,5,7,9,11]), i = 0
  let sh = H/N
  let xo,yo // offsets
  
  ctx.beginPath()
  ctx.moveTo(x+W/4,y+H/8)
  let cpx1 = x+W/2, cpy1 = y
  let cpx2 = x+W/2, cpy2 = y + H/3
  ctx.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x+W/2,y+(H-(H/5))/2)
  
  cpx1 = x+W/2, cpy1 = y + H/2
  cpx2 = x+W/2, cpy2 = y + 3*H/4
  ctx.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x+W,y+4*H/5)
  ctx.lineTo(x+3*W/4,y+H)
  ctx.stroke()
 
  // right slide
  ctx.beginPath()
  ctx.moveTo(x+W/4,y+H/8)
  cpx1 = x+3*W/4, cpy1 = y- H/10
  cpx2 = x+3*W/4, cpy2 = y + H/3
  ctx.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x+3*W/4,y+(H-(H/5))/2)
  
  cpx1 = x+3*W/4, cpy1 = y + H/2
  cpx2 = x+3*W/4, cpy2 = y + 3*H/4
  ctx.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x+W,y+4*H/5)
  ctx.lineTo(x+W,y+H)
  ctx.stroke()
}

function everythingArray () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let N = randomPick([7,9,11,13])
  let functions = shuffle(["gunAt", "skullAt", "prayerAt", "origamiAt", "airplaneAt", "envelopeAt", "sardinesAt", "refractionAt", "firebirdAt", "mothAt",  "spiralAt", "gunAt", "elephantAt", "coreAt", "orbitAt", "lensAt", "pythagAt", "floppyAt", "spiderAt", "shoesAt", "mushroomAt", "catAt", "birbAt",
  "pantsAt", "tvAt", "drAt", "fishAt", "cactusAt", "umbrellaAt", "flameAt",
  "appleAt", "bridgeAt", "bugAt", "mailboxAt", "rowhousesAt", "jumpropeAt",
  "pointhouseAt", "breadAt", "flathouseAt", "flatchairAt", "birdhouseAt", "factoryAt",
  "dashedAt", "phaseAt", "leafAt", "allAt", "thenAt", "existAt", "tildeAt", "userAt",
  "heartAt", "glassAt", "prayerAt", "thoughtAt", "skullAt", "lampAt", "chairAt",
  "stairsAt", "treeAt", "slideAt", "ladderAt", "swingAt"])
  let pad = 50
  let delta = Math.round(W/N) - pad*1
  let colors = getCurrentPalette()
  let x = pad/2, y = pad/2, i = 0
  let cnt = 0, f
  for (; i < N*N; i++) {
    f = randomPick(functions)
    window[randomPick(functions)](x,y,delta,randomPick (colors))
    x += delta+pad
    cnt++
    if (cnt > 1 && cnt%N === 0) {
      x = pad/2
      y += delta+pad
    }
  }
}

function airplaneAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"

  ctx.beginPath()
  ctx.moveTo(x+5*W/10, y+10*H/10)
  points.push(x+5*W/10, y+10*H/10)
  ctx.lineTo(x+5*W/10, y+0*H/10)
  points.push(x+5*W/10, y+0*H/10)
  ctx.lineTo(x+10*W/10, y+4*H/10)
  points.push(x+10*W/10, y+4*H/10)
  ctx.lineTo(x+10*W/10, y+10*H/10)
  points.push(x+10*W/10, y+10*H/10)
  ctx.lineTo(x+0*W/10, y+10*H/10)
  points.push(x+0*W/10, y+10*H/10)
  ctx.lineTo(x+0*W/10, y+4*H/10)
  points.push(x+0*W/10, y+4*H/10)
  ctx.lineTo(x+5*W/10, y+0*H/10)
  points.push(x+5*W/10, y+0*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+0*W/10, y+4*H/10)
  points.push(x+0*W/10, y+4*H/10)
  ctx.lineTo(x+10*W/10, y+4*H/10)
  points.push(x+10*W/10, y+4*H/10)
  ctx.stroke()
  
  ctx.setLineDash([W/30, W/30])
  
  ctx.beginPath()
  ctx.moveTo(x+0*W/10, y+8*H/10)
  points.push(x+0*W/10, y+8*H/10)
  ctx.lineTo(x+5*W/10, y+0*H/10)
  points.push(x+5*W/10, y+0*H/10)
  ctx.lineTo(x+10*W/10, y+8*H/10)
  points.push(x+10*W/10, y+8*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+9*W/10, y+4*H/10)
  points.push(x+9*W/10, y+4*H/10)
  cpx = x+6*W/10
  cpy = y+3*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+6*H/10)
  points.push(x+6*W/10, y+6*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+1*W/10, y+4*H/10)
  points.push(x+1*W/10, y+4*H/10)
  cpx = x+4*W/10
  cpy = y+3*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/10, y+6*H/10)
  points.push(x+4*W/10, y+6*H/10)
  ctx.stroke()
  ctx.setLineDash ([])
  
  ctx.beginPath()
  ctx.moveTo(x+3.5*W/10, y+5.5*H/10)
  ctx.lineTo(x+4*W/10, y+6*H/10)
  ctx.lineTo(x+4.5*W/10, y+5.5*H/10)
  
  points.push(x+3.5*W/10, y+5.5*H/10)
  points.push(x+4.5*W/10, y+5.5*H/10)
  ctx.stroke()

  ctx.beginPath()
  ctx.moveTo(x+5.5*W/10, y+5.5*H/10)
  ctx.lineTo(x+6*W/10, y+6*H/10)
  ctx.lineTo(x+6.5*W/10, y+5.5*H/10)
  
  points.push(x+5.5*W/10, y+5.5*H/10)
  points.push(x+6.5*W/10, y+5.5*H/10)
  ctx.stroke()
  
  drawStars(x,y,W,points)
}

function envelopeAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.lineJoin = "bevel"

  ctx.beginPath()
  ctx.moveTo(x+0*W/10, y+10*H/10)
  points.push(x+0*W/10, y+10*H/10)
  ctx.lineTo(x+10*W/10, y+10*H/10)
  points.push(x+10*W/10, y+10*H/10)
  ctx.lineTo(x+10*W/10, y+4*H/10)
  points.push(x+10*W/10, y+4*H/10)
  ctx.lineTo(x+5*W/10, y+0*H/10)
  points.push(x+5*W/10, y+0*H/10)
  ctx.lineTo(x+0*W/10, y+4*H/10)
  points.push(x+0*W/10, y+4*H/10)
  ctx.lineTo(x+0*W/10, y+10*H/10)
  points.push(x+0*W/10, y+10*H/10)
  ctx.lineTo(x+5*W/10, y+7*H/10)
  points.push(x+5*W/10, y+7*H/10)
  ctx.lineTo(x+0*W/10, y+4*H/10)
  points.push(x+0*W/10, y+4*H/10)
  ctx.lineTo(x+10*W/10, y+4*H/10)
  points.push(x+10*W/10, y+4*H/10)
  ctx.lineTo(x+5*W/10, y+7*H/10)
  points.push(x+5*W/10, y+7*H/10)
  ctx.lineTo(x+10*W/10, y+10*H/10)
  points.push(x+10*W/10, y+10*H/10)
  ctx.stroke()

  drawStars(x,y,W,points)
}

function pythagAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+3*W/10, y+10*H/10)
  points.push(x+3*W/10, y+10*H/10)
  ctx.lineTo(x+3*W/10, y+6*H/10)
  points.push(x+3*W/10, y+6*H/10)
  ctx.lineTo(x+7*W/10, y+6*H/10)
  points.push(x+7*W/10, y+6*H/10)
  ctx.lineTo(x+7*W/10, y+10*H/10)
  points.push(x+7*W/10, y+10*H/10)
  ctx.lineTo(x+3*W/10, y+10*H/10)
  points.push(x+3*W/10, y+10*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7*W/10, y+6*H/10)
  points.push(x+7*W/10, y+6*H/10)
  ctx.lineTo(x+9*W/10, y+6*H/10)
  points.push(x+9*W/10, y+6*H/10)
  ctx.lineTo(x+9*W/10, y+4*H/10)
  points.push(x+9*W/10, y+4*H/10)
  ctx.lineTo(x+7*W/10, y+4*H/10)
  points.push(x+7*W/10, y+4*H/10)
  ctx.lineTo(x+7*W/10, y+6*H/10)
  points.push(x+7*W/10, y+6*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+3*W/10, y+6*H/10)
  points.push(x+3*W/10, y+6*H/10)
  ctx.lineTo(x+7*W/10, y+4*H/10)
  points.push(x+7*W/10, y+4*H/10)
  ctx.lineTo(x+5*W/10, y+0*H/10)
  points.push(x+5*W/10, y+0*H/10)
  ctx.lineTo(x+1*W/10, y+2*H/10)
  points.push(x+1*W/10, y+2*H/10)
  ctx.lineTo(x+3*W/10, y+6*H/10)
  points.push(x+3*W/10, y+6*H/10)
  ctx.stroke()
  drawStars(x,y,W,points,0.1)
}

function headAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+1*W/13, y+1*H/13)
  points.push(x+1*W/13, y+1*H/13)
  ctx.lineTo(x+2*W/13, y+2*H/13)
  points.push(x+2*W/13, y+2*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+1*W/13, y+4*H/13)
  points.push(x+1*W/13, y+4*H/13)
  ctx.lineTo(x+2*W/13, y+3*H/13)
  points.push(x+2*W/13, y+3*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+1*W/13, y+2*H/13)
  points.push(x+1*W/13, y+2*H/13)
  ctx.lineTo(x+1*W/13, y+3*H/13)
  points.push(x+1*W/13, y+3*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+3*W/13, y+1*H/13)
  points.push(x+3*W/13, y+1*H/13)
  ctx.lineTo(x+4*W/13, y+0*H/13)
  points.push(x+4*W/13, y+0*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/13, y+4*H/13)
  points.push(x+2*W/13, y+4*H/13)
  ctx.lineTo(x+3*W/13, y+5*H/13)
  points.push(x+3*W/13, y+5*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+3*W/13, y+4*H/13)
  points.push(x+3*W/13, y+4*H/13)
  ctx.lineTo(x+4*W/13, y+3*H/13)
  points.push(x+4*W/13, y+3*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+3*W/13, y+2*H/13)
  points.push(x+3*W/13, y+2*H/13)
  ctx.lineTo(x+4*W/13, y+2*H/13)
  points.push(x+4*W/13, y+2*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/13, y+1*H/13)
  points.push(x+4*W/13, y+1*H/13)
  ctx.lineTo(x+5*W/13, y+2*H/13)
  points.push(x+5*W/13, y+2*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/13, y+1*H/13)
  points.push(x+2*W/13, y+1*H/13)
  ctx.lineTo(x+3*W/13, y+0*H/13)
  points.push(x+3*W/13, y+0*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/13, y+5*H/13)
  points.push(x+2*W/13, y+5*H/13)
  ctx.lineTo(x+1*W/13, y+6*H/13)
  points.push(x+1*W/13, y+6*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+1*W/13, y+5*H/13)
  points.push(x+1*W/13, y+5*H/13)
  ctx.lineTo(x+0*W/13, y+4*H/13)
  points.push(x+0*W/13, y+4*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/13, y+4*H/13)
  points.push(x+4*W/13, y+4*H/13)
  ctx.lineTo(x+5*W/13, y+4*H/13)
  points.push(x+5*W/13, y+4*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/13, y+5*H/13)
  points.push(x+4*W/13, y+5*H/13)
  ctx.lineTo(x+4*W/13, y+6*H/13)
  points.push(x+4*W/13, y+6*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/13, y+3*H/13)
  points.push(x+5*W/13, y+3*H/13)
  ctx.lineTo(x+6*W/13, y+2*H/13)
  points.push(x+6*W/13, y+2*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+1*W/13, y+8*H/13)
  points.push(x+1*W/13, y+8*H/13)
  cpx = x+1*W/13
  cpy = y+1*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/13, y+1*H/13)
  points.push(x+6*W/13, y+1*H/13)
  cpx = x+10*W/13
  cpy = y+1*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/13, y+4*H/13)
  points.push(x+10*W/13, y+4*H/13)
  cpx = x+10*W/13
  cpy = y+6*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/13, y+6*H/13)
  points.push(x+9*W/13, y+6*H/13)
  cpx = x+10*W/13
  cpy = y+8*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+11*W/13, y+8*H/13)
  points.push(x+11*W/13, y+8*H/13)
  cpx = x+10*W/13
  cpy = y+8*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/13, y+8*H/13)
  points.push(x+10*W/13, y+8*H/13)
  cpx = x+9*W/13
  cpy = y+8*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/13, y+9*H/13)
  points.push(x+9*W/13, y+9*H/13)
  cpx = x+9*W/13
  cpy = y+10*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/13, y+10*H/13)
  points.push(x+8*W/13, y+10*H/13)
  cpx = x+9*W/13
  cpy = y+10*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/13, y+11*H/13)
  points.push(x+9*W/13, y+11*H/13)
  cpx = x+9*W/13
  cpy = y+13*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/13, y+13*H/13)
  points.push(x+6*W/13, y+13*H/13)
  cpx = x+3*W/13
  cpy = y+13*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/13, y+13*H/13)
  points.push(x+3*W/13, y+13*H/13)
  cpx = x+1*W/13
  cpy = y+13*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/13, y+8*H/13)
  points.push(x+1*W/13, y+8*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/13, y+6*H/13)
  points.push(x+2*W/13, y+6*H/13)
  cpx = x+3*W/13
  cpy = y+7*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/13, y+7*H/13)
  points.push(x+3*W/13, y+7*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7*W/13, y+1*H/13)
  points.push(x+7*W/13, y+1*H/13)
  ctx.lineTo(x+8*W/13, y+0*H/13)
  points.push(x+8*W/13, y+0*H/13)
  ctx.lineTo(x+6*W/13, y+1*H/13)
  points.push(x+6*W/13, y+1*H/13)
  ctx.lineTo(x+5*W/13, y+0*H/13)
  points.push(x+5*W/13, y+0*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7*W/13, y+2*H/13)
  points.push(x+7*W/13, y+2*H/13)
  ctx.lineTo(x+8*W/13, y+2*H/13)
  points.push(x+8*W/13, y+2*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+8*W/13, y+1*H/13)
  points.push(x+8*W/13, y+1*H/13)
  ctx.lineTo(x+9*W/13, y+1*H/13)
  points.push(x+9*W/13, y+1*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/13, y+3*H/13)
  points.push(x+6*W/13, y+3*H/13)
  ctx.lineTo(x+7*W/13, y+4*H/13)
  points.push(x+7*W/13, y+4*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/13, y+7*H/13)
  points.push(x+2*W/13, y+7*H/13)
  ctx.lineTo(x+1*W/13, y+7*H/13)
  points.push(x+1*W/13, y+7*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+1*W/13, y+8*H/13)
  points.push(x+1*W/13, y+8*H/13)
  ctx.lineTo(x+0*W/13, y+8*H/13)
  points.push(x+0*W/13, y+8*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/13, y+5*H/13)
  points.push(x+5*W/13, y+5*H/13)
  ctx.lineTo(x+6*W/13, y+4*H/13)
  points.push(x+6*W/13, y+4*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/13, y+8*H/13)
  points.push(x+2*W/13, y+8*H/13)
  ctx.lineTo(x+2*W/13, y+9*H/13)
  points.push(x+2*W/13, y+9*H/13)
  ctx.lineTo(x+1*W/13, y+9*H/13)
  points.push(x+1*W/13, y+9*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+3*W/13, y+8*H/13)
  points.push(x+3*W/13, y+8*H/13)
  ctx.lineTo(x+4*W/13, y+9*H/13)
  points.push(x+4*W/13, y+9*H/13)
  ctx.lineTo(x+4*W/13, y+7*H/13)
  points.push(x+4*W/13, y+7*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+3*W/13, y+6*H/13)
  points.push(x+3*W/13, y+6*H/13)
  ctx.lineTo(x+4*W/13, y+7*H/13)
  points.push(x+4*W/13, y+7*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+9*W/13, y+6*H/13)
  points.push(x+9*W/13, y+6*H/13)
  cpx = x+9*W/13
  cpy = y+5*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/13, y+5*H/13)
  points.push(x+8*W/13, y+5*H/13)
  cpx = x+7*W/13
  cpy = y+5*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/13, y+6*H/13)
  points.push(x+7*W/13, y+6*H/13)
  cpx = x+8*W/13
  cpy = y+7*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/13, y+6*H/13)
  points.push(x+9*W/13, y+6*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+8*W/13, y+10*H/13)
  points.push(x+8*W/13, y+10*H/13)
  cpx = x+6*W/13
  cpy = y+10*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/13, y+9*H/13)
  points.push(x+6*W/13, y+9*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/13, y+13*H/13)
  points.push(x+6*W/13, y+13*H/13)
  cpx = x+3*W/13
  cpy = y+13*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/13, y+12*H/13)
  points.push(x+2*W/13, y+12*H/13)
  cpx = x+2*W/13
  cpy = y+0*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/13, y+3*H/13)
  points.push(x+2*W/13, y+3*H/13)
  cpx = x+6*W/13
  cpy = y+6*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/13, y+5*H/13)
  points.push(x+6*W/13, y+5*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/13, y+6*H/13)
  points.push(x+6*W/13, y+6*H/13)
  cpx = x+6*W/13
  cpy = y+5*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/13, y+5*H/13)
  points.push(x+5*W/13, y+5*H/13)
  cpx = x+4*W/13
  cpy = y+5*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/13, y+6*H/13)
  points.push(x+4*W/13, y+6*H/13)
  cpx = x+5*W/13
  cpy = y+7*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/13, y+6*H/13)
  points.push(x+6*W/13, y+6*H/13)
  ctx.stroke()
  drawStars(x,y,W,points)
}

function socialnetwork () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let colors = ["#f6c2d9","#fff69b","#bcdfc9","#a1c8e9","#e4dae2"]
  let linecolors = getCurrentPalette()
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.shadowBlur = 10
  ctx.shadowColor = "#444444"
  ctx.shadowOffsetX = (Math.random()-0.5) * 8
  ctx.shadowOffsetY  = (Math.random()-0.5) * 8
  let N = randomPick([9,11,13])
  let pad = 24, delta = W/(N-3), x = 0, y = 0, cpx, cpy
  let cx = W/2-delta/2, cy = H/2-delta/2, R = W/2.9
  let i = 0, points = []
  let pinned = []
  let angle = 2*Math.PI * Math.random(), inc = Math.PI*2/N
  x = delta/3 + pet(pad*2), y = delta/3 + pet(pad*2)
  x = cx, y = cy
  for (; i < N+1; i++) {
    points.push([x,y])
    ctx.shadowBlur = 3
    ctx.shadowOffsetX = 2
    ctx.shadowOffsetY = 3
    ctx.fillStyle = randomPick(colors)
    
    let spin = pet(8)
    ctx.beginPath()
    ctx.moveTo(x-pad+spin,y-pad-spin)
    ctx.lineTo(x+delta+pad+spin, y-pad+spin)
    ctx.lineTo(x+delta+pad-spin, y+delta+pad+spin)
    ctx.lineTo(x-pad-spin, y+delta+pad-spin)
    ctx.lineTo(x-pad+spin, y+pad-spin)
    ctx.fill()
    ctx.shadowBlur = 0
    ctx.shadowOffsetX = 0
    ctx.shadowOffsetY = 0
    user2At(x,y,delta,randomPick (linecolors))
    if (i > 4) {
      ctx.shadowBlur = 3
      ctx.shadowOffsetX = 0
      ctx.shadowOffsetY = 8
      pinned = connectPoints(points, ctx, delta, pad, pinned)
    }
    x = (R+pet(pad*3)) * Math.cos(angle)+cx;
    y = (R+pet(pad*3)) * Math.sin(angle)+cy;
    if (x > W -delta) {
      y += delta*1.4 +pet(pad*2)
      x = delta/3 +pet(pad)
    }
    angle += inc
  }
}

function aconst () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let colors = ["#f6c2d9","#fff69b","#bcdfc9","#a1c8e9","#e4dae2"]
  let linecolors = getCurrentPalette()
  let functions = shuffle(["origamiAt", "airplaneAt", "envelopeAt", "sardinesAt", "refractionAt", "firebirdAt", "spiralAt", "gunAt", "elephantAt", "coreAt",
  "orbitAt", "lensAt", "pythagAt", "user2At", "mothAt",
  "floppyAt", "spiderAt", "factoryAt", "shoesAt", "umbrellaAt", "flathouseAt",
  "slideAt", "tvAt", "cactusAt", "flatchairAt", "skullAt",
  "bugAt", "stairsAt", "birdhouseAt"])
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let N = 12
  let pad = 24, delta = W/(N-5), x = 0, y = 0, cpx, cpy
  let cx = W, cy = H, R = W/2.6
  let i = 0, points = []
  let pinned = []
  let angle = 0, inc = Math.PI*2/N
  x = delta/3 + pet(pad*2), y = delta/3 + pet(pad*2)
  x = cx, y = cy
  checkAlt(true)
  points.push([x,y])
  x = W*0.25//(R) * Math.cos(angle)+cx
  y = H*0.25//(R) * Math.sin(angle)+cy
  f = functions[i % functions.length]
  window[f](x,y,W*0.5,randomPick (linecolors))

  checkAlt(false)
  // draw divisions/houses
  R = W*2
  cx = -R/10
  if (Math.random() > 0.5)
    cx = W+R/10
  cy = H+R/2.6
  ctx.strokeStyle = randomPick(linecolors)
 // ctx.lineWidth = 6
  ctx.beginPath()
  ctx.arc(cx,cy,R,0,Math.PI*2)
  ctx.stroke()
  ctx.beginPath()
  ctx.arc(cx,cy,R/2,0,Math.PI*2)
  ctx.stroke()
  i = 0, angle = 0 + Math.PI/12
  let x2, y2
  for (; i < N; i++) {
    x = (R) * Math.cos(angle)+cx
    y = (R) * Math.sin(angle)+cy
    x2 = (R/2) * Math.cos(angle)+cx
    y2 = (R/2) * Math.sin(angle)+cy
    ctx.beginPath()
    ctx.moveTo(x2,y2)
    ctx.lineTo(x,y)
    ctx.stroke()
    angle += inc
  }
  // ticks
  i = 0, angle = 0 + Math.PI/12
  inc = Math.PI*2 / 360, N = 360
  let d = 32
  for (; i < N; i++) {
    d = W*0.05
    if (i % 2 === 0)
      d = W*0.1
    x = (R) * Math.cos(angle)+cx
    y = (R) * Math.sin(angle)+cy
    x2 = (R-d) * Math.cos(angle)+cx
    y2 = (R-d) * Math.sin(angle)+cy
    ctx.beginPath()
    ctx.moveTo(x2,y2)
    ctx.lineTo(x,y)
    ctx.stroke()
    angle += inc
  }
  
  
  let angles = []
  let planets = shuffle(["\u2646", "\u2645", "\u2640","\u263F","\u2642", "\u2643", "\u2644", "\u2609", "\u263D"])
  ctx.font = "48pt serif"
  ctx.fillStyle = randomPick(linecolors)
  x = (cx > W)? W - 120: 120;
  y = H-100
  ctx.fillText(planets[0],x-18,y+18)
}

function natal () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let colors = ["#f6c2d9","#fff69b","#bcdfc9","#a1c8e9","#e4dae2"]
  let linecolors = getCurrentPalette()
  let functions = shuffle(["origamiAt", "airplaneAt", "envelopeAt", "sardinesAt", "refractionAt","mothAt", "firebirdAt", "spiralAt", "gunAt", "elephantAt", "coreAt", "orbitAt", "lensAt", "pythagAt",
  "floppyAt", "spiderAt", "factoryAt", "shoesAt", "umbrellaAt", "flathouseAt",
  "slideAt", "tvAt", "cactusAt", "flatchairAt", "skullAt",
  "bugAt", "stairsAt", "birdhouseAt"])
  ctx.globalAlpha = document.getElementById("opacity").value/100

  let N = 12
  let pad = 24, delta = W/(N-5), x = 0, y = 0, cpx, cpy
  let cx = W/2-delta/2, cy = H/2-delta/2, R = W/2.6
  let i = 0, points = []
  let pinned = []
  let angle = 0, inc = Math.PI*2/N
  x = delta/3 + pet(pad*2), y = delta/3 + pet(pad*2)
  x = cx, y = cy
  checkAlt(true)
  for (; i < N; i++) {
    points.push([x,y])
    x = (R) * Math.cos(angle)+cx
    y = (R) * Math.sin(angle)+cy
    f = functions[i % functions.length]
    window[f](x,y,delta,randomPick (linecolors))
    if (x > W -delta) {
      y += delta*1.4
      x = delta/3
    }
    angle += inc
  }
  checkAlt(false)
  // draw divisions/houses
  R = W*0.49
  cx = W/2, cy = H/2
  ctx.strokeStyle = randomPick(linecolors)
  ctx.beginPath()
  ctx.arc(cx,cy,R,0,Math.PI*2)
  ctx.stroke()
  ctx.beginPath()
  ctx.arc(cx,cy,R/2,0,Math.PI*2)
  ctx.stroke()
  i = 0, angle = Math.PI/12
  let x2, y2
  for (; i < N; i++) {
    x = (R) * Math.cos(angle)+cx
    y = (R) * Math.sin(angle)+cy
    x2 = (R/2) * Math.cos(angle)+cx
    y2 = (R/2) * Math.sin(angle)+cy
    ctx.beginPath()
    ctx.moveTo(x2,y2)
    ctx.lineTo(x,y)
    ctx.stroke()
    angle += inc
  }
  // ticks
  i = 0, angle = Math.PI/12, R = W*0.49
  inc = Math.PI*2 / 180, N = 180
  let d = 32
  for (; i < N; i++) {
    d = W*0.01
    if (i % 2 === 0)
      d = W*0.02
    x = (R) * Math.cos(angle)+cx
    y = (R) * Math.sin(angle)+cy
    x2 = (R-d) * Math.cos(angle)+cx
    y2 = (R-d) * Math.sin(angle)+cy
    ctx.beginPath()
    ctx.moveTo(x2,y2)
    ctx.lineTo(x,y)
    ctx.stroke()
    angle += inc
  }
  
  let angles = []
  let planets = shuffle(["\u2646", "\u2645", "\u2640","\u263F","\u2642", "\u2643", "\u2644", "\u2609", "\u263D"])
  ctx.font = "32pt serif"
  ctx.fillStyle = randomPick(linecolors)
  i = 0, R = W/4.6
  for (; i < planets.length; i++) {
    angle = Math.random() * Math.PI*2
    angles.push(angle)
    x = (R) * Math.cos(angle)+cx
    y = (R) * Math.sin(angle)+cy
    //R *= 0.95
    ctx.fillText(planets[i],x-18,y+18)
  }
  let j = 0
  i = 0, R = W/5.5
  ctx.strokeStyle = randomPick(linecolors)
  for (; i < angles.length; i++) {
    j = i+1
    for (; j < angles.length; j++) {
      x = (R) * Math.cos(angles[i])+cx
      y = (R) * Math.sin(angles[i])+cy
      x2 = (R) * Math.cos(angles[j])+cx
      y2 = (R) * Math.sin(angles[j])+cy
      ctx.beginPath()
      ctx.moveTo(x2,y2)
      ctx.lineTo(x,y)
      ctx.stroke()
    }
  }
}

function crazywall () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let colors = ["#f6c2d9","#fff69b","#bcdfc9","#a1c8e9","#e4dae2"]
  let linecolors = getCurrentPalette()
  let functions = shuffle(["origamiAt", "airplaneAt", "envelopeAt", "sardinesAt", "refractionAt", "mothAt", "firebirdAt", "spiralAt", "gunAt", "elephantAt", "coreAt", "orbitAt", "lensAt", "pythagAt", "floppyAt", "spiderAt", "shoesAt", "mushroomAt", "catAt", "birbAt",
   "pantsAt", "tvAt", "drAt", "fishAt", "cactusAt", "umbrellaAt", "flameAt",
    "appleAt", "bridgeAt", "bugAt", "mailboxAt", "jumpropeAt", "pointhouseAt", "breadAt",
    "flathouseAt", "flatchairAt", "birdhouseAt", "factoryAt", "dashedAt", "phaseAt",
    "leafAt", "allAt", "thenAt", "existAt", "tildeAt", "userAt", "heartAt", "glassAt", "prayerAt", "thoughtAt", "skullAt", "lampAt", "chairAt",
  "stairsAt", "treeAt", "slideAt", "ladderAt", "swingAt"])
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.shadowBlur = 10
  ctx.shadowColor = "#444444"
  ctx.shadowOffsetX = (Math.random()-0.5) * 8
  ctx.shadowOffsetY  = (Math.random()-0.5) * 8
  let pad = 24, delta = W/6, x = 0, y = 0, cpx, cpy
  let cx = W/2-delta/2, cy = H/2-delta/2, R = W/2.9
  let i = 0, points = []
  let pinned = [], N = 11
  let angle = 2*Math.PI * Math.random(), inc = Math.PI*2/N
  x = delta/3 +pet(pad*2), y = delta/3 + pet(pad*2)
  for (; i < N+1; i++) {
    points.push([x,y])
    ctx.shadowBlur = 3
    ctx.shadowOffsetX = 2
    ctx.shadowOffsetY = 3
    ctx.fillStyle = randomPick(colors)
    
    let spin = pet(8)
    ctx.beginPath()
    ctx.moveTo(x-pad+spin,y-pad-spin)
    ctx.lineTo(x+delta+pad+spin, y-pad+spin)
    ctx.lineTo(x+delta+pad-spin, y+delta+pad+spin)
    ctx.lineTo(x-pad-spin, y+delta+pad-spin)
    ctx.lineTo(x-pad+spin, y+pad-spin)
    ctx.fill()
    ctx.shadowBlur = 0
    ctx.shadowOffsetX = 0
    ctx.shadowOffsetY = 0
    f = randomPick(functions)
    window[functions[i]](x,y,delta,randomPick (linecolors))
    if (i > 4) {
      ctx.shadowBlur = 3
      ctx.shadowOffsetX = 0
      ctx.shadowOffsetY = 8
      pinned = connectPoints(points, ctx, delta, pad, pinned)
    }
    //x = (R+pet(pad*3)) * Math.cos(angle)+cx;
    //y = (R+pet(pad*3)) * Math.sin(angle)+cy;
    x += delta*2 + pet(pad*2)
    y += pet(pad)
    if (x > W -delta) {
      y += delta*1.4 +pet(pad*2)
      x = delta/3 +pet(pad)
    }
    angle += inc
  }
}

function connectPoints (points, ctx, delta, pad, pinned) {
  let cpx = 0, cpy = 0
  let colors = ["#ee0000", "#c28a5d"]
  let x = points[points.length - 1][0]
  let y = points[points.length - 1][1]
  let i = 0//Math.floor(points.length/3) // don't go too far back to covered post-its
  for (; i < points.length-1 ; i++) {
    cpx = Math.min(x+delta/2, points[i][0]+delta/2) + Math.abs(x-points[i][0])/2
    cpy = Math.min(y, points[i][1]) + Math.abs(y-points[i][1])/1.2
    if (Math.random() > 0.73) {
      ctx.strokeStyle = randomPick(colors)
      ctx.lineWidth = randomPick([2,2,3])
      ctx.beginPath()
      ctx.moveTo(x+delta/2, y)
      //ctx.lineTo(points[i][0]+delta/2, points[i][1])
      ctx.quadraticCurveTo(cpx, cpy, points[i][0]+delta/2, points[i][1])
      ctx.lineTo(points[i][0]+delta/2+pet(11), 11 + points[i][1]+Math.random()*80)
      ctx.stroke()
      // pin
      if (!pinned.includes(i)) {
        pinned.push(i)
      }
      if (!pinned.includes(points.length-1)) {
        pinned.push(points.length-1)
      }
    }
  }
  i = 0
  for (; i < points.length; i++) {
    if (pinned.includes(i)) {
      ctx.fillStyle = randomPick(["#dd0000", "#00aa00", "#0000dd"])
      ctx.shadowColor = "#666666"
      ctx.shadowBlur = 2
      ctx.shadowOffsetX = 0
      ctx.shadowOffsetY = 4
      let x2 = points[i][0] +delta/2, y2 = points[i][1]
      ctx.beginPath()
      ctx.arc(x2, y2, delta/19, 0, Math.PI*2)
      ctx.closePath()
      ctx.fill()
      pinned.push(i)
    }
  }
  ctx.shadowBlur = 0
  ctx.shadowOffsetX = 0
  ctx.shadowOffsetY = 0
  return pinned
}

function user2At (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+12*H/12)
  points.push(x+0*W/12, y+12*H/12)
  ctx.lineTo(x+0*W/12, y+8*H/12)
  points.push(x+0*W/12, y+8*H/12)
  cpx = x+0*W/12
  cpy = y+6*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+6*H/12)
  points.push(x+2*W/12, y+6*H/12)
  cpx = x+4*W/12
  cpy = y+6*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+4*H/12)
  points.push(x+4*W/12, y+4*H/12)
  ctx.lineTo(x+4*W/12, y+2*H/12)
  points.push(x+4*W/12, y+2*H/12)
  cpx = x+4*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+0*H/12)
  points.push(x+6*W/12, y+0*H/12)
  cpx = x+8*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+2*H/12)
  points.push(x+8*W/12, y+2*H/12)
  ctx.lineTo(x+8*W/12, y+4*H/12)
  points.push(x+8*W/12, y+4*H/12)
  cpx = x+8*W/12
  cpy = y+6*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+6*H/12)
  points.push(x+10*W/12, y+6*H/12)
  cpx = x+12*W/12
  cpy = y+6*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+8*H/12)
  points.push(x+12*W/12, y+8*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+12*W/12, y+8*H/12)
  points.push(x+12*W/12, y+8*H/12)
  ctx.lineTo(x+12*W/12, y+12*H/12)
  points.push(x+12*W/12, y+12*H/12)
  ctx.stroke()
  drawStars(x,y,W,points)
  
  // features
  // 00 eyes
  ctx.beginPath()
  ctx.moveTo(x+4*W/12, y+3*H/12)
  points.push(x+4*W/12, y+3*H/12)
  cpx = x+5*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+3*H/12)
  points.push(x+6*W/12, y+3*H/12)
  cpx = x+7*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+3*H/12)
  points.push(x+8*W/12, y+3*H/12)
  cpx = x+7*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+3*H/12)
  points.push(x+6*W/12, y+3*H/12)
  cpx = x+5*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+3*H/12)
  if (Math.random() > 0.8) {
    points.push(x+4*W/12, y+3*H/12)
    ctx.stroke()
  }
  // ears
  if (Math.random() > 0.8) {
    ctx.beginPath()
    ctx.moveTo(x+4*W/12, y+4*H/12)
    points.push(x+4*W/12, y+4*H/12)
    cpx = x+3*W/12
    cpy = y+4*H/12
    ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+3*H/12)
    points.push(x+3*W/12, y+4*H/12)
    cpx = x+3*W/12
    cpy = y+2*H/12
    ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+3*H/12)
    points.push(x+4*W/12, y+3*H/12)
    ctx.stroke()
    ctx.beginPath()
    ctx.moveTo(x+8*W/12, y+4*H/12)
    points.push(x+8*W/12, y+4*H/12)
    cpx = x+9*W/12
    cpy = y+4*H/12
    ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+3*H/12)
    points.push(x+9*W/12, y+3*H/12)
    cpx = x+9*W/12
    cpy = y+2*H/12
    ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+3*H/12)
    points.push(x+8*W/12, y+3*H/12)
    ctx.stroke()
  }
  //hair flip
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+0*H/12)
  points.push(x+6*W/12, y+0*H/12)
  cpx = x+3*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+2*H/12)
  points.push(x+3*W/12, y+2*H/12)
  cpx = x+3*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/12, y+5*H/12)
  points.push(x+1*W/12, y+5*H/12)
  cpx = x+4*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+2*H/12)
  points.push(x+4*W/12, y+2*H/12)
  cpx = x+4*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+0*H/12)
  points.push(x+6*W/12, y+0*H/12)
  cpx = x+9*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+2*H/12)
  points.push(x+9*W/12, y+2*H/12)
  cpx = x+9*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+11*W/12, y+5*H/12)
  points.push(x+11*W/12, y+5*H/12)
  cpx = x+8*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+2*H/12)
  points.push(x+8*W/12, y+2*H/12)
  cpx = x+8*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+0*H/12)
  if (Math.random() > 0.8) {
    points.push(x+6*W/12, y+0*H/12)
    ctx.stroke()
  }
  
  // square face lines
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+2*H/12)
  points.push(x+5*W/12, y+2*H/12)
  ctx.lineTo(x+6*W/12, y+2*H/12)
  points.push(x+6*W/12, y+2*H/12)
  ctx.lineTo(x+6*W/12, y+4*H/12)
  points.push(x+6*W/12, y+4*H/12)
  if (Math.random() > 0.8)
    ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+5*H/12)
  points.push(x+5*W/12, y+5*H/12)
  ctx.lineTo(x+6*W/12, y+4*H/12)
  points.push(x+6*W/12, y+4*H/12)
  ctx.lineTo(x+7*W/12, y+5*H/12)
  points.push(x+7*W/12, y+5*H/12)
  if (Math.random() > 0.8)
    ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+3*W/12, y+2*H/12)
  points.push(x+3*W/12, y+2*H/12)
  ctx.lineTo(x+9*W/12, y+2*H/12)
  if (Math.random() > 0.8) {
    points.push(x+9*W/12, y+2*H/12)
    ctx.stroke()
  }
  ctx.beginPath() // beard
  ctx.moveTo(x+4*W/12, y+4*H/12)
  points.push(x+4*W/12, y+4*H/12)
  cpx = x+4*W/12
  cpy = y+6*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+7*H/12)
  points.push(x+6*W/12, y+7*H/12)
  cpx = x+8*W/12
  cpy = y+6*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+4*H/12)
  points.push(x+8*W/12, y+4*H/12)
  ctx.lineTo(x+4*W/12, y+4*H/12)
  if (Math.random() > 0.8) {
    points.push(x+4*W/12, y+4*H/12)
    ctx.stroke()
  }
  
  // shifty eyes
  if (Math.random() > 0.0) {
    ctx.beginPath()
    ctx.moveTo(x+5*W/12, y+3*H/12)
    //points.push(x+5*W/12, y+4*H/12)
    cpx = x+6*W/12
    cpy = y+3*H/12
    ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+3*H/12)
    //points.push(x+5*W/12, y+4*H/12)
    ctx.stroke()
    ctx.beginPath()
    ctx.moveTo(x+7*W/12, y+3*H/12)
   // points.push(x+7*W/12, y+4*H/12)
    cpx = x+8*W/12
    cpy = y+3*H/12
    ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+3*H/12)
    //points.push(x+7*W/12, y+4*H/12)
    ctx.stroke()
  }
  ctx.beginPath() // chin/smile
  ctx.moveTo(x+5*W/12, y+5*H/12)
  points.push(x+5*W/12, y+5*H/12)
  cpx = x+6*W/12
  cpy = y+6*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+5*H/12)
  if (Math.random() > 0.8) {
    points.push(x+7*W/12, y+5*H/12)
    ctx.stroke()
  }

  ctx.beginPath() // pointy nose
  ctx.moveTo(x+5*W/12, y+3*H/12)
  points.push(x+5*W/12, y+3*H/12)
  cpx = x+6*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+4*H/12)
  points.push(x+6*W/12, y+4*H/12)
  cpx = x+6*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+3*H/12)
  if (Math.random() > 0.8) {
    ctx.stroke()
  }
  ctx.beginPath() // frown
  ctx.moveTo(x+5*W/12, y+5*H/12)
  points.push(x+5*W/12, y+5*H/12)
  cpx = x+6*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+5*H/12)
  if (Math.random() > 0.8) {
    ctx.stroke()
  }
  
  if (Math.random() > 0.9) {
    ctx.beginPath()
    ctx.moveTo(x+4*W/12, y+1*H/12)
    points.push(x+4*W/12, y+1*H/12)
    ctx.lineTo(x+3*W/12, y+0*H/12)
    points.push(x+3*W/12, y+0*H/12)
    ctx.stroke()
    ctx.beginPath()
    ctx.moveTo(x+8*W/12, y+1*H/12)
    points.push(x+8*W/12, y+1*H/12)
    ctx.lineTo(x+9*W/12, y+0*H/12)
    points.push(x+9*W/12, y+0*H/12)
    ctx.stroke()
    ctx.beginPath()
    ctx.moveTo(x+4*W/12, y+2*H/12)
    points.push(x+4*W/12, y+2*H/12)
    ctx.lineTo(x+3*W/12, y+2*H/12)
    points.push(x+3*W/12, y+2*H/12)
    ctx.stroke()
    ctx.beginPath()
    ctx.moveTo(x+4*W/12, y+3*H/12)
    points.push(x+4*W/12, y+3*H/12)
    ctx.lineTo(x+3*W/12, y+3*H/12)
    points.push(x+3*W/12, y+3*H/12)
    ctx.stroke()
    ctx.beginPath()
    ctx.moveTo(x+4*W/12, y+4*H/12)
    points.push(x+4*W/12, y+4*H/12)
    ctx.lineTo(x+3*W/12, y+5*H/12)
    points.push(x+3*W/12, y+5*H/12)
    ctx.stroke()
    ctx.beginPath()
    ctx.moveTo(x+8*W/12, y+2*H/12)
    points.push(x+8*W/12, y+2*H/12)
    ctx.lineTo(x+9*W/12, y+2*H/12)
    points.push(x+9*W/12, y+2*H/12)
    ctx.stroke()
    ctx.beginPath()
    ctx.moveTo(x+8*W/12, y+3*H/12)
    points.push(x+8*W/12, y+3*H/12)
    ctx.lineTo(x+9*W/12, y+3*H/12)
    points.push(x+9*W/12, y+3*H/12)
    ctx.stroke()
    ctx.beginPath()
    ctx.moveTo(x+8*W/12, y+4*H/12)
    points.push(x+8*W/12, y+4*H/12)
    ctx.lineTo(x+9*W/12, y+5*H/12)
    points.push(x+9*W/12, y+5*H/12)
    ctx.stroke()
  }
  drawStars(x,y,W,points,0.01)
}

function origamiAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"

  ctx.beginPath()
  ctx.moveTo(x+5*W/10, y+10*H/10)
  points.push(x+5*W/10, y+10*H/10)
  ctx.lineTo(x+10*W/10, y+5*H/10)
  points.push(x+10*W/10, y+5*H/10)
  ctx.lineTo(x+5*W/10, y+0*H/10)
  points.push(x+5*W/10, y+0*H/10)
  ctx.lineTo(x+0*W/10, y+5*H/10)
  points.push(x+0*W/10, y+5*H/10)
  ctx.lineTo(x+5*W/10, y+10*H/10)
  points.push(x+5*W/10, y+10*H/10)
  ctx.lineTo(x+5*W/10, y+10*H/10)
  points.push(x+5*W/10, y+10*H/10)
  ctx.lineTo(x+7.8*W/10, y+3.1*H/10)
  points.push(x+7.8*W/10, y+3.1*H/10)
  ctx.lineTo(x+5*W/10, y+3*H/10)
  points.push(x+5*W/10, y+3*H/10)
  ctx.lineTo(x+5*W/10, y+10*H/10)
  points.push(x+5*W/10, y+10*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7.8*W/10, y+3.1*H/10)
  ctx.lineTo(x+5*W/10, y+0*H/10)
  ctx.stroke()
  ctx.setLineDash([W/30,W/30])
  ctx.beginPath()
  ctx.moveTo(x+6*W/10, y+5*H/10)
  points.push(x+6*W/10, y+5*H/10)
  cpx = x+8*W/10
  cpy = y+3*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/10, y+6*H/10)
  points.push(x+8*W/10, y+6*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/10, y+3*H/10)
  points.push(x+5*W/10, y+3*H/10)
  cpx = x+5*W/10
  cpy = y+0*H/10
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/10, y+3*H/10)
  points.push(x+5*W/10, y+3*H/10)
  ctx.lineTo(x+5*W/10, y+0*H/10)
  points.push(x+5*W/10, y+0*H/10)
  ctx.stroke()
  ctx.setLineDash([])
  ctx.beginPath()
  ctx.moveTo(x+5*W/10, y+0*H/10)
  points.push(x+5*W/10, y+0*H/10)
  ctx.lineTo(x+0*W/10, y+4*H/10)
  points.push(x+0*W/10, y+4*H/10)
  ctx.lineTo(x+0.5*W/10, y+4.5*H/10)
  points.push(x+0.5*W/10, y+4.5*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7.5*W/10, y+5.5*H/10)
  ctx.lineTo(x+8*W/10, y+6*H/10)
  ctx.lineTo(x+8.5*W/10, y+5.5*H/10)
  ctx.stroke()
  drawStars(x,y,W,points)
}

function pocket2At (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.lineJoin = "bevel"
  ctx.beginPath()
  ctx.moveTo(x+5*W/10, y+5*H/10)
  points.push(x+5*W/10, y+5*H/10)
  ctx.lineTo(x+2*W/10, y+7*H/10)
  points.push(x+2*W/10, y+7*H/10)
  ctx.lineTo(x+5*W/10, y+10*H/10)
  points.push(x+5*W/10, y+10*H/10)
  ctx.lineTo(x+8*W/10, y+7*H/10)
  points.push(x+8*W/10, y+7*H/10)
  ctx.lineTo(x+5*W/10, y+5*H/10)
  points.push(x+5*W/10, y+5*H/10)
  cpx = x+4*W/10
  cpy = y+7*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+10*H/10)
  points.push(x+5*W/10, y+10*H/10)
  cpx = x+6*W/10
  cpy = y+7*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+5*H/10)
  points.push(x+5*W/10, y+5*H/10)
  ctx.stroke()
  
  ctx.setLineDash([W/30,W/30])
  
  ctx.beginPath()
  ctx.moveTo(x+5*W/10, y+5*H/10)
  points.push(x+5*W/10, y+5*H/10)
  ctx.lineTo(x+0*W/10, y+5*H/10)
  points.push(x+0*W/10, y+5*H/10)
  ctx.lineTo(x+2*W/10, y+7*H/10)
  points.push(x+2*W/10, y+7*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+8*W/10, y+7*H/10)
  points.push(x+8*W/10, y+7*H/10)
  ctx.lineTo(x+10*W/10, y+5*H/10)
  points.push(x+10*W/10, y+5*H/10)
  ctx.lineTo(x+5*W/10, y+5*H/10)
  points.push(x+5*W/10, y+5*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+1*W/10, y+5*H/10)
  points.push(x+1*W/10, y+5*H/10)
  cpx = x+1*W/10
  cpy = y+8*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/10, y+8*H/10)
  points.push(x+5*W/10, y+8*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+9*W/10, y+5*H/10)
  points.push(x+9*W/10, y+5*H/10)
  cpx = x+9*W/10
  cpy = y+8*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+8*H/10)
  points.push(x+6*W/10, y+8*H/10)
  ctx.stroke()
  ctx.setLineDash([])
  // arrows
  
  ctx.beginPath()
  ctx.moveTo(x+3.5*W/10, y+7.5*H/10)
  ctx.lineTo(x+4*W/10, y+8*H/10)
  ctx.lineTo(x+3.5*W/10, y+8.5*H/10)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+6.5*W/10, y+7.5*H/10)
  ctx.lineTo(x+6*W/10, y+8*H/10)
  ctx.lineTo(x+6.5*W/10, y+8.5*H/10)
  ctx.stroke()
  // behind ...
  
  ctx.beginPath()
  ctx.moveTo(x+8*W/10, y+7*H/10)
  points.push(x+8*W/10, y+7*H/10)
  ctx.lineTo(x+5.25*W/10, y+10*H/10)
  points.push(x+6*W/10, y+10*H/10)
  ctx.lineTo(x+5.1*W/10, y+9.9*H/10)
  points.push(x+5.25*W/10, y+9.5*H/10)
  ctx.stroke()
  
  drawStars(x,y,W,points)
}

function foldedAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.fillStyle = color
  ctx.lineCap = "square"
  ctx.lineJoin = "bevel"
  ctx.shadowBlur = 10 + Math.random() * 15
  ctx.shadowColor = "#666666"
  ctx.shadowOffsetX = (Math.random()) * 4
  ctx.shadowOffsetY  = (Math.random()) * 4
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+7*H/12)
  points.push(x+0*W/12, y+7*H/12)
  ctx.lineTo(x+5*W/12, y+12*H/12)
  points.push(x+5*W/12, y+12*H/12)
  ctx.lineTo(x+6*W/12, y+0*H/12)
  points.push(x+6*W/12, y+0*H/12)
  ctx.lineTo(x+0*W/12, y+7*H/12)
  points.push(x+0*W/12, y+7*H/12)
  ctx.fill()
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+12*H/12)
  points.push(x+7*W/12, y+12*H/12)
  ctx.lineTo(x+6*W/12, y+0*H/12)
  points.push(x+6*W/12, y+0*H/12)
  ctx.lineTo(x+12*W/12, y+7*H/12)
  points.push(x+12*W/12, y+7*H/12)
  ctx.lineTo(x+7*W/12, y+12*H/12)
  points.push(x+7*W/12, y+12*H/12)
  ctx.fill()
  ctx.fillStyle = "#ffffff"
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+12*H/12)
  points.push(x+5*W/12, y+12*H/12)
  ctx.lineTo(x+0*W/12, y+6*H/12)
  points.push(x+0*W/12, y+6*H/12)
  ctx.lineTo(x+6*W/12, y+0*H/12)
  points.push(x+6*W/12, y+0*H/12)
  ctx.lineTo(x+5*W/12, y+12*H/12)
  points.push(x+5*W/12, y+12*H/12)
  ctx.fill()
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+12*H/12)
  points.push(x+7*W/12, y+12*H/12)
  ctx.lineTo(x+12*W/12, y+6*H/12)
  points.push(x+12*W/12, y+6*H/12)
  ctx.lineTo(x+6*W/12, y+0*H/12)
  points.push(x+6*W/12, y+0*H/12)
  ctx.lineTo(x+7*W/12, y+12*H/12)
  points.push(x+7*W/12, y+12*H/12)
  ctx.fill()
  ctx.fillStyle = color
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+6*H/12)
  points.push(x+0*W/12, y+6*H/12)
  ctx.lineTo(x+6*W/12, y+12*H/12)
  points.push(x+6*W/12, y+12*H/12)
  ctx.lineTo(x+12*W/12, y+6*H/12)
  points.push(x+12*W/12, y+6*H/12)
  ctx.lineTo(x+6*W/12, y+0*H/12)
  points.push(x+6*W/12, y+0*H/12)
  ctx.lineTo(x+0*W/12, y+6*H/12)
  points.push(x+0*W/12, y+6*H/12)
  ctx.fill()

  ctx.setLineDash([])
  ctx.shadowBlur = 0
  drawStars(x,y,W,points)
}

function foldedbackAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.fillStyle = color
  ctx.lineCap = "square"
  ctx.lineJoin = "bevel"
  ctx.shadowBlur = 5 + Math.random() * 5
  ctx.shadowColor = "#666666"
  ctx.shadowOffsetX = -(Math.random()) * 4
  ctx.shadowOffsetY  = -(Math.random()) * 4
  
  ctx.fillStyle = "#ffffff"
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+6*H/12)
  points.push(x+0*W/12, y+6*H/12)
  ctx.lineTo(x+6*W/12, y+12*H/12)
  points.push(x+6*W/12, y+12*H/12)
  ctx.lineTo(x+12*W/12, y+6*H/12)
  points.push(x+12*W/12, y+6*H/12)
  ctx.lineTo(x+6*W/12, y+0*H/12)
  points.push(x+6*W/12, y+0*H/12)
  ctx.lineTo(x+0*W/12, y+6*H/12)
  points.push(x+0*W/12, y+6*H/12)
  ctx.fill()
  ctx.fillStyle = color
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+7*H/12)
  points.push(x+0*W/12, y+7*H/12)
  ctx.lineTo(x+5*W/12, y+12*H/12)
  points.push(x+5*W/12, y+12*H/12)
  ctx.lineTo(x+6*W/12, y+0*H/12)
  points.push(x+6*W/12, y+0*H/12)
  ctx.lineTo(x+0*W/12, y+7*H/12)
  points.push(x+0*W/12, y+7*H/12)
  ctx.fill()
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+12*H/12)
  points.push(x+7*W/12, y+12*H/12)
  ctx.lineTo(x+6*W/12, y+0*H/12)
  points.push(x+6*W/12, y+0*H/12)
  ctx.lineTo(x+12*W/12, y+7*H/12)
  points.push(x+12*W/12, y+7*H/12)
  ctx.lineTo(x+7*W/12, y+12*H/12)
  points.push(x+7*W/12, y+12*H/12)
  ctx.fill()
  ctx.fillStyle = "#ffffff"
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+12*H/12)
  points.push(x+5*W/12, y+12*H/12)
  ctx.lineTo(x+0*W/12, y+6*H/12)
  points.push(x+0*W/12, y+6*H/12)
  ctx.lineTo(x+6*W/12, y+0*H/12)
  points.push(x+6*W/12, y+0*H/12)
  ctx.lineTo(x+5*W/12, y+12*H/12)
  points.push(x+5*W/12, y+12*H/12)
  ctx.fill()
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+12*H/12)
  points.push(x+7*W/12, y+12*H/12)
  ctx.lineTo(x+12*W/12, y+6*H/12)
  points.push(x+12*W/12, y+6*H/12)
  ctx.lineTo(x+6*W/12, y+0*H/12)
  points.push(x+6*W/12, y+0*H/12)
  ctx.lineTo(x+7*W/12, y+12*H/12)
  points.push(x+7*W/12, y+12*H/12)
  ctx.fill()
  
  ctx.fillStyle = color
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+6*H/12)
  //ctx.lineTo(x+6*W/12, y+12*H/12)
  ctx.lineTo(x+12*W/12, y+6*H/12)
  ctx.lineTo(x+5.7*W/12, y+0*H/12)
  ctx.lineTo(x+0*W/12, y+6*H/12)
  ctx.fill()
 
  ctx.fillStyle = "#ffffff"
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+6*H/12)
  //ctx.lineTo(x+6*W/12, y+12*H/12)
  ctx.lineTo(x+12*W/12, y+6*H/12)
  ctx.lineTo(x+6*W/12, y+0*H/12)
  ctx.lineTo(x+0*W/12, y+6*H/12)
  ctx.fill()
  
  ctx.setLineDash([])
  ctx.shadowBlur = 0
  drawStars(x,y,W,points)
}

function foldedback2At (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.fillStyle = color
  ctx.lineCap = "square"
  ctx.lineJoin = "bevel"
  ctx.shadowBlur = 8 + Math.random() * 5
  ctx.shadowColor = "#444444"
  ctx.shadowOffsetX = -(Math.random()) * 4
  ctx.shadowOffsetY  = -(Math.random()) * 4
  
  ctx.fillStyle = "#ffffff"
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+6*H/12)
  ctx.lineTo(x+6*W/12, y+12*H/12)
  ctx.lineTo(x+12*W/12, y+6*H/12)
  ctx.lineTo(x+6*W/12, y+0*H/12)
  ctx.lineTo(x+0*W/12, y+6*H/12)
  ctx.fill()
  
  ctx.fillStyle = color
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+7*H/12)
  ctx.lineTo(x+5*W/12, y+12*H/12)
  ctx.lineTo(x+6*W/12, y+0*H/12)
  ctx.lineTo(x+0*W/12, y+7*H/12)
  ctx.fill()
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+12*H/12)
  ctx.lineTo(x+6*W/12, y+0*H/12)
  ctx.lineTo(x+12*W/12, y+6*H/12)
  ctx.lineTo(x+7*W/12, y+12*H/12)
  ctx.fill()
  
  ctx.fillStyle = "#ffffff"
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+12*H/12)
  ctx.lineTo(x+0*W/12, y+6*H/12)
  ctx.lineTo(x+6*W/12, y+0*H/12)
  ctx.lineTo(x+5*W/12, y+12*H/12)
  ctx.fill()
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+12*H/12)
  ctx.lineTo(x+10*W/12, y+4*H/12)//
  ctx.lineTo(x+6*W/12, y+0*H/12)
  ctx.lineTo(x+7*W/12, y+12*H/12)
  ctx.fill()
  
  ctx.fillStyle = color
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+6*H/12)
  ctx.lineTo(x+10*W/12, y+4*H/12)
  ctx.lineTo(x+5.7*W/12, y+0*H/12)
  ctx.lineTo(x+0*W/12, y+6*H/12)
  ctx.fill()
 
  ctx.fillStyle = "#ffffff"
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+6*H/12)
  ctx.lineTo(x+6*W/12, y+0*H/12)
  
  ctx.lineTo(x+10*W/12, y+4*H/12)
  ctx.lineTo(x+7*W/12, y+6*H/12)
  ctx.lineTo(x+0*W/12, y+6*H/12)
  ctx.fill()
  
  ctx.fillStyle = color
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+12*H/12)
  ctx.lineTo(x+10*W/12, y+4*H/12)
  ctx.lineTo(x+6*W/12, y+4*H/12)
  ctx.lineTo(x+7*W/12, y+12*H/12)
  ctx.fill()
  
  ctx.setLineDash([])
  ctx.shadowBlur = 0
  drawStars(x,y,W,points)
}

function updownAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  let colors = shuffle(getCurrentPalette(true,13))
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.lineJoin = "bevel"

  ctx.beginPath()
  ctx.moveTo(x+5*W/16, y+1*H/16)
  ctx.lineTo(x+2*W/16, y+7*H/16)
  ctx.lineTo(x+8*W/16, y+7*H/16)
  ctx.lineTo(x+5*W/16, y+1*H/16)
  ctx.fillStyle = randomPick(colors)
 ctx.fill()
  ctx.beginPath()
  ctx.moveTo(x+5*W/16, y+15*H/16)
  ctx.lineTo(x+8*W/16, y+9*H/16)
  ctx.lineTo(x+2*W/16, y+9*H/16)
  ctx.lineTo(x+5*W/16, y+15*H/16)
  ctx.fillStyle = randomPick(colors)
 ctx.fill()
  ctx.beginPath()
  ctx.moveTo(x+9*W/16, y+1*H/16)
  ctx.lineTo(x+9*W/16, y+6*H/16)
  ctx.lineTo(x+10*W/16, y+6*H/16)
  ctx.lineTo(x+10*W/16, y+7*H/16)
  ctx.lineTo(x+13*W/16, y+7*H/16)
  ctx.lineTo(x+13*W/16, y+6*H/16)
  ctx.lineTo(x+14*W/16, y+6*H/16)
  ctx.lineTo(x+14*W/16, y+1*H/16)
  ctx.lineTo(x+12*W/16, y+1*H/16)
  ctx.lineTo(x+12*W/16, y+5*H/16)
  ctx.lineTo(x+11*W/16, y+5*H/16)
  ctx.lineTo(x+11*W/16, y+2*H/16)
  ctx.lineTo(x+10*W/16, y+1*H/16)
  ctx.lineTo(x+9*W/16, y+1*H/16)
  ctx.fillStyle = randomPick(colors)
 ctx.fill()
  ctx.beginPath()
  ctx.moveTo(x+9*W/16, y+9*H/16)
  ctx.lineTo(x+9*W/16, y+15*H/16)
  ctx.lineTo(x+13*W/16, y+15*H/16)
  ctx.lineTo(x+13*W/16, y+14*H/16)
  ctx.lineTo(x+14*W/16, y+14*H/16)
  ctx.lineTo(x+14*W/16, y+10*H/16)
  ctx.lineTo(x+13*W/16, y+10*H/16)
  ctx.lineTo(x+13*W/16, y+9*H/16)
  ctx.lineTo(x+9*W/16, y+9*H/16)
  ctx.fillStyle = randomPick(colors)
 ctx.fill()
  ctx.beginPath()
  ctx.moveTo(x+10*W/16, y+10*H/16)
  ctx.lineTo(x+10*W/16, y+14*H/16)
  ctx.lineTo(x+12*W/16, y+14*H/16)
  ctx.lineTo(x+13*W/16, y+13*H/16)
  ctx.lineTo(x+13*W/16, y+11*H/16)
  ctx.lineTo(x+12*W/16, y+10*H/16)
  ctx.lineTo(x+10*W/16, y+10*H/16)
  ctx.fillStyle = randomPick(colors)
 ctx.fill()
  ctx.beginPath()
  ctx.moveTo(x+8*W/16, y+7*H/16)
  ctx.lineTo(x+7*W/16, y+8*H/16)
  ctx.lineTo(x+6*W/16, y+9*H/16)
  ctx.lineTo(x+2*W/16, y+9*H/16)
  ctx.lineTo(x+5*W/16, y+15*H/16)
  ctx.lineTo(x+4*W/16, y+16*H/16)
  ctx.lineTo(x+0*W/16, y+15*H/16)
  ctx.lineTo(x+0*W/16, y+8*H/16)
  ctx.lineTo(x+2*W/16, y+7*H/16)
  ctx.fillStyle = randomPick(colors)
 ctx.fill()
  ctx.beginPath()
  ctx.moveTo(x+9*W/16, y+1*H/16)
  ctx.lineTo(x+6*W/16, y+3*H/16)
  ctx.lineTo(x+8*W/16, y+7*H/16)
  ctx.lineTo(x+6*W/16, y+9*H/16)
  ctx.lineTo(x+8*W/16, y+9*H/16)
  ctx.lineTo(x+9*W/16, y+8*H/16)
  ctx.lineTo(x+13*W/16, y+8*H/16)
  ctx.lineTo(x+14*W/16, y+6*H/16)
  ctx.fillStyle = randomPick(colors)
 ctx.fill()
  ctx.beginPath()
  ctx.moveTo(x+10*W/16, y+11*H/16)
  ctx.lineTo(x+12*W/16, y+12*H/16)
  ctx.lineTo(x+13*W/16, y+13*H/16)
  ctx.lineTo(x+13*W/16, y+11*H/16)
  ctx.lineTo(x+12*W/16, y+10*H/16)
  ctx.lineTo(x+10*W/16, y+10*H/16)
  ctx.fillStyle = randomPick(colors)
 ctx.fill()
  ctx.beginPath()
  ctx.moveTo(x+6*W/16, y+13*H/16)
  ctx.lineTo(x+8*W/16, y+14*H/16)
  ctx.lineTo(x+7*W/16, y+16*H/16)
  ctx.lineTo(x+14*W/16, y+16*H/16)
  ctx.lineTo(x+14*W/16, y+14*H/16)
  ctx.lineTo(x+13*W/16, y+14*H/16)
  ctx.lineTo(x+13*W/16, y+15*H/16)
  ctx.lineTo(x+9*W/16, y+15*H/16)
  ctx.lineTo(x+9*W/16, y+9*H/16)
  ctx.lineTo(x+8*W/16, y+9*H/16)
  ctx.lineTo(x+6*W/16, y+13*H/16)
  ctx.fillStyle = randomPick(colors)
 ctx.fill()
  ctx.beginPath()
  ctx.moveTo(x+8*W/16, y+9*H/16)
  ctx.lineTo(x+15*W/16, y+9*H/16)
  ctx.lineTo(x+16*W/16, y+7*H/16)
  ctx.lineTo(x+16*W/16, y+6*H/16)
  ctx.lineTo(x+14*W/16, y+6*H/16)
  ctx.lineTo(x+13*W/16, y+8*H/16)
  ctx.lineTo(x+9*W/16, y+8*H/16)
  ctx.lineTo(x+8*W/16, y+9*H/16)
  ctx.fillStyle = randomPick(colors)
 ctx.fill()
 ctx.beginPath()
  ctx.moveTo(x+9*W/16, y+1*H/16)
  ctx.lineTo(x+9*W/16, y+6*H/16)
  ctx.lineTo(x+10*W/16, y+6*H/16)
  ctx.lineTo(x+10*W/16, y+7*H/16)
  ctx.lineTo(x+13*W/16, y+7*H/16)
  ctx.lineTo(x+13*W/16, y+6*H/16)
  ctx.lineTo(x+14*W/16, y+6*H/16)
  ctx.lineTo(x+14*W/16, y+1*H/16)
  ctx.lineTo(x+12*W/16, y+1*H/16)
  ctx.lineTo(x+12*W/16, y+5*H/16)
  ctx.lineTo(x+11*W/16, y+5*H/16)
  ctx.lineTo(x+11*W/16, y+2*H/16)
  ctx.lineTo(x+10*W/16, y+1*H/16)
  ctx.lineTo(x+9*W/16, y+1*H/16)
  ctx.lineTo(x+9*W/16, y+6*H/16)
  ctx.lineTo(x+10*W/16, y+6*H/16)
  ctx.fillStyle = randomPick(colors)
  ctx.fill()

  ctx.setLineDash([])
  drawStars(x,y,W,points)
}


function refractionAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  
  ctx.beginPath()
  ctx.moveTo(x+2*W/14, y+2*H/14)
  points.push(x+2*W/14, y+2*H/14)
  cpx = x+2*W/14
  cpy = y+1*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/14, y+1*H/14)
  points.push(x+7*W/14, y+1*H/14)
  cpx = x+12*W/14
  cpy = y+1*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/14, y+2*H/14)
  points.push(x+12*W/14, y+2*H/14)
  cpx = x+12*W/14
  cpy = y+3*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/14, y+3*H/14)
  points.push(x+7*W/14, y+3*H/14)
  cpx = x+2*W/14
  cpy = y+3*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/14, y+2*H/14)
  points.push(x+2*W/14, y+2*H/14)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+4*W/14, y+13*H/14)
  points.push(x+4*W/14, y+13*H/14)
  cpx = x+4*W/14
  cpy = y+12*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/14, y+12*H/14)
  points.push(x+7*W/14, y+12*H/14)
  cpx = x+10*W/14
  cpy = y+12*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/14, y+13*H/14)
  points.push(x+10*W/14, y+13*H/14)
  cpx = x+10*W/14
  cpy = y+14*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/14, y+14*H/14)
  points.push(x+7*W/14, y+14*H/14)
  cpx = x+4*W/14
  cpy = y+14*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/14, y+13*H/14)
  points.push(x+4*W/14, y+13*H/14)
  ctx.lineTo(x+2*W/14, y+2*H/14)
  points.push(x+2*W/14, y+2*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+12*W/14, y+2*H/14)
  points.push(x+12*W/14, y+2*H/14)
  ctx.lineTo(x+10*W/14, y+13*H/14)
  points.push(x+10*W/14, y+13*H/14)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+3*W/14, y+7*H/14)
  points.push(x+3*W/14, y+7*H/14)
  cpx = x+3*W/14
  cpy = y+6*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/14, y+6*H/14)
  points.push(x+7*W/14, y+6*H/14)
  cpx = x+11*W/14
  cpy = y+6*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+11*W/14, y+7*H/14)
  points.push(x+11*W/14, y+7*H/14)
  cpx = x+11*W/14
  cpy = y+8*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/14, y+8*H/14)
  points.push(x+7*W/14, y+8*H/14)
  cpx = x+3*W/14
  cpy = y+8*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/14, y+7*H/14)
  points.push(x+3*W/14, y+7*H/14)
  ctx.stroke()

  ctx.beginPath()
  ctx.moveTo(x+6*W/14, y+8*H/14)
  points.push(x+6*W/14, y+8*H/14)
  ctx.lineTo(x+8*W/14, y+0*H/14)
  points.push(x+8*W/14, y+0*H/14)
  ctx.moveTo(x+8*W/14, y+0*H/14)
  points.push(x+8*W/14, y+0*H/14)
  cpx = x+9*W/14
  cpy = y+0*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/14, y+1*H/14)
  points.push(x+9*W/14, y+1*H/14)
  ctx.lineTo(x+7*W/14, y+8*H/14)
  points.push(x+7*W/14, y+8*H/14)
  ctx.lineTo(x+6*W/14, y+12*H/14)
  points.push(x+6*W/14, y+12*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7*W/14, y+13*H/14)
  points.push(x+7*W/14, y+13*H/14)
  ctx.lineTo(x+8*W/14, y+8*H/14)
  points.push(x+8*W/14, y+8*H/14)
  ctx.stroke()
  
  //low end of straw
  ctx.beginPath()
  ctx.moveTo(x+7*W/14, y+13*H/14)
  points.push(x+7*W/14, y+13*H/14)
  cpx = x+7*W/14
  cpy = y+12*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/14, y+12*H/14)
  points.push(x+6*W/14, y+12*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/14, y+12*H/14)
  points.push(x+6*W/14, y+12*H/14)
  cpx = x+6*W/14
  cpy = y+13*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/14, y+13*H/14)
  points.push(x+7*W/14, y+13*H/14)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+9*W/14, y+1*H/14)
  points.push(x+9*W/14, y+1*H/14)
  cpx = x+8*W/14
  cpy = y+1*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/14, y+0*H/14)
  points.push(x+8*W/14, y+0*H/14)
  ctx.stroke()
  
  drawStars(x,y,W,points)
}

function sardinesAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"

  ctx.beginPath()
  ctx.moveTo(x+2*W/12, y+9*H/12)
  points.push(x+2*W/12, y+9*H/12)
  cpx = x+2*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+12*H/12)
  points.push(x+3*W/12, y+12*H/12)
  cpx = x+4*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+9*H/12)
  points.push(x+4*W/12, y+9*H/12)
  cpx = x+4*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+2*H/12)
  points.push(x+3*W/12, y+2*H/12)
  cpx = x+2*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+9*H/12)
  points.push(x+2*W/12, y+9*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+0*H/12)
  points.push(x+5*W/12, y+0*H/12)
  cpx = x+4*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+3*H/12)
  points.push(x+4*W/12, y+3*H/12)
  cpx = x+4*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+10*H/12)
  points.push(x+5*W/12, y+10*H/12)
  cpx = x+6*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+3*H/12)
  points.push(x+6*W/12, y+3*H/12)
  cpx = x+6*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+0*H/12)
  points.push(x+5*W/12, y+0*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+12*H/12)
  points.push(x+7*W/12, y+12*H/12)
  cpx = x+6*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+9*H/12)
  points.push(x+6*W/12, y+9*H/12)
  cpx = x+6*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+2*H/12)
  points.push(x+7*W/12, y+2*H/12)
  cpx = x+8*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+9*H/12)
  points.push(x+8*W/12, y+9*H/12)
  cpx = x+8*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+12*H/12)
  points.push(x+7*W/12, y+12*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+9*W/12, y+0*H/12)
  points.push(x+9*W/12, y+0*H/12)
  cpx = x+8*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+3*H/12)
  points.push(x+8*W/12, y+3*H/12)
  cpx = x+8*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+10*H/12)
  points.push(x+9*W/12, y+10*H/12)
  cpx = x+10*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+4*H/12)
  points.push(x+10*W/12, y+4*H/12)
  cpx = x+10*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+0*H/12)
  points.push(x+9*W/12, y+0*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/12, y+12*H/12)
  points.push(x+4*W/12, y+12*H/12)
  cpx = x+4*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+10*H/12)
  points.push(x+5*W/12, y+10*H/12)
  cpx = x+6*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+12*H/12)
  points.push(x+6*W/12, y+12*H/12)
  cpx = x+5*W/12
  cpy = y+11*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+12*H/12)
  points.push(x+4*W/12, y+12*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+0*H/12)
  points.push(x+6*W/12, y+0*H/12)
  cpx = x+6*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+2*H/12)
  points.push(x+7*W/12, y+2*H/12)
  cpx = x+8*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+0*H/12)
  points.push(x+8*W/12, y+0*H/12)
  cpx = x+7*W/12
  cpy = y+1*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+0*H/12)
  points.push(x+6*W/12, y+0*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+8*W/12, y+12*H/12)
  points.push(x+8*W/12, y+12*H/12)
  cpx = x+8*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+10*H/12)
  points.push(x+9*W/12, y+10*H/12)
  cpx = x+10*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+11*H/12)
  points.push(x+10*W/12, y+11*H/12)
  cpx = x+10*W/12
  cpy = y+12*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+11*H/12)
  points.push(x+9*W/12, y+11*H/12)
  //ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+8*W/12, y+12*H/12)
  points.push(x+8*W/12, y+12*H/12)
  cpx = x+8*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+10*H/12)
  points.push(x+9*W/12, y+10*H/12)
  cpx = x+10*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+12*H/12)
  points.push(x+10*W/12, y+12*H/12)
  cpx = x+9*W/12
  cpy = y+11*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+12*H/12)
  points.push(x+8*W/12, y+12*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/12, y+0*H/12)
  points.push(x+2*W/12, y+0*H/12)
  cpx = x+2*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+2*H/12)
  points.push(x+3*W/12, y+2*H/12)
  cpx = x+4*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+0*H/12)
  points.push(x+4*W/12, y+0*H/12)
  cpx = x+3*W/12
  cpy = y+1*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+0*H/12)
  points.push(x+2*W/12, y+0*H/12)
  ctx.stroke()
  // eyes
  ctx.beginPath()
  ctx.arc(x+3*W/12, y+10*H/12,W/24,0,Math.PI*2)
  points.push(x+3*W/12, y+10*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.arc(x+7*W/12, y+10*H/12,W/24,0,Math.PI*2)
  points.push(x+7*W/12, y+10*H/12)
  ctx.stroke()
  // eyes
  ctx.beginPath()
  ctx.arc(x+5*W/12, y+2*H/12,W/24,0,Math.PI*2)
  points.push(x+5*W/12, y+2*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.arc(x+9*W/12, y+2*H/12,W/24,0,Math.PI*2)
  points.push(x+9*W/12, y+2*H/12)
  ctx.stroke()
  
  // box
  ctx.beginPath()
  ctx.moveTo(x+2.5*W/12, y+12*H/12)
  points.push(x+2.5*W/12, y+12*H/12)
  cpx = x+1.5*W/12
  cpy = y+12*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+1.5*W/12, y+11*H/12)
  points.push(x+1.5*W/12, y+11*H/12)
  ctx.lineTo(x+1.5*W/12, y+1*H/12)
  points.push(x+1.5*W/12, y+1*H/12)
  cpx = x+1.5*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2.5*W/12, y+0*H/12)
  points.push(x+2*W/12, y+0*H/12)
  ctx.lineTo(x+10*W/12, y+0*H/12)
  points.push(x+10*W/12, y+0*H/12)
  cpx = x+10.5*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10.5*W/12, y+1*H/12)
  points.push(x+10.5*W/12, y+1*H/12)
  ctx.lineTo(x+10.5*W/12, y+11*H/12)
  points.push(x+10.5*W/12, y+11*H/12)
  cpx = x+10.5*W/12
  cpy = y+12*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9.5*W/12, y+12*H/12)
  points.push(x+9.5*W/12, y+12*H/12)
  ctx.lineTo(x+2.5*W/12, y+12*H/12)
  points.push(x+2.5*W/12, y+12*H/12)
  ctx.stroke()

  drawStars(x,y,W,points)
}  // sardines end

function refractfishAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"

  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+4*H/12)
  points.push(x+7*W/12, y+4*H/12)
  cpx = x+7*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+1*H/12)
  points.push(x+10*W/12, y+1*H/12)
  cpx = x+10*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+4*H/12)
  points.push(x+9*W/12, y+4*H/12)
  ctx.stroke()
  // tail
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+4*H/12)
  points.push(x+0*W/12, y+4*H/12)
  ctx.lineTo(x+12*W/12, y+4*H/12)
  points.push(x+12*W/12, y+4*H/12)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+4*H/12)
  points.push(x+7*W/12, y+4*H/12)
  cpx = x+6*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+9*H/12)
  points.push(x+3*W/12, y+9*H/12)
  cpx = x+3*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+4*H/12)
  points.push(x+5*W/12, y+4*H/12)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+3*W/12, y+9*H/12)
  points.push(x+3*W/12, y+9*H/12)
  cpx = x+1*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/12, y+11*H/12)
  points.push(x+1*W/12, y+11*H/12)
  cpx = x+3*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+12*H/12)
  points.push(x+4*W/12, y+12*H/12)
  cpx = x+4*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+9*H/12)
  points.push(x+3*W/12, y+9*H/12)
  ctx.stroke()
  //eye
  ctx.beginPath()
  ctx.arc(x+9.25*W/12, y+2*H/12, W/24, 0, Math.PI*2)
  points.push(x+9.25*W/12, y+2*H/12)
  ctx.stroke()
  
  drawStars(x,y,W,points)
}

function fiss3At (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"

  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+4*H/12)
  points.push(x+0*W/12, y+4*H/12)
  cpx = x+0*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/12, y+0*H/12)
  points.push(x+1*W/12, y+0*H/12)
  cpx = x+2*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+4*H/12)
  points.push(x+2*W/12, y+4*H/12)
  cpx = x+2*W/12
  cpy = y+6*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+10*H/12)
  points.push(x+3*W/12, y+10*H/12)
  cpx = x+4*W/12
  cpy = y+6*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+4*H/12)
  points.push(x+4*W/12, y+4*H/12)
  cpx = x+4*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+0*H/12)
  points.push(x+5*W/12, y+0*H/12)
  cpx = x+6*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+4*H/12)
  points.push(x+6*W/12, y+4*H/12)
  cpx = x+6*W/12
  cpy = y+6*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+10*H/12)
  points.push(x+7*W/12, y+10*H/12)
  cpx = x+8*W/12
  cpy = y+6*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+4*H/12)
  points.push(x+8*W/12, y+4*H/12)
  cpx = x+8*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+0*H/12)
  points.push(x+9*W/12, y+0*H/12)
  cpx = x+10*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+4*H/12)
  points.push(x+10*W/12, y+4*H/12)
  cpx = x+10*W/12
  cpy = y+6*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+11*W/12, y+10*H/12)
  points.push(x+11*W/12, y+10*H/12)
  cpx = x+12*W/12
  cpy = y+6*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+4*H/12)
  points.push(x+12*W/12, y+4*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/12, y+12*H/12)
  points.push(x+2*W/12, y+12*H/12)
  cpx = x+2*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+10*H/12)
  points.push(x+3*W/12, y+10*H/12)
  cpx = x+4*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+12*H/12)
  points.push(x+4*W/12, y+12*H/12)
  cpx = x+3*W/12
  cpy = y+11*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+12*H/12)
  points.push(x+2*W/12, y+12*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+12*H/12)
  points.push(x+6*W/12, y+12*H/12)
  cpx = x+6*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+10*H/12)
  points.push(x+7*W/12, y+10*H/12)
  cpx = x+8*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+12*H/12)
  points.push(x+8*W/12, y+12*H/12)
  cpx = x+7*W/12
  cpy = y+11*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+12*H/12)
  points.push(x+6*W/12, y+12*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+10*W/12, y+12*H/12)
  points.push(x+10*W/12, y+12*H/12)
  cpx = x+10*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+11*W/12, y+10*H/12)
  points.push(x+11*W/12, y+10*H/12)
  cpx = x+12*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+12*H/12)
  points.push(x+12*W/12, y+12*H/12)
  cpx = x+11*W/12
  cpy = y+11*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+12*H/12)
  points.push(x+10*W/12, y+12*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+4*H/12)
  points.push(x+0*W/12, y+4*H/12)
  ctx.lineTo(x+12*W/12, y+4*H/12)
  points.push(x+12*W/12, y+4*H/12)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+4*H/12)
  points.push(x+6*W/12, y+4*H/12)
  cpx = x+5*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+8*H/12)
  points.push(x+5*W/12, y+8*H/12)
  cpx = x+6*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+10*H/12)
  points.push(x+7*W/12, y+10*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+10*W/12, y+4*H/12)
  points.push(x+10*W/12, y+4*H/12)
  cpx = x+9*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+8*H/12)
  points.push(x+9*W/12, y+8*H/12)
  cpx = x+10*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+11*W/12, y+10*H/12)
  points.push(x+11*W/12, y+10*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/12, y+4*H/12)
  points.push(x+2*W/12, y+4*H/12)
  cpx = x+1*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/12, y+8*H/12)
  points.push(x+1*W/12, y+8*H/12)
  cpx = x+2*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+10*H/12)
  points.push(x+3*W/12, y+10*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.arc(x+1*W/12, y+3*H/12, W/24,0,Math.PI*2)
  points.push(x+1*W/12, y+3*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.arc(x+5*W/12, y+3*H/12, W/24,0,Math.PI*2)
  points.push(x+5*W/12, y+3*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.arc(x+9*W/12, y+3*H/12, W/24,0,Math.PI*2)
  points.push(x+9*W/12, y+3*H/12)
  ctx.stroke()
// sides & bottom
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+4*H/12)
  points.push(x+0*W/12, y+4*H/12)
  ctx.lineTo(x+0*W/12, y+12*H/12)
  points.push(x+0*W/12, y+12*H/12)
  ctx.lineTo(x+12*W/12, y+12*H/12)
  points.push(x+12*W/12, y+12*H/12)
  ctx.lineTo(x+12*W/12, y+4*H/12)
  points.push(x+12*W/12, y+4*H/12)
  ctx.stroke()
  drawStars(x,y,W,points)
}

function fiss2At (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+12*H/12)
  points.push(x+0*W/12, y+12*H/12)
  ctx.lineTo(x+6*W/12, y+10*H/12)
  points.push(x+6*W/12, y+10*H/12)
  ctx.lineTo(x+12*W/12, y+12*H/12)
  points.push(x+12*W/12, y+12*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+0*H/12)
  points.push(x+0*W/12, y+0*H/12)
  ctx.lineTo(x+6*W/12, y+2*H/12)
  points.push(x+6*W/12, y+2*H/12)
  ctx.lineTo(x+12*W/12, y+0*H/12)
  points.push(x+12*W/12, y+0*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+10*H/12)
  points.push(x+6*W/12, y+10*H/12)
  ctx.lineTo(x+6*W/12, y+2*H/12)
  points.push(x+6*W/12, y+2*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+9*H/12)
  points.push(x+6*W/12, y+9*H/12)
  cpx = x+5*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+9*H/12)
  points.push(x+3*W/12, y+9*H/12)
  cpx = x+5*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+7*H/12)
  points.push(x+6*W/12, y+7*H/12)
  cpx = x+7*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+6*H/12)
  points.push(x+9*W/12, y+6*H/12)
  cpx = x+7*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+5*H/12)
  points.push(x+6*W/12, y+5*H/12)
  cpx = x+5*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+3*H/12)
  points.push(x+3*W/12, y+3*H/12)
  cpx = x+5*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+3*H/12)
  points.push(x+6*W/12, y+3*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+3*H/12)
  points.push(x+6*W/12, y+3*H/12)
  cpx = x+9*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+3*H/12)
  points.push(x+10*W/12, y+3*H/12)
  cpx = x+9*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+5*H/12)
  points.push(x+6*W/12, y+5*H/12)
  cpx = x+5*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+6*H/12)
  points.push(x+2*W/12, y+6*H/12)
  cpx = x+5*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+7*H/12)
  points.push(x+6*W/12, y+7*H/12)
  cpx = x+9*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+9*H/12)
  points.push(x+10*W/12, y+9*H/12)
  cpx = x+9*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+9*H/12)
  points.push(x+6*W/12, y+9*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+10*W/12, y+3*H/12)
  points.push(x+10*W/12, y+3*H/12)
  cpx = x+10*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+1*H/12)
  points.push(x+12*W/12, y+1*H/12)
  cpx = x+11*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+3*H/12)
  points.push(x+12*W/12, y+3*H/12)
  cpx = x+12*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+11*W/12, y+4*H/12)
  points.push(x+11*W/12, y+4*H/12)
  cpx = x+10*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+3*H/12)
  points.push(x+10*W/12, y+3*H/12)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+3*W/12, y+9*H/12)
  points.push(x+3*W/12, y+9*H/12)
  cpx = x+3*W/12
  cpy = y+10*H/12
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+10*W/12, y+9*H/12)
  points.push(x+10*W/12, y+9*H/12)
  cpx = x+10*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+11*H/12)
  points.push(x+12*W/12, y+11*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+10*W/12, y+9*H/12)
  points.push(x+10*W/12, y+9*H/12)
  cpx = x+10*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+11*W/12, y+8*H/12)
  points.push(x+11*W/12, y+8*H/12)
  cpx = x+12*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+9*H/12)
  points.push(x+12*W/12, y+9*H/12)
  cpx = x+11*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+11*H/12)
  points.push(x+12*W/12, y+11*H/12)
  ctx.stroke()
  // center tail
  ctx.beginPath()
  ctx.moveTo(x+2*W/12, y+6*H/12)
  points.push(x+2*W/12, y+6*H/12)
  cpx = x+2*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+5*H/12)
  points.push(x+0*W/12, y+5*H/12)
  cpx = x+1*W/12
  cpy = y+6*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+7*H/12)
  points.push(x+0*W/12, y+7*H/12)
  cpx = x+2*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+6*H/12)
  points.push(x+2*W/12, y+6*H/12)
  ctx.stroke()
  // eyes
  ctx.beginPath()
  ctx.arc(x+5*W/12, y+3.5*H/12, W/24,0,Math.PI*2)
  points.push(x+5*W/12, y+3.5*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.arc(x+7*W/12, y+6*H/12, W/24,0,Math.PI*2)
  points.push(x+7*W/12, y+6*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.arc(x+5*W/12, y+8.5*H/12, W/24,0,Math.PI*2)
  points.push(x+5*W/12, y+8.5*H/12)
  ctx.stroke()
 
  drawStars(x,y,W,points)
}

function fissAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+7*H/12)
  points.push(x+6*W/12, y+7*H/12)
  cpx = x+7*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+6*H/12)
  points.push(x+9*W/12, y+6*H/12)
  cpx = x+7*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+5*H/12)
  points.push(x+6*W/12, y+5*H/12)
  cpx = x+5*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+4*H/12)
  points.push(x+3*W/12, y+4*H/12)
  cpx = x+5*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+3*H/12)
  points.push(x+6*W/12, y+3*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+7*H/12)
  points.push(x+6*W/12, y+7*H/12)
  cpx = x+5*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+8*H/12)
  points.push(x+3*W/12, y+8*H/12)
  cpx = x+5*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+9*H/12)
  points.push(x+6*W/12, y+9*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+3*H/12)
  points.push(x+6*W/12, y+3*H/12)
  cpx = x+9*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+3*H/12)
  points.push(x+10*W/12, y+3*H/12)
  cpx = x+9*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+5*H/12)
  points.push(x+6*W/12, y+5*H/12)
  cpx = x+3*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+6*H/12)
  points.push(x+2*W/12, y+6*H/12)
  cpx = x+3*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+7*H/12)
  points.push(x+6*W/12, y+7*H/12)
  cpx = x+9*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+9*H/12)
  points.push(x+10*W/12, y+9*H/12)
  cpx = x+9*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+9*H/12)
  points.push(x+6*W/12, y+9*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+7*H/12)
  points.push(x+0*W/12, y+7*H/12)
  cpx = x+2*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+6*H/12)
  points.push(x+2*W/12, y+6*H/12)
  cpx = x+2*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+5*H/12)
  points.push(x+0*W/12, y+5*H/12)
  cpx = x+1*W/12
  cpy = y+6*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+7*H/12)
  points.push(x+0*W/12, y+7*H/12)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+12*H/12)
  points.push(x+0*W/12, y+12*H/12)
  ctx.lineTo(x+6*W/12, y+10*H/12)
  points.push(x+6*W/12, y+10*H/12)
  ctx.lineTo(x+6*W/12, y+2*H/12)
  points.push(x+6*W/12, y+2*H/12)
  ctx.lineTo(x+0*W/12, y+0*H/12)
  points.push(x+0*W/12, y+0*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+10*H/12)
  points.push(x+6*W/12, y+10*H/12)
  ctx.lineTo(x+12*W/12, y+12*H/12)
  points.push(x+12*W/12, y+12*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+2*H/12)
  points.push(x+6*W/12, y+2*H/12)
  ctx.lineTo(x+12*W/12, y+0*H/12)
  points.push(x+12*W/12, y+0*H/12)
  ctx.stroke()
  // eyes
  ctx.beginPath()
  ctx.arc(x+5*W/12, y+4*H/12, W/24,0,Math.PI*2)
  points.push(x+5*W/12, y+4*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.arc(x+7*W/12, y+6*H/12, W/24,0,Math.PI*2)
  points.push(x+7*W/12, y+6*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.arc(x+5*W/12, y+8*H/12, W/24,0,Math.PI*2)
  points.push(x+5*W/12, y+8*H/12)
  ctx.stroke()
  
  // rt top tail
  ctx.beginPath()
  ctx.moveTo(x+10*W/12, y+3*H/12)
  points.push(x+10*W/12, y+3*H/12)
  cpx = x+10*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+1*H/12)
  points.push(x+12*W/12, y+1*H/12)
  cpx = x+11*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+3*H/12)
  points.push(x+12*W/12, y+3*H/12)
  cpx = x+11*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+3*H/12)
  points.push(x+10*W/12, y+3*H/12)
  ctx.stroke()
  // bottom tail
  ctx.beginPath()
  ctx.moveTo(x+10*W/12, y+9*H/12)
  points.push(x+10*W/12, y+9*H/12)
  cpx = x+10*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+11*H/12)
  points.push(x+12*W/12, y+11*H/12)
  cpx = x+11*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+9*H/12)
  points.push(x+12*W/12, y+9*H/12)
  cpx = x+11*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+9*H/12)
  points.push(x+10*W/12, y+9*H/12)
  ctx.stroke()
  // alt heads
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+7*H/12)
  points.push(x+6*W/12, y+7*H/12)
  cpx = x+5*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+9*H/12)
  points.push(x+3*W/12, y+9*H/12)
  cpx = x+5*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+9*H/12)
  points.push(x+6*W/12, y+9*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+5*H/12)
  points.push(x+6*W/12, y+5*H/12)
  cpx = x+5*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+3*H/12)
  points.push(x+3*W/12, y+3*H/12)
  cpx = x+5*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+3*H/12)
  points.push(x+6*W/12, y+3*H/12)
  ctx.stroke()
  
  drawStars(x,y,W,points,0.2)
}

function ohoneAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+4*W/14, y+2*H/14)
  points.push(x+4*W/14, y+2*H/14)
  cpx = x+2*W/14
  cpy = y+2*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/14, y+7*H/14)
  points.push(x+2*W/14, y+7*H/14)
  cpx = x+2*W/14
  cpy = y+12*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/14, y+12*H/14)
  points.push(x+4*W/14, y+12*H/14)
  ctx.lineTo(x+4*W/14, y+14*H/14)
  points.push(x+4*W/14, y+14*H/14)
  cpx = x+0*W/14
  cpy = y+14*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/14, y+7*H/14)
  points.push(x+0*W/14, y+7*H/14)
  cpx = x+0*W/14
  cpy = y+0*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/14, y+0*H/14)
  points.push(x+4*W/14, y+0*H/14)
  ctx.lineTo(x+4*W/14, y+2*H/14)
  points.push(x+4*W/14, y+2*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/14, y+2*H/14)
  points.push(x+5*W/14, y+2*H/14)
  ctx.lineTo(x+5*W/14, y+0*H/14)
  points.push(x+5*W/14, y+0*H/14)
  cpx = x+9*W/14
  cpy = y+0*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/14, y+7*H/14)
  points.push(x+9*W/14, y+7*H/14)
  cpx = x+9*W/14
  cpy = y+14*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/14, y+14*H/14)
  points.push(x+5*W/14, y+14*H/14)
  ctx.lineTo(x+5*W/14, y+12*H/14)
  points.push(x+5*W/14, y+12*H/14)
  cpx = x+7*W/14
  cpy = y+12*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/14, y+7*H/14)
  points.push(x+7*W/14, y+7*H/14)
  cpx = x+7*W/14
  cpy = y+2*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/14, y+2*H/14)
  points.push(x+5*W/14, y+2*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+12*W/14, y+0*H/14)
  points.push(x+12*W/14, y+0*H/14)
  ctx.lineTo(x+14*W/14, y+0*H/14)
  points.push(x+14*W/14, y+0*H/14)
  ctx.lineTo(x+14*W/14, y+14*H/14)
  points.push(x+14*W/14, y+14*H/14)
  ctx.lineTo(x+12*W/14, y+14*H/14)
  points.push(x+12*W/14, y+14*H/14)
  ctx.lineTo(x+12*W/14, y+0*H/14)
  points.push(x+12*W/14, y+0*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+9*W/14, y+2*H/14)
  points.push(x+9*W/14, y+2*H/14)
  ctx.lineTo(x+11*W/14, y+2*H/14)
  points.push(x+11*W/14, y+2*H/14)
  ctx.lineTo(x+11*W/14, y+0*H/14)
  points.push(x+11*W/14, y+0*H/14)
  ctx.lineTo(x+9*W/14, y+2*H/14)
  points.push(x+9*W/14, y+2*H/14)
  ctx.stroke()
  drawStars(x,y,W,points)
}

function mothAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+5*H/12)
  points.push(x+5*W/12, y+5*H/12)
  cpx = x+5*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+0*H/12)
  points.push(x+0*W/12, y+0*H/12)
  cpx = x+0*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+5*H/12)
  points.push(x+5*W/12, y+5*H/12)
  cpx = x+5*W/12
  cpy = y+0*H/12
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+5*H/12)
  points.push(x+7*W/12, y+5*H/12)
  cpx = x+7*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+0*H/12)
  points.push(x+12*W/12, y+0*H/12)
  cpx = x+12*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+5*H/12)
  points.push(x+7*W/12, y+5*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+5*H/12)
  points.push(x+5*W/12, y+5*H/12)
  cpx = x+5*W/12
  cpy = y+12*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+11*H/12)
  points.push(x+0*W/12, y+11*H/12)
  cpx = x+0*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+5*H/12)
  points.push(x+5*W/12, y+5*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+5*H/12)
  points.push(x+7*W/12, y+5*H/12)
  cpx = x+7*W/12
  cpy = y+12*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+11*H/12)
  points.push(x+12*W/12, y+11*H/12)
  cpx = x+12*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+5*H/12)
  points.push(x+7*W/12, y+5*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+4*H/12)
  points.push(x+7*W/12, y+4*H/12)
  cpx = x+7*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+3*H/12)
  points.push(x+6*W/12, y+3*H/12)
  cpx = x+5*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+4*H/12)
  points.push(x+5*W/12, y+4*H/12)
  cpx = x+5*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+10*H/12)
  points.push(x+6*W/12, y+10*H/12)
  cpx = x+7*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+5*H/12)
  points.push(x+7*W/12, y+5*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+3*W/12, y+2*H/12)
  points.push(x+3*W/12, y+2*H/12)
  cpx = x+3*W/12
  cpy = y+1*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+1*H/12)
  points.push(x+2*W/12, y+1*H/12)
  cpx = x+1*W/12
  cpy = y+1*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/12, y+2*H/12)
  points.push(x+1*W/12, y+2*H/12)
  cpx = x+1*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+3*H/12)
  points.push(x+2*W/12, y+3*H/12)
  cpx = x+3*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+2*H/12)
  points.push(x+3*W/12, y+2*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+9*W/12, y+1*H/12)
  points.push(x+9*W/12, y+1*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+9*W/12, y+2*H/12)
  points.push(x+9*W/12, y+2*H/12)
  cpx = x+9*W/12
  cpy = y+1*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+1*H/12)
  points.push(x+10*W/12, y+1*H/12)
  cpx = x+11*W/12
  cpy = y+1*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+11*W/12, y+2*H/12)
  points.push(x+11*W/12, y+2*H/12)
  cpx = x+11*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+3*H/12)
  points.push(x+10*W/12, y+3*H/12)
  cpx = x+9*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+2*H/12)
  points.push(x+9*W/12, y+2*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+3*H/12)
  points.push(x+6*W/12, y+3*H/12)
  cpx = x+7*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+2*H/12)
  points.push(x+7*W/12, y+2*H/12)
  cpx = x+7*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+0*H/12)
  points.push(x+9*W/12, y+0*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+3*H/12)
  points.push(x+6*W/12, y+3*H/12)
  cpx = x+5*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+2*H/12)
  points.push(x+5*W/12, y+2*H/12)
  cpx = x+5*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+0*H/12)
  points.push(x+3*W/12, y+0*H/12)
  ctx.stroke()
  drawStars(x,y,W,points)
}

function vineAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+2*W/10, y+10*H/10)
  points.push(x+2*W/10, y+10*H/10)
  cpx = x+2*W/10
  cpy = y+7*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+7*H/10)
  points.push(x+5*W/10, y+7*H/10)
  cpx = x+8*W/10
  cpy = y+7*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/10, y+4*H/10)
  points.push(x+8*W/10, y+4*H/10)
  cpx = x+8*W/10
  cpy = y+2*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+2*H/10)
  points.push(x+6*W/10, y+2*H/10)
  cpx = x+3*W/10
  cpy = y+2*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/10, y+0*H/10)
  points.push(x+3*W/10, y+0*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+3*W/10, y+0*H/10)
  points.push(x+3*W/10, y+0*H/10)
  cpx = x+3*W/10
  cpy = y+2*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/10, y+2*H/10)
  points.push(x+0*W/10, y+2*H/10)
  cpx = x+0*W/10
  cpy = y+0*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/10, y+0*H/10)
  points.push(x+3*W/10, y+0*H/10)
  cpx = x+3*W/10
  cpy = y+1*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/10, y+1*H/10)
  points.push(x+4*W/10, y+1*H/10)
  cpx = x+4*W/10
  cpy = y+0*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/10, y+0*H/10)
  points.push(x+3*W/10, y+0*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/10, y+2*H/10)
  points.push(x+5*W/10, y+2*H/10)
  cpx = x+2*W/10
  cpy = y+2*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/10, y+4*H/10)
  points.push(x+2*W/10, y+4*H/10)
  cpx = x+5*W/10
  cpy = y+4*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+2*H/10)
  points.push(x+5*W/10, y+2*H/10)
  cpx = x+4*W/10
  cpy = y+2*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/10, y+0*H/10)
  points.push(x+4*W/10, y+0*H/10)
  cpx = x+5*W/10
  cpy = y+0*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+2*H/10)
  points.push(x+5*W/10, y+2*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/10, y+2*H/10)
  points.push(x+6*W/10, y+2*H/10)
  cpx = x+5*W/10
  cpy = y+1*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+0*H/10)
  points.push(x+5*W/10, y+0*H/10)
  cpx = x+6*W/10
  cpy = y+1*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+2*H/10)
  points.push(x+6*W/10, y+2*H/10)
  cpx = x+6*W/10
  cpy = y+0*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/10, y+0*H/10)
  points.push(x+8*W/10, y+0*H/10)
  cpx = x+8*W/10
  cpy = y+2*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+2*H/10)
  points.push(x+6*W/10, y+2*H/10)
  cpx = x+5*W/10
  cpy = y+2*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+5*H/10)
  points.push(x+5*W/10, y+5*H/10)
  cpx = x+7*W/10
  cpy = y+4*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+2*H/10)
  points.push(x+6*W/10, y+2*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/10, y+10*H/10)
  points.push(x+2*W/10, y+10*H/10)
  cpx = x+2*W/10
  cpy = y+7*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/10, y+7*H/10)
  points.push(x+0*W/10, y+7*H/10)
  cpx = x+0*W/10
  cpy = y+10*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/10, y+10*H/10)
  points.push(x+2*W/10, y+10*H/10)
  cpx = x+2*W/10
  cpy = y+8*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/10, y+8*H/10)
  points.push(x+4*W/10, y+8*H/10)
  cpx = x+4*W/10
  cpy = y+10*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/10, y+10*H/10)
  points.push(x+2*W/10, y+10*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/10, y+7*H/10)
  points.push(x+4*W/10, y+7*H/10)
  cpx = x+4*W/10
  cpy = y+4*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/10, y+4*H/10)
  points.push(x+1*W/10, y+4*H/10)
  cpx = x+1*W/10
  cpy = y+7*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/10, y+7*H/10)
  points.push(x+4*W/10, y+7*H/10)
  cpx = x+4*W/10
  cpy = y+9*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+9*H/10)
  points.push(x+6*W/10, y+9*H/10)
  cpx = x+6*W/10
  cpy = y+7*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/10, y+7*H/10)
  points.push(x+4*W/10, y+7*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+8*W/10, y+4*H/10)
  points.push(x+8*W/10, y+4*H/10)
  cpx = x+8*W/10
  cpy = y+1*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/10, y+1*H/10)
  points.push(x+10*W/10, y+1*H/10)
  cpx = x+10*W/10
  cpy = y+4*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/10, y+4*H/10)
  points.push(x+8*W/10, y+4*H/10)
  cpx = x+7*W/10
  cpy = y+4*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/10, y+3*H/10)
  points.push(x+7*W/10, y+3*H/10)
  cpx = x+8*W/10
  cpy = y+3*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/10, y+4*H/10)
  points.push(x+8*W/10, y+4*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+8*W/10, y+5*H/10)
  points.push(x+8*W/10, y+5*H/10)
  cpx = x+8*W/10
  cpy = y+8*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/10, y+8*H/10)
  points.push(x+10*W/10, y+8*H/10)
  cpx = x+10*W/10
  cpy = y+5*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/10, y+5*H/10)
  points.push(x+8*W/10, y+5*H/10)
  cpx = x+5*W/10
  cpy = y+5*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+7*H/10)
  points.push(x+5*W/10, y+7*H/10)
  cpx = x+8*W/10
  cpy = y+7*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/10, y+5*H/10)
  points.push(x+8*W/10, y+5*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/10, y+7*H/10)
  points.push(x+6*W/10, y+7*H/10)
  cpx = x+6*W/10
  cpy = y+8*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/10, y+8*H/10)
  points.push(x+7*W/10, y+8*H/10)
  cpx = x+7*W/10
  cpy = y+7*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+7*H/10)
  points.push(x+6*W/10, y+7*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+8*W/10, y+5*H/10)
  points.push(x+8*W/10, y+5*H/10)
  cpx = x+10*W/10
  cpy = y+5*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/10, y+4*H/10)
  points.push(x+10*W/10, y+4*H/10)
  cpx = x+8*W/10
  cpy = y+4*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/10, y+5*H/10)
  points.push(x+8*W/10, y+5*H/10)
  cpx = x+7*W/10
  cpy = y+5*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/10, y+4*H/10)
  points.push(x+7*W/10, y+4*H/10)
  cpx = x+8*W/10
  cpy = y+4*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/10, y+5*H/10)
  points.push(x+8*W/10, y+5*H/10)
  ctx.stroke()
  drawStars(x,y,W,points)
}

function firebirdAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+2*H/12)
  points.push(x+7*W/12, y+2*H/12)
  cpx = x+7*W/12
  cpy = y+1*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+1*H/12)
  points.push(x+8*W/12, y+1*H/12)
  cpx = x+9*W/12
  cpy = y+1*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+2*H/12)
  points.push(x+9*W/12, y+2*H/12)
  cpx = x+11*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+3*H/12)
  points.push(x+12*W/12, y+3*H/12)
  cpx = x+11*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+3*H/12)
  points.push(x+9*W/12, y+3*H/12)
  cpx = x+9*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+9*H/12)
  points.push(x+4*W/12, y+9*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+2*H/12)
  points.push(x+7*W/12, y+2*H/12)
  cpx = x+7*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+3*H/12)
  points.push(x+5*W/12, y+3*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+3*H/12)
  points.push(x+5*W/12, y+3*H/12)
  cpx = x+5*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/12, y+0*H/12)
  points.push(x+1*W/12, y+0*H/12)
  cpx = x+1*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+3*H/12)
  points.push(x+5*W/12, y+3*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+4*H/12)
  points.push(x+5*W/12, y+4*H/12)
  cpx = x+5*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+3*H/12)
  points.push(x+3*W/12, y+3*H/12)
  cpx = x+1*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+4*H/12)
  points.push(x+0*W/12, y+4*H/12)
  cpx = x+1*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+5*H/12)
  points.push(x+3*W/12, y+5*H/12)
  cpx = x+5*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+4*H/12)
  points.push(x+5*W/12, y+4*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+5*H/12)
  points.push(x+5*W/12, y+5*H/12)
  cpx = x+2*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+7*H/12)
  points.push(x+2*W/12, y+7*H/12)
  cpx = x+5*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+5*H/12)
  points.push(x+5*W/12, y+5*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/12, y+9*H/12)
  points.push(x+4*W/12, y+9*H/12)
  cpx = x+4*W/12
  cpy = y+12*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+12*H/12)
  points.push(x+0*W/12, y+12*H/12)
  cpx = x+0*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+9*H/12)
  points.push(x+4*W/12, y+9*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+7*H/12)
  points.push(x+5*W/12, y+7*H/12)
  cpx = x+5*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+9*H/12)
  points.push(x+2*W/12, y+9*H/12)
  cpx = x+2*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+7*H/12)
  points.push(x+5*W/12, y+7*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/12, y+6*H/12)
  points.push(x+2*W/12, y+6*H/12)
  cpx = x+0*W/12
  cpy = y+6*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+5*H/12)
  points.push(x+0*W/12, y+5*H/12)
  cpx = x+2*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+6*H/12)
  points.push(x+2*W/12, y+6*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+8*H/12)
  points.push(x+7*W/12, y+8*H/12)
  cpx = x+11*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+11*W/12, y+9*H/12)
  points.push(x+11*W/12, y+9*H/12)
  cpx = x+11*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+10*H/12)
  points.push(x+10*W/12, y+10*H/12)
  cpx = x+11*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+9*H/12)
  points.push(x+10*W/12, y+9*H/12)
  cpx = x+11*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+8*H/12)
  points.push(x+7*W/12, y+8*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+9*H/12)
  points.push(x+5*W/12, y+9*H/12)
  cpx = x+9*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+10*H/12)
  points.push(x+9*W/12, y+10*H/12)
  cpx = x+9*W/12
  cpy = y+11*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+11*H/12)
  points.push(x+8*W/12, y+11*H/12)
  cpx = x+9*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+10*H/12)
  points.push(x+8*W/12, y+10*H/12)
  cpx = x+9*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+9*H/12)
  points.push(x+5*W/12, y+9*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+9*H/12)
  points.push(x+5*W/12, y+9*H/12)
  cpx = x+5*W/12
  cpy = y+11*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+11*H/12)
  points.push(x+4*W/12, y+11*H/12)
  cpx = x+4*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+9*H/12)
  points.push(x+5*W/12, y+9*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/12, y+7*H/12)
  points.push(x+2*W/12, y+7*H/12)
  cpx = x+2*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+10*H/12)
  points.push(x+0*W/12, y+10*H/12)
  cpx = x+0*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+7*H/12)
  points.push(x+2*W/12, y+7*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/12, y+6*H/12)
  points.push(x+2*W/12, y+6*H/12)
  cpx = x+0*W/12
  cpy = y+6*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+7*H/12)
  points.push(x+0*W/12, y+7*H/12)
  cpx = x+2*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+6*H/12)
  points.push(x+2*W/12, y+6*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/12, y+3*H/12)
  points.push(x+2*W/12, y+3*H/12)
  cpx = x+0*W/12
  cpy = y+2*H/12
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/12, y+3*H/12)
  points.push(x+2*W/12, y+3*H/12)
  cpx = x+2*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+2*H/12)
  points.push(x+0*W/12, y+2*H/12)
  cpx = x+0*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+3*H/12)
  points.push(x+2*W/12, y+3*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+8*H/12)
  points.push(x+6*W/12, y+8*H/12)
  cpx = x+5*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+9*H/12)
  points.push(x+5*W/12, y+9*H/12)
  cpx = x+6*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+8*H/12)
  points.push(x+6*W/12, y+8*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+4*H/12)
  points.push(x+6*W/12, y+4*H/12)
  cpx = x+6*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+3*H/12)
  points.push(x+5*W/12, y+3*H/12)
  cpx = x+5*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+4*H/12)
  points.push(x+6*W/12, y+4*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+2*H/12)
  points.push(x+7*W/12, y+2*H/12)
  cpx = x+8*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+2*H/12)
  points.push(x+9*W/12, y+2*H/12)
  cpx = x+8*W/12
  cpy = y+1*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+2*H/12)
  points.push(x+7*W/12, y+2*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+1*W/12, y+2*H/12)
  points.push(x+1*W/12, y+2*H/12)
  cpx = x+1*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+0*H/12)
  points.push(x+0*W/12, y+0*H/12)
  cpx = x+0*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/12, y+2*H/12)
  points.push(x+1*W/12, y+2*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/12, y+11*H/12)
  points.push(x+4*W/12, y+11*H/12)
  cpx = x+3*W/12
  cpy = y+11*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+12*H/12)
  points.push(x+3*W/12, y+12*H/12)
  cpx = x+4*W/12
  cpy = y+12*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+11*H/12)
  points.push(x+4*W/12, y+11*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+8*W/12, y+1*H/12)
  points.push(x+8*W/12, y+1*H/12)
  cpx = x+8*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+0*H/12)
  points.push(x+5*W/12, y+0*H/12)
  cpx = x+5*W/12
  cpy = y+1*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+1*H/12)
  points.push(x+8*W/12, y+1*H/12)
  ctx.stroke()
  // feather mid-lines below
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+4*H/12)
  points.push(x+6*W/12, y+4*H/12)
  ctx.lineTo(x+5*W/12, y+3*H/12)
  points.push(x+5*W/12, y+3*H/12)
  ctx.lineTo(x+1*W/12, y+0*H/12)
  points.push(x+1*W/12, y+0*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+4*H/12)
  points.push(x+5*W/12, y+4*H/12)
  ctx.lineTo(x+0*W/12, y+4*H/12)
  points.push(x+0*W/12, y+4*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/12, y+3*H/12)
  points.push(x+2*W/12, y+3*H/12)
  ctx.lineTo(x+0*W/12, y+2*H/12)
  points.push(x+0*W/12, y+2*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+1*W/12, y+2*H/12)
  points.push(x+1*W/12, y+2*H/12)
  ctx.lineTo(x+0*W/12, y+0*H/12)
  points.push(x+0*W/12, y+0*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+5*H/12)
  points.push(x+5*W/12, y+5*H/12)
  ctx.lineTo(x+2*W/12, y+7*H/12)
  points.push(x+2*W/12, y+7*H/12)
  ctx.lineTo(x+0*W/12, y+10*H/12)
  points.push(x+0*W/12, y+10*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/12, y+6*H/12)
  points.push(x+2*W/12, y+6*H/12)
  ctx.lineTo(x+0*W/12, y+7*H/12)
  points.push(x+0*W/12, y+7*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+5*H/12)
  points.push(x+0*W/12, y+5*H/12)
  ctx.lineTo(x+2*W/12, y+6*H/12)
  points.push(x+2*W/12, y+6*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+8*H/12)
  points.push(x+6*W/12, y+8*H/12)
  ctx.lineTo(x+5*W/12, y+9*H/12)
  points.push(x+5*W/12, y+9*H/12)
  ctx.lineTo(x+4*W/12, y+11*H/12)
  points.push(x+4*W/12, y+11*H/12)
  ctx.lineTo(x+3*W/12, y+12*H/12)
  points.push(x+3*W/12, y+12*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+7*H/12)
  points.push(x+5*W/12, y+7*H/12)
  ctx.lineTo(x+2*W/12, y+9*H/12)
  points.push(x+2*W/12, y+9*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/12, y+9*H/12)
  points.push(x+4*W/12, y+9*H/12)
  ctx.lineTo(x+0*W/12, y+12*H/12)
  points.push(x+0*W/12, y+12*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+8*W/12, y+1*H/12)
  points.push(x+8*W/12, y+1*H/12)
  ctx.lineTo(x+5*W/12, y+0*H/12)
  points.push(x+5*W/12, y+0*H/12)
  ctx.stroke()
  drawStars(x,y,W,points)
}

function face2At (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+12*H/12)
  points.push(x+7*W/12, y+12*H/12)
  cpx = x+7*W/12
  cpy = y+11*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+11*H/12)
  points.push(x+9*W/12, y+11*H/12)
  cpx = x+11*W/12
  cpy = y+11*H/12
  //ctx.quadraticCurveTo(cpx, cpy, x+11*W/12, y+7*H/12)
  points.push(x+11*W/12, y+7*H/12)
  cpx = x+11*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+2*H/12)
  points.push(x+9*W/12, y+2*H/12)
  cpx = x+1*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/12, y+11*H/12)
  points.push(x+1*W/12, y+11*H/12)
  cpx = x+1*W/12
  cpy = y+12*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+12*H/12)
  points.push(x+0*W/12, y+12*H/12)
  //ctx.stroke()
  
  
  ctx.beginPath()
  ctx.moveTo(x+9*W/12, y+2*H/12)
  points.push(x+9*W/12, y+2*H/12)
  cpx = x+9*W/12
  cpy = y+1*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/12, y+1*H/12)
  points.push(x+1*W/12, y+1*H/12)
  cpx = x+0*W/12
  cpy = y+1*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+10*H/12)
  points.push(x+0*W/12, y+10*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+9*W/12, y+2*H/12)
  points.push(x+9*W/12, y+2*H/12)
  cpx = x+9*W/12
  cpy = y+1*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+1*H/12)
  points.push(x+8*W/12, y+1*H/12)
  cpx = x+1*W/12
  cpy = y+1*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+10*H/12)
  points.push(x+0*W/12, y+10*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+8*W/12, y+1*H/12)
  points.push(x+8*W/12, y+1*H/12)
  cpx = x+8*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+0*H/12)
  points.push(x+7*W/12, y+0*H/12)
  cpx = x+0*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+10*H/12)
  points.push(x+0*W/12, y+10*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+5*H/12)
  points.push(x+5*W/12, y+5*H/12)
  cpx = x+3*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+6*H/12)
  points.push(x+3*W/12, y+6*H/12)
  cpx = x+3*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+7*H/12)
  points.push(x+5*W/12, y+7*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+3*W/12, y+1*H/12)
  points.push(x+3*W/12, y+1*H/12)
  cpx = x+3*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+0*H/12)
  points.push(x+2*W/12, y+0*H/12)
  cpx = x+0*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+10*H/12)
  points.push(x+0*W/12, y+10*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+6*H/12)
  points.push(x+6*W/12, y+6*H/12)
  cpx = x+7*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+6*H/12)
  points.push(x+8*W/12, y+6*H/12)
  cpx = x+7*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+6*H/12)
  points.push(x+6*W/12, y+6*H/12)
  cpx = x+9*W/12
  cpy = y+6*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+6*H/12)
  points.push(x+9*W/12, y+6*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+9*W/12, y+6*H/12)
  points.push(x+9*W/12, y+6*H/12)
  cpx = x+10*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+11*W/12, y+6*H/12)
  points.push(x+11*W/12, y+6*H/12)
  cpx = x+10*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+6*H/12)
  points.push(x+9*W/12, y+6*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+8*W/12, y+6*H/12)
  points.push(x+8*W/12, y+6*H/12)
  cpx = x+9*W/12
  cpy = y+6*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+8*H/12)
  points.push(x+9*W/12, y+8*H/12)
  cpx = x+9*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+9*H/12)
  points.push(x+8*W/12, y+9*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+10*H/12)
  points.push(x+7*W/12, y+10*H/12)
  cpx = x+9*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+9*H/12)
  points.push(x+9*W/12, y+9*H/12)
  cpx = x+9*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+10*H/12)
  points.push(x+7*W/12, y+10*H/12)
  cpx = x+9*W/12
  cpy = y+11*H/12
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+10*H/12)
  points.push(x+7*W/12, y+10*H/12)
  cpx = x+9*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+11*H/12)
  points.push(x+9*W/12, y+11*H/12)
  ctx.stroke()
  drawStars(x,y,W,points)
}

function floppyAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+0*W/16, y+1*H/16)
points.push(x+0*W/16, y+1*H/16)
  cpx = x+0*W/16
  cpy = y+0*H/16
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/16, y+0*H/16)
  ctx.lineTo(x+14*W/16, y+0*H/16)
points.push(x+14*W/16, y+0*H/16)
  ctx.lineTo(x+16*W/16, y+2*H/16)
points.push(x+16*W/16, y+2*H/16)
  ctx.lineTo(x+16*W/16, y+15*H/16)
points.push(x+16*W/16, y+15*H/16)
  cpx = x+16*W/16
  cpy = y+16*H/16
  ctx.quadraticCurveTo(cpx, cpy, x+15*W/16, y+16*H/16)
  ctx.lineTo(x+1*W/16, y+16*H/16)
points.push(x+1*W/16, y+16*H/16)
  cpx = x+0*W/16
  cpy = y+16*H/16
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/16, y+15*H/16)
  ctx.lineTo(x+0*W/16, y+1*H/16)
points.push(x+0*W/16, y+1*H/16)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/16, y+0*H/16)
points.push(x+2*W/16, y+0*H/16)
  ctx.lineTo(x+2*W/16, y+4*H/16)
points.push(x+2*W/16, y+4*H/16)
  cpx = x+2*W/16
  cpy = y+5*H/16
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/16, y+5*H/16)
  ctx.lineTo(x+10*W/16, y+5*H/16)
points.push(x+10*W/16, y+5*H/16)
  cpx = x+11*W/16
  cpy = y+5*H/16
  ctx.quadraticCurveTo(cpx, cpy, x+11*W/16, y+4*H/16)
  ctx.lineTo(x+11*W/16, y+0*H/16)
points.push(x+11*W/16, y+0*H/16)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+3*W/16, y+6*H/16)
points.push(x+3*W/16, y+6*H/16)
  cpx = x+2*W/16
  cpy = y+6*H/16
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/16, y+7*H/16)
  ctx.lineTo(x+2*W/16, y+14*H/16)
points.push(x+2*W/16, y+14*H/16)
  cpx = x+2*W/16
  cpy = y+15*H/16
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/16, y+15*H/16)
  ctx.lineTo(x+13*W/16, y+15*H/16)
points.push(x+13*W/16, y+15*H/16)
  cpx = x+14*W/16
  cpy = y+15*H/16
  ctx.quadraticCurveTo(cpx, cpy, x+14*W/16, y+14*H/16)
  ctx.lineTo(x+14*W/16, y+7*H/16)
points.push(x+14*W/16, y+7*H/16)
  cpx = x+14*W/16
  cpy = y+6*H/16
  ctx.quadraticCurveTo(cpx, cpy, x+13*W/16, y+6*H/16)
  ctx.lineTo(x+3*W/16, y+6*H/16)
points.push(x+3*W/16, y+6*H/16)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+10*W/16, y+4*H/16)
points.push(x+10*W/16, y+4*H/16)
  ctx.lineTo(x+8*W/16, y+4*H/16)
points.push(x+8*W/16, y+4*H/16)
  ctx.lineTo(x+8*W/16, y+1*H/16)
points.push(x+8*W/16, y+1*H/16)
  ctx.lineTo(x+10*W/16, y+1*H/16)
points.push(x+10*W/16, y+1*H/16)
  ctx.lineTo(x+10*W/16, y+4*H/16)
points.push(x+10*W/16, y+4*H/16)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+3*W/16, y+12*H/16)
points.push(x+3*W/16, y+12*H/16)
  ctx.lineTo(x+13*W/16, y+12*H/16)
points.push(x+13*W/16, y+12*H/16)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+3*W/16, y+10*H/16)
points.push(x+3*W/16, y+10*H/16)
  ctx.lineTo(x+13*W/16, y+10*H/16)
points.push(x+13*W/16, y+10*H/16)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+3*W/16, y+8*H/16)
points.push(x+3*W/16, y+8*H/16)
  ctx.lineTo(x+13*W/16, y+8*H/16)
points.push(x+13*W/16, y+8*H/16)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/16, y+0*H/16)
points.push(x+4*W/16, y+0*H/16)
  ctx.lineTo(x+4*W/16, y+4*H/16)
points.push(x+4*W/16, y+4*H/16)
  cpx = x+4*W/16
  cpy = y+5*H/16
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/16, y+5*H/16)
  ctx.stroke()
  drawStars(x,y,W,points)
}

function pantsAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+0*W/9, y+7*H/9)
  cpx = x+3*W/9
  cpy = y+7*H/9
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/9, y+9*H/9)
  cpx = x+1*W/9
  cpy = y+9*H/9
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/9, y+7*H/9)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/9, y+9*H/9)
  cpx = x+8*W/9
  cpy = y+9*H/9
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/9, y+7*H/9)
  cpx = x+6*W/9
  cpy = y+7*H/9
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/9, y+9*H/9)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/9, y+9*H/9)
  ctx.lineTo(x+4*W/9, y+5*H/9)
  ctx.lineTo(x+5*W/9, y+5*H/9)
  ctx.lineTo(x+5*W/9, y+9*H/9)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+0*W/9, y+7*H/9)
  ctx.lineTo(x+0*W/9, y+1*H/9)
  ctx.lineTo(x+9*W/9, y+1*H/9)
  ctx.lineTo(x+9*W/9, y+7*H/9)
  ctx.stroke()
}

function spiralAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+7*H/12)
  points.push(x+7*W/12, y+7*H/12)
  cpx = x+7*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+8*H/12)
  points.push(x+6*W/12, y+8*H/12)
  cpx = x+5*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+7*H/12)
  points.push(x+5*W/12, y+7*H/12)
  cpx = x+5*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+5*H/12)
  points.push(x+7*W/12, y+5*H/12)
  cpx = x+9*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+7*H/12)
  points.push(x+9*W/12, y+7*H/12)
  cpx = x+9*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+10*H/12)
  points.push(x+6*W/12, y+10*H/12)
  cpx = x+3*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+7*H/12)
  points.push(x+3*W/12, y+7*H/12)
  cpx = x+3*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+3*H/12)
  points.push(x+7*W/12, y+3*H/12)
  cpx = x+11*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+11*W/12, y+7*H/12)
  points.push(x+11*W/12, y+7*H/12)
  cpx = x+11*W/12
  cpy = y+12*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+12*H/12)
  points.push(x+6*W/12, y+12*H/12)
  cpx = x+1*W/12
  cpy = y+12*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/12, y+6*H/12)
  points.push(x+1*W/12, y+6*H/12)
  cpx = x+1*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+0*H/12)
  points.push(x+6*W/12, y+0*H/12)
  ctx.stroke()
  // extra arm part
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+0*H/12)
  points.push(x+6*W/12, y+0*H/12)
  cpx = x+12*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+3*H/12)
  points.push(x+12*W/12, y+3*H/12)
  ctx.stroke()
  drawStars(x,y,W,points)
}

function mushroomAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+0*W/10, y+4*H/10)
  cpx = x+0*W/10
  cpy = y+0*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+0*H/10)
  cpx = x+10*W/10
  cpy = y+0*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/10, y+4*H/10)
  cpx = x+10*W/10
  cpy = y+2*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+2*H/10)
  cpx = x+0*W/10
  cpy = y+2*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/10, y+4*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/10, y+4*H/10)
  cpx = x+5*W/10
  cpy = y+7*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/10, y+10*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/10, y+4*H/10)
  cpx = x+5*W/10
  cpy = y+7*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/10, y+10*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/10, y+4*H/10)
  cpx = x+5*W/10
  cpy = y+3*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+4*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+0*W/10, y+4*H/10)
  cpx = x+0*W/10
  cpy = y+5*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/10, y+5*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+10*W/10, y+4*H/10)
  cpx = x+10*W/10
  cpy = y+5*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+5*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+3*W/10, y+10*H/10)
  cpx = x+5*W/10
  cpy = y+10*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/10, y+10*H/10)
  ctx.stroke()
}

function catAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+5*W/9, y+2*H/9)
  cpx = x+0*W/9
  cpy = y+2*H/9
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/9, y+8*H/9)
  cpx = x+0*W/9
  cpy = y+9*H/9
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/9, y+9*H/9)
  ctx.lineTo(x+6*W/9, y+9*H/9)
  cpx = x+6*W/9
  cpy = y+8*H/9
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/9, y+8*H/9)
  ctx.lineTo(x+4*W/9, y+8*H/9)
  cpx = x+4*W/9
  cpy = y+6*H/9
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/9, y+6*H/9)
  ctx.stroke()
  ctx.beginPath() // face
  ctx.moveTo(x+5*W/9, y+0*H/9)
  ctx.lineTo(x+5*W/9, y+2*H/9)
  cpx = x+5*W/9
  cpy = y+4*H/9
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/9, y+4*H/9)
  cpx = x+9*W/9
  cpy = y+4*H/9
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/9, y+2*H/9)
  ctx.lineTo(x+9*W/9, y+0*H/9)
  ctx.lineTo(x+8*W/9, y+1*H/9)
  cpx = x+7*W/9
  cpy = y+0*H/9
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/9, y+1*H/9)
  ctx.lineTo(x+5*W/9, y+0*H/9)
  ctx.stroke()
  
  ctx.beginPath() // left front leg
  ctx.moveTo(x+5*W/9, y+5*H/9)
  ctx.lineTo(x+5*W/9, y+8*H/9)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/9, y+6*H/9)
  ctx.lineTo(x+6*W/9, y+9*H/9)
  ctx.stroke()

  ctx.beginPath()
  ctx.moveTo(x+8*W/9, y+7*H/9)
  cpx = x+8*W/9
  cpy = y+8*H/9
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/9, y+8*H/9)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+6*W/9, y+2*H/9)
  cpx = x+7*W/9
  cpy = y+2*H/9
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/9, y+3*H/9)
  cpx = x+7*W/9
  cpy = y+2*H/9
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/9, y+2*H/9)
  ctx.stroke()
  
  //right leg
  ctx.beginPath()
  ctx.moveTo(x+8*W/9, y+4*H/9)
  cpx = x+9*W/9
  cpy = y+4*H/9
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/9, y+5*H/9)
  ctx.lineTo(x+9*W/9, y+9*H/9)
  cpx = x+8*W/9
  cpy = y+9*H/9
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/9, y+8*H/9)
  ctx.lineTo(x+8*W/9, y+6*H/9)
  ctx.stroke()
  
  // tail
  ctx.beginPath()
  ctx.moveTo(x+0*W/9, y+7*H/9)
  ctx.lineTo(x+0*W/9, y+0*H/9)
  cpx = x+1*W/9
  cpy = y+0*H/9
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/9, y+1*H/9)
  ctx.lineTo(x+1*W/9, y+3.8*H/9)
  ctx.stroke()
  
}

function mailboxAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+12*H/12)
  ctx.lineTo(x+0*W/12, y+7*H/12)
  ctx.lineTo(x+1*W/12, y+6*H/12)
  ctx.lineTo(x+2*W/12, y+5*H/12)
  ctx.lineTo(x+4*W/12, y+5*H/12)
  ctx.lineTo(x+6*W/12, y+7*H/12)
  ctx.lineTo(x+6*W/12, y+12*H/12)
  ctx.lineTo(x+0*W/12, y+12*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+12*H/12)
  ctx.lineTo(x+12*W/12, y+7*H/12)
  ctx.lineTo(x+12*W/12, y+2*H/12)
  ctx.lineTo(x+10*W/12, y+0*H/12)
  ctx.lineTo(x+8*W/12, y+0*H/12)
  ctx.lineTo(x+2*W/12, y+5*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/12, y+5*H/12)
  ctx.lineTo(x+10*W/12, y+0*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+7*H/12)
  ctx.lineTo(x+12*W/12, y+2*H/12)
  ctx.stroke()
  ctx.beginPath() // flag
  ctx.moveTo(x+7*W/12, y+8*H/12)
  ctx.lineTo(x+7*W/12, y+4*H/12)
  ctx.lineTo(x+8*W/12, y+3*H/12)
  ctx.lineTo(x+8*W/12, y+4*H/12)
  ctx.lineTo(x+7*W/12, y+5*H/12)
  ctx.stroke()
  // 30
  ctx.beginPath()
  ctx.moveTo(x+8*W/12, y+7*H/12)
  ctx.lineTo(x+9*W/12, y+6*H/12)
  ctx.lineTo(x+9*W/12, y+7*H/12)
  ctx.lineTo(x+8*W/12, y+8*H/12)
  ctx.lineTo(x+9*W/12, y+7*H/12)
  ctx.lineTo(x+9*W/12, y+8*H/12)
  ctx.lineTo(x+8*W/12, y+9*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+10*W/12, y+5*H/12)
  ctx.lineTo(x+11*W/12, y+4*H/12)
  ctx.lineTo(x+11*W/12, y+6*H/12)
  ctx.lineTo(x+10*W/12, y+7*H/12)
  ctx.lineTo(x+10*W/12, y+5*H/12)
  ctx.stroke()
}

function flameAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+8*H/12)
  cpx = x+0*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+0*H/12)
  cpx = x+4*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+6*H/12)
  cpx = x+4*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+0*H/12)
  cpx = x+8*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+6*H/12)
  cpx = x+8*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+0*H/12)
  cpx = x+12*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+8*H/12)
  cpx = x+12*W/12
  cpy = y+12*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+12*H/12)
  cpx = x+0*W/12
  cpy = y+12*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+8*H/12)
  ctx.stroke()
}

function elephantAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+2*W/12, y+10*H/12)
  points.push(x+2*W/12, y+10*H/12)
  cpx = x+1*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+6*H/12)
  points.push(x+0*W/12, y+6*H/12)
  cpx = x+0*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+2*H/12)
  points.push(x+2*W/12, y+2*H/12)
  cpx = x+8*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+3*H/12)
  points.push(x+8*W/12, y+3*H/12)
  cpx = x+10*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+11*W/12, y+8*H/12)
  points.push(x+11*W/12, y+8*H/12)
  cpx = x+11*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+10*H/12)
  points.push(x+12*W/12, y+10*H/12)
  cpx = x+11*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+7*H/12)
  points.push(x+9*W/12, y+7*H/12)
  cpx = x+8*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+10*H/12)
  points.push(x+8*W/12, y+10*H/12)
  cpx = x+7*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+8*H/12)
  points.push(x+7*W/12, y+8*H/12)
  cpx = x+5*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+8*H/12)
  points.push(x+3*W/12, y+8*H/12)
  cpx = x+2*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+10*H/12)
  points.push(x+2*W/12, y+10*H/12)
  ctx.stroke()
  // ear
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+4*H/12)
  points.push(x+7*W/12, y+4*H/12)
  cpx = x+7*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+3*H/12)
  points.push(x+6*W/12, y+3*H/12)
  cpx = x+5*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+6*H/12)
  points.push(x+6*W/12, y+6*H/12)
  cpx = x+7*W/12
  cpy = y+6*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+5*H/12)
  points.push(x+7*W/12, y+5*H/12)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+3*W/12, y+8*H/12)
  points.push(x+3*W/12, y+8*H/12)
  cpx = x+3*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+10*H/12)
  points.push(x+4*W/12, y+10*H/12)
  cpx = x+4*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+8*H/12)
  points.push(x+5*W/12, y+8*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+8*H/12)
  points.push(x+6*W/12, y+8*H/12)
  cpx = x+6*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+10*H/12)
  points.push(x+7*W/12, y+10*H/12)
  cpx = x+7*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+8*H/12)
  points.push(x+8*W/12, y+8*H/12)
  ctx.stroke()
  drawStars(x,y,W,points)
}

function cactusAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy
  let points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+6*W/14, y+14*H/14)
points.push(x+6*W/14, y+14*H/14)
  cpx = x+6*W/14
  cpy = y+12*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/14, y+12*H/14)
points.push( x+4*W/14, y+12*H/14)
  cpx = x+2*W/14
  cpy = y+12*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/14, y+10*H/14)
points.push( x+2*W/14, y+10*H/14)
  cpx = x+2*W/14
  cpy = y+4*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/14, y+3*H/14)
points.push( x+2*W/14, y+3*H/14)
  cpx = x+3*W/14
  cpy = y+2*H/14
  ctx.arc(x+3*W/14, y+3*H/14, W/14, Math.PI, Math.PI*2)
  //ctx.quadraticCurveTo(cpx, cpy, x+4*W/14, y+3*H/14)
  cpx = x+4*W/14
  cpy = y+9*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/14, y+9*H/14)
points.push( x+4*W/14, y+9*H/14)
  cpx = x+5*W/14
  cpy = y+11*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/14, y+9*H/14)
points.push( x+6*W/14, y+9*H/14)
  cpx = x+6*W/14
  cpy = y+1*H/14
  ctx.arc(x+7*W/14, y+1*H/14, W/14, Math.PI, Math.PI*2)
  //ctx.quadraticCurveTo(cpx, cpy, x+6*W/14, y+1*H/14)
  cpx = x+8*W/14
  cpy = y+1*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/14, y+1*H/14)
points.push( x+8*W/14, y+1*H/14)
  cpx = x+8*W/14
  cpy = y+10*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/14, y+10*H/14)
points.push( x+8*W/14, y+10*H/14)
  cpx = x+9*W/14
  cpy = y+12*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/14, y+10*H/14)
points.push( x+10*W/14, y+10*H/14)
  cpx = x+10*W/14
  cpy = y+4*H/14

  ctx.arc(x+11*W/14, y+4*H/14, W/14, Math.PI, Math.PI*2)
  cpx = x+12*W/14
  cpy = y+4*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/14, y+4*H/14)
points.push( x+12*W/14, y+4*H/14)
  cpx = x+12*W/14
  cpy = y+10*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/14, y+10*H/14)
points.push( x+12*W/14, y+10*H/14)
  cpx = x+12*W/14
  cpy = y+12*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/14, y+13*H/14)
points.push( x+10*W/14, y+13*H/14)
  cpx = x+8*W/14
  cpy = y+13*H/14
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/14, y+14*H/14)
points.push( x+8*W/14, y+14*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+12*W/14, y+10*H/14)
points.push(x+12*W/14, y+10*H/14)
  cpx = x+13*W/14
  cpy = y+11*H/14
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+12*W/14, y+10*H/14)
points.push(x+12*W/14, y+10*H/14)
  ctx.lineTo(x+13*W/14, y+11*H/14)
points.push(x+13*W/14, y+11*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+12*W/14, y+10*H/14)
points.push(x+12*W/14, y+10*H/14)
  ctx.lineTo(x+13*W/14, y+9*H/14)
points.push(x+13*W/14, y+9*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+12*W/14, y+7*H/14)
points.push(x+12*W/14, y+7*H/14)
  ctx.lineTo(x+13*W/14, y+8*H/14)
points.push(x+13*W/14, y+8*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+12*W/14, y+7*H/14)
points.push(x+12*W/14, y+7*H/14)
  ctx.lineTo(x+13*W/14, y+6*H/14)
points.push(x+13*W/14, y+6*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+13*W/14, y+5*H/14)
points.push(x+13*W/14, y+5*H/14)
  ctx.lineTo(x+12*W/14, y+4*H/14)
points.push(x+12*W/14, y+4*H/14)
  ctx.lineTo(x+13*W/14, y+3*H/14)
points.push(x+13*W/14, y+3*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+10*W/14, y+2*H/14)
points.push(x+10*W/14, y+2*H/14)
  ctx.lineTo(x+11*W/14, y+3*H/14)
points.push(x+11*W/14, y+3*H/14)
  ctx.lineTo(x+12*W/14, y+2*H/14)
points.push(x+12*W/14, y+2*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+1*W/14, y+11*H/14)
points.push(x+1*W/14, y+11*H/14)
  ctx.lineTo(x+2*W/14, y+10*H/14)
points.push(x+2*W/14, y+10*H/14)
  ctx.lineTo(x+1*W/14, y+9*H/14)
points.push(x+1*W/14, y+9*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+1*W/14, y+8*H/14)
points.push(x+1*W/14, y+8*H/14)
  ctx.lineTo(x+2*W/14, y+7*H/14)
points.push(x+2*W/14, y+7*H/14)
  ctx.lineTo(x+1*W/14, y+6*H/14)
points.push(x+1*W/14, y+6*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+1*W/14, y+5*H/14)
points.push(x+1*W/14, y+5*H/14)
  ctx.lineTo(x+2*W/14, y+4*H/14)
points.push(x+2*W/14, y+4*H/14)
  ctx.lineTo(x+1*W/14, y+3*H/14)
points.push(x+1*W/14, y+3*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/14, y+1*H/14)
points.push(x+2*W/14, y+1*H/14)
  ctx.lineTo(x+3*W/14, y+2*H/14)
points.push(x+3*W/14, y+2*H/14)
  ctx.lineTo(x+4*W/14, y+1*H/14)
points.push(x+4*W/14, y+1*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/14, y+13*H/14)
points.push(x+2*W/14, y+13*H/14)
  ctx.lineTo(x+3*W/14, y+12*H/14)
points.push(x+3*W/14, y+12*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+11*W/14, y+12*H/14)
points.push(x+11*W/14, y+12*H/14)
  ctx.lineTo(x+12*W/14, y+13*H/14)
points.push(x+12*W/14, y+13*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/14, y+9*H/14)
points.push(x+4*W/14, y+9*H/14)
  ctx.lineTo(x+5*W/14, y+8*H/14)
points.push(x+5*W/14, y+8*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+8*W/14, y+10*H/14)
points.push(x+8*W/14, y+10*H/14)
  ctx.lineTo(x+9*W/14, y+9*H/14)
points.push(x+9*W/14, y+9*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+9*W/14, y+0*H/14)
points.push(x+9*W/14, y+0*H/14)
  ctx.lineTo(x+8*W/14, y+1*H/14)
points.push(x+8*W/14, y+1*H/14)
  ctx.lineTo(x+9*W/14, y+2*H/14)
points.push(x+9*W/14, y+2*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/14, y+2*H/14)
points.push(x+5*W/14, y+2*H/14)
  ctx.lineTo(x+6*W/14, y+1*H/14)
points.push(x+6*W/14, y+1*H/14)
  ctx.lineTo(x+5*W/14, y+0*H/14)
points.push(x+5*W/14, y+0*H/14)
  ctx.stroke()
  ctx.beginPath() // split this?
  ctx.moveTo(x+6*W/14, y+6*H/14)
points.push(x+6*W/14, y+6*H/14)
  ctx.lineTo(x+5*W/14, y+7*H/14)
points.push(x+5*W/14, y+7*H/14)
  
  ctx.stroke()
  ctx.beginPath()
  ctx.lineTo(x+4*W/14, y+6*H/14)
points.push(x+4*W/14, y+6*H/14)
  ctx.lineTo(x+5*W/14, y+5*H/14)
points.push(x+5*W/14, y+5*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/14, y+3*H/14)
points.push(x+6*W/14, y+3*H/14)
  ctx.lineTo(x+5*W/14, y+4*H/14)
points.push(x+5*W/14, y+4*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+10*W/14, y+7*H/14)
points.push(x+10*W/14, y+7*H/14)
  ctx.lineTo(x+9*W/14, y+8*H/14)
points.push(x+9*W/14, y+8*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+8*W/14, y+7*H/14)
points.push(x+8*W/14, y+7*H/14)
  ctx.lineTo(x+9*W/14, y+6*H/14)
points.push(x+9*W/14, y+6*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+10*W/14, y+4*H/14)
points.push(x+10*W/14, y+4*H/14)
  ctx.lineTo(x+9*W/14, y+5*H/14)
points.push(x+9*W/14, y+5*H/14)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+8*W/14, y+4*H/14)
points.push(x+8*W/14, y+4*H/14)
  ctx.lineTo(x+9*W/14, y+3*H/14)
points.push(x+9*W/14, y+3*H/14)
  ctx.stroke()
  drawStars(x,y,W,points,0.5)
}

function fishAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+10*W/10, y+6*H/10)
  cpx = x+8*W/10
  cpy = y+4*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+4*H/10)
  cpx = x+3*W/10
  cpy = y+4*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/10, y+6*H/10)
  cpx = x+3*W/10
  cpy = y+8*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+8*H/10)
  cpx = x+9*W/10
  cpy = y+8*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/10, y+6*H/10)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+0*W/10, y+4*H/10)
  cpx = x+1*W/10
  cpy = y+4*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/10, y+6*H/10)
  cpx = x+1*W/10
  cpy = y+8*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/10, y+8*H/10)
  ctx.lineTo(x+0*W/10, y+7*H/10)
  ctx.lineTo(x+0*W/10, y+4*H/10)
  ctx.stroke()
  // eye
  ctx.beginPath()
  ctx.arc(x+8*W/10, y+6*H/10, W/20, 0, Math.PI*2)
  ctx.stroke()
  // upper waves
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+0*H/12)
  cpx = x+1*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+0*H/12)
  cpx = x+3*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+0*H/12)
  cpx = x+5*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+0*H/12)
  cpx = x+7*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+0*H/12)
  cpx = x+9*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+0*H/12)
  cpx = x+11*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+0*H/12)
  ctx.stroke()
}

function birbAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  let points = []
  ctx.beginPath()
  ctx.moveTo(x+7*W/12, y+3*H/12)
  cpx = x+7*W/12
  cpy = y+1*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+1*H/12)
  cpx = x+7*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+0*H/12)
  cpx = x+5*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+3*H/12)
  cpx = x+0*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+9*H/12)
  cpx = x+5*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+7*H/12)
  cpx = x+5*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+11*H/12)
  cpx = x+6*W/12
  cpy = y+12*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+11*H/12)
  cpx = x+7*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+7*H/12)
  cpx = x+7*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+9*H/12)
  cpx = x+12*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+3*H/12)
  ctx.stroke()
  ctx.beginPath()

  ctx.arc(x+6.25*W/12, y+1*H/12, W/24, 0, Math.PI*2)
  ctx.stroke()
}

function appleAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+4*W/8, y+7*H/8)
  cpx = x+4*W/8
  cpy = y+8*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/8, y+8*H/8)
  cpx = x+0*W/8
  cpy = y+7*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/8, y+4*H/8)
  cpx = x+0*W/8
  cpy = y+2*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/8, y+2*H/8)
  cpx = x+4*W/8
  cpy = y+2*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/8, y+4*H/8)
  cpx = x+4*W/8
  cpy = y+2*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/8, y+2*H/8)
  cpx = x+8*W/8
  cpy = y+2*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/8, y+4*H/8)
  cpx = x+8*W/8
  cpy = y+7*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/8, y+8*H/8)
  cpx = x+4*W/8
  cpy = y+8*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/8, y+7*H/8)
  ctx.stroke()
  // stem
  ctx.beginPath()
  ctx.moveTo(x+4*W/8, y+4*H/8)
  cpx = x+4*W/8
  cpy = y+2*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/8, y+0*H/8)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/8, y+4*H/8)
  cpx = x+4*W/8
  cpy = y+1*H/8
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/8, y+0*H/8)
  ctx.stroke()
}

function bridgeAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+6*H/12)
  ctx.lineTo(x+0*W/12, y+12*H/12)
  ctx.lineTo(x+1*W/12, y+12*H/12)
  ctx.lineTo(x+1*W/12, y+8*H/12)
  cpx = x+2*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+8*H/12)
  ctx.lineTo(x+3*W/12, y+12*H/12)
  ctx.lineTo(x+4*W/12, y+12*H/12)
  ctx.lineTo(x+4*W/12, y+6*H/12)
  cpx = x+6*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+6*H/12)
  ctx.lineTo(x+8*W/12, y+12*H/12)
  ctx.lineTo(x+9*W/12, y+12*H/12)
  ctx.lineTo(x+9*W/12, y+8*H/12)
  cpx = x+10*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+11*W/12, y+8*H/12)
  ctx.lineTo(x+11*W/12, y+12*H/12)
  ctx.lineTo(x+12*W/12, y+12*H/12)
  ctx.lineTo(x+12*W/12, y+6*H/12)
  cpx = x+8*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+2*H/12)
  cpx = x+4*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+6*H/12)
  // large arc offset up
  ctx.moveTo(x+12*W/12, y+6*H/12)
  ctx.lineTo(x+12*W/12, y+4*H/12)
  cpx = x+8*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+0*H/12)
  cpx = x+4*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+4*H/12)
  ctx.lineTo(x+0*W/12, y+6*H/12)
  ctx.stroke()
}

function lensAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+0*W/10, y+4*H/10)
  points.push(x+0*W/10, y+4*H/10)
  cpx = x+5*W/10
  cpy = y+6*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/10, y+4*H/10)
  points.push(x+10*W/10, y+4*H/10)
  cpx = x+5*W/10
  cpy = y+2*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/10, y+4*H/10)
  points.push(x+0*W/10, y+4*H/10)
  cpx = x+5*W/10
  cpy = y+10*H/10
  ctx.lineTo(x+0*W/10, y+4*H/10)
  points.push(x+0*W/10, y+4*H/10)
  ctx.lineTo(x+5*W/10, y+10*H/10)
  points.push(x+5*W/10, y+10*H/10)
  ctx.lineTo(x+10*W/10, y+4*H/10)
  points.push(x+10*W/10, y+4*H/10)
  ctx.lineTo(x+10*W/10, y+0*H/10)
  points.push(x+10*W/10, y+0*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+0*W/10, y+4*H/10)
  points.push(x+0*W/10, y+4*H/10)
  ctx.lineTo(x+0*W/10, y+0*H/10)
  points.push(x+0*W/10, y+0*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+2*W/10, y+0*H/10)
  points.push(x+2*W/10, y+0*H/10)
  ctx.lineTo(x+2*W/10, y+4*H/10)
  points.push(x+2*W/10, y+4*H/10)
  ctx.lineTo(x+5*W/10, y+10*H/10)
  points.push(x+5*W/10, y+10*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/10, y+0*H/10)
  points.push(x+4*W/10, y+0*H/10)
  ctx.lineTo(x+4*W/10, y+4*H/10)
  points.push(x+4*W/10, y+4*H/10)
  ctx.lineTo(x+5*W/10, y+10*H/10)
 
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/10, y+0*H/10)
  points.push(x+6*W/10, y+0*H/10)
  ctx.lineTo(x+6*W/10, y+4*H/10)
  points.push(x+6*W/10, y+4*H/10)
  ctx.lineTo(x+5*W/10, y+10*H/10)
  
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+8*W/10, y+0*H/10)
  points.push(x+8*W/10, y+0*H/10)
  ctx.lineTo(x+8*W/10, y+4*H/10)
  points.push(x+8*W/10, y+4*H/10)
  ctx.lineTo(x+5*W/10, y+10*H/10)
 
  ctx.stroke()
  drawStars(x,y,W,points)
}

function orbitAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+5*W/10, y+3*H/10)
  points.push(x+5*W/10, y+3*H/10)
  cpx = x+7*W/10
  cpy = y+3*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/10, y+5*H/10)
  points.push(x+7*W/10, y+5*H/10)
  cpx = x+7*W/10
  cpy = y+7*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+7*H/10)
  points.push(x+5*W/10, y+7*H/10)
  cpx = x+3*W/10
  cpy = y+7*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/10, y+5*H/10)
  points.push(x+3*W/10, y+5*H/10)
  cpx = x+3*W/10
  cpy = y+3*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+3*H/10)
  points.push(x+5*W/10, y+3*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+0*W/10, y+5*H/10)
  points.push(x+0*W/10, y+5*H/10)
  cpx = x+0*W/10
  cpy = y+4*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/10, y+4*H/10)
  points.push(x+1*W/10, y+4*H/10)
  cpx = x+2*W/10
  cpy = y+4*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/10, y+5*H/10)
  points.push(x+2*W/10, y+5*H/10)
  cpx = x+2*W/10
  cpy = y+6*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/10, y+6*H/10)
  points.push(x+1*W/10, y+6*H/10)
  cpx = x+0*W/10
  cpy = y+6*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/10, y+5*H/10)
  points.push(x+0*W/10, y+5*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+1*W/10, y+4*H/10)
  points.push(x+1*W/10, y+4*H/10)
  cpx = x+1*W/10
  cpy = y+1*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+1*H/10)
  points.push(x+5*W/10, y+1*H/10)
  cpx = x+9*W/10
  cpy = y+1*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/10, y+5*H/10)
  points.push(x+9*W/10, y+5*H/10)
  cpx = x+9*W/10
  cpy = y+9*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+9*H/10)
  points.push(x+5*W/10, y+9*H/10)
  cpx = x+1*W/10
  cpy = y+9*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/10, y+6*H/10)
  points.push(x+1*W/10, y+6*H/10)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+5*W/10, y+3*H/10)
  points.push(x+5*W/10, y+3*H/10)
  ctx.lineTo(x+5*W/10, y+2*H/10)
  points.push(x+5*W/10, y+2*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/10, y+7*H/10)
  points.push(x+5*W/10, y+7*H/10)
  ctx.lineTo(x+5*W/10, y+8*H/10)
  points.push(x+5*W/10, y+8*H/10)
  ctx.stroke()
  drawStars(x,y,W,points)
}

function coreAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+5*W/10, y+0*H/10)
  points.push(x+5*W/10, y+0*H/10)
  ctx.lineTo(x+5*W/10, y+4*H/10)
  points.push(x+5*W/10, y+4*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/10, y+6*H/10)
  points.push(x+5*W/10, y+6*H/10)
  ctx.lineTo(x+5*W/10, y+10*H/10)
  points.push(x+5*W/10, y+10*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/10, y+4*H/10)
  points.push(x+5*W/10, y+4*H/10)
  cpx = x+4*W/10
  cpy = y+4*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/10, y+5*H/10)
  points.push(x+4*W/10, y+5*H/10)
  cpx = x+4*W/10
  cpy = y+6*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+6*H/10)
  points.push(x+5*W/10, y+6*H/10)
  cpx = x+6*W/10
  cpy = y+6*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+5*H/10)
  points.push(x+6*W/10, y+5*H/10)
  cpx = x+6*W/10
  cpy = y+4*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+4*H/10)
  points.push(x+5*W/10, y+4*H/10)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+5*W/10, y+0*H/10)
  points.push(x+5*W/10, y+0*H/10)
  cpx = x+0*W/10
  cpy = y+0*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/10, y+5*H/10)
  points.push(x+0*W/10, y+5*H/10)
  cpx = x+0*W/10
  cpy = y+10*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+10*H/10)
  points.push(x+5*W/10, y+10*H/10)
  cpx = x+10*W/10
  cpy = y+10*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/10, y+5*H/10)
  points.push(x+10*W/10, y+5*H/10)
  cpx = x+10*W/10
  cpy = y+0*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+0*H/10)
  points.push(x+5*W/10, y+0*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/10, y+0*H/10)
  points.push(x+5*W/10, y+0*H/10)
  cpx = x+8*W/10
  cpy = y+2*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/10, y+5*H/10)
  points.push(x+8*W/10, y+5*H/10)
  cpx = x+8*W/10
  cpy = y+8*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+10*H/10)
  points.push(x+5*W/10, y+10*H/10)
  ctx.stroke()

  ctx.beginPath()
  ctx.moveTo(x+5*W/10, y+10*H/10)
  points.push(x+5*W/10, y+10*H/10)
  cpx = x+2*W/10
  cpy = y+8*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/10, y+5*H/10)
  points.push(x+2*W/10, y+5*H/10)
  cpx = x+2*W/10
  cpy = y+2*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+0*H/10)
  points.push(x+5*W/10, y+0*H/10)
  ctx.stroke()
  drawStars(x,y,W,points,0.1)
}

function tvAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  let points = []
  ctx.beginPath()
  ctx.moveTo(x+0*W/15, y+3*H/15)
points.push(x+0*W/15, y+3*H/15)
  ctx.lineTo(x+15*W/15, y+3*H/15)
points.push(x+15*W/15, y+3*H/15)
  ctx.lineTo(x+15*W/15, y+15*H/15)
points.push(x+15*W/15, y+15*H/15)
  ctx.lineTo(x+0*W/15, y+15*H/15)
points.push(x+0*W/15, y+15*H/15)
  ctx.lineTo(x+0*W/15, y+3*H/15)
points.push(x+0*W/15, y+3*H/15)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+1*W/15, y+6*H/15)
points.push(x+1*W/15, y+6*H/15)
  cpx = x+1*W/15
  cpy = y+4*H/15
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/15, y+4*H/15)
  ctx.lineTo(x+12*W/15, y+4*H/15)
points.push(x+12*W/15, y+4*H/15)
  cpx = x+14*W/15
  cpy = y+4*H/15
  ctx.quadraticCurveTo(cpx, cpy, x+14*W/15, y+6*H/15)
  ctx.lineTo(x+14*W/15, y+12*H/15)
points.push(x+14*W/15, y+12*H/15)
  cpx = x+14*W/15
  cpy = y+14*H/15
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/15, y+14*H/15)
  ctx.lineTo(x+3*W/15, y+14*H/15)
points.push(x+3*W/15, y+14*H/15)
  cpx = x+1*W/15
  cpy = y+14*H/15
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/15, y+12*H/15)
  ctx.lineTo(x+1*W/15, y+6*H/15)
points.push(x+1*W/15, y+6*H/15)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+0*W/15, y+0*H/15)
points.push(x+0*W/15, y+0*H/15)
  ctx.lineTo(x+7*W/15, y+3*H/15)
points.push(x+7*W/15, y+3*H/15)
  ctx.lineTo(x+14*W/15, y+0*H/15)
points.push(x+14*W/15, y+0*H/15)
  ctx.stroke()
  drawStars(x,y,W,points,0.1)
}

function duckAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  // body
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+8*H/12)
  cpx = x+3*W/12
  cpy = y+11*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+12*H/12)
  cpx = x+12*W/12
  cpy = y+12*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+8*H/12)
  cpx = x+12*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+4*H/12)
  cpx = x+3*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+8*H/12)
  ctx.stroke()
  // head
  ctx.beginPath()
  ctx.moveTo(x+12*W/12, y+2*H/12)
  cpx = x+11*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+1*H/12)
  cpx = x+7*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+2*H/12)
  cpx = x+7*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+3*H/12)
  cpx = x+11*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+2*H/12)
  ctx.stroke()
  
  ctx.beginPath() // eye
  ctx.arc(x+9*W/12, y+2*H/12, W/24, 0, Math.PI*2)
  ctx.stroke()
}

function bugAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  let points = []
  let cpx = 0, cpy = 0
  ctx.beginPath() // head
  ctx.moveTo(x+5.5*W/13, y+1*H/13)
points.push(x+5.5*W/13, y+1*H/13)
  ctx.lineTo(x+7.5*W/13, y+1*H/13)
points.push(x+7.5*W/13, y+1*H/13)
  ctx.arc(x+7.5*W/13, y+1.5*H/13, W/26, Math.PI*1.5, Math.PI/2)
points.push(x+7.5*W/13, y+1.5*H/13)
  ctx.arc(x+5.5*W/13, y+1.5*H/13, W/26, Math.PI/2, Math.PI*1.5)
points.push(x+5.5*W/13, y+1.5*H/13)
  ctx.stroke()
  ctx.beginPath() // left anten
  ctx.moveTo(x+6*W/13, y+1*H/13)
points.push(x+6*W/13, y+1*H/13)
  cpx = x+5*W/13
  cpy = y
  ctx.quadraticCurveTo(cpx,cpy,x+1*W/13, y+1*H/13)
  points.push(x+1*W/13, y+1*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7*W/13, y+1*H/13)
points.push(x+7*W/13, y+1*H/13)

  cpx = x+7*W/13
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/13, y+1*H/13)
  points.push(x+12*W/13, y+1*H/13)
  ctx.stroke()
  ctx.beginPath() // thorax
  ctx.moveTo(x+6*W/13, y+2*H/13)
points.push(x+6*W/13, y+2*H/13)
  ctx.lineTo(x+6*W/13, y+4*H/13)
points.push(x+6*W/13, y+4*H/13)
  ctx.lineTo(x+7*W/13, y+4*H/13)
points.push(x+7*W/13, y+4*H/13)
  ctx.lineTo(x+7*W/13, y+2*H/13)
points.push(x+7*W/13, y+2*H/13)
  ctx.stroke()
  
  ctx.beginPath() // body
  ctx.moveTo(x+6*W/13, y+4*H/13)
points.push(x+6*W/13, y+4*H/13)
  ctx.lineTo(x+5*W/13, y+5*H/13)
points.push(x+5*W/13, y+5*H/13)
  cpx = x+5*H/13
  cpy = y+12*W/13
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/13, y+13*H/13)
  ctx.lineTo(x+7*W/13, y+13*H/13)
points.push(x+7*W/13, y+13*H/13)
  cpx = x+8*H/13
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/13, y+5*H/13)
  ctx.lineTo(x+7*W/13, y+4*H/13)
points.push(x+7*W/13, y+4*H/13)
  ctx.stroke()

  ctx.beginPath()
  ctx.moveTo(x+7*W/13, y+4*H/13)
points.push(x+7*W/13, y+4*H/13)
  ctx.lineTo(x+9*W/13, y+3*H/13)
points.push(x+9*W/13, y+3*H/13)
  ctx.lineTo(x+10*W/13, y+3*H/13)
points.push(x+10*W/13, y+3*H/13)
  ctx.lineTo(x+11*W/13, y+2*H/13)
points.push(x+11*W/13, y+2*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/13, y+4*H/13)
points.push(x+6*W/13, y+4*H/13)
  ctx.lineTo(x+4*W/13, y+3*H/13)
points.push(x+4*W/13, y+3*H/13)
  ctx.lineTo(x+3*W/13, y+3*H/13)
points.push(x+3*W/13, y+3*H/13)
  ctx.lineTo(x+2*W/13, y+2*H/13)
points.push(x+2*W/13, y+2*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/13, y+5*H/13)
points.push(x+5*W/13, y+5*H/13)
  ctx.lineTo(x+3*W/13, y+5*H/13)
points.push(x+3*W/13, y+5*H/13)
  ctx.lineTo(x+2*W/13, y+4*H/13)
points.push(x+2*W/13, y+4*H/13)
  ctx.lineTo(x+1*W/13, y+4*H/13)
points.push(x+1*W/13, y+4*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+8*W/13, y+5*H/13)
points.push(x+8*W/13, y+5*H/13)
  ctx.lineTo(x+10*W/13, y+5*H/13)
points.push(x+10*W/13, y+5*H/13)
  ctx.lineTo(x+11*W/13, y+4*H/13)
points.push(x+11*W/13, y+4*H/13)
  ctx.lineTo(x+12*W/13, y+4*H/13)
points.push(x+12*W/13, y+4*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/13, y+6*H/13)
points.push(x+5*W/13, y+6*H/13)
  ctx.lineTo(x+3*W/13, y+6*H/13)
points.push(x+3*W/13, y+6*H/13)
  ctx.lineTo(x+1*W/13, y+8*H/13)
points.push(x+1*W/13, y+8*H/13)
  ctx.lineTo(x+1*W/13, y+9*H/13)
points.push(x+1*W/13, y+9*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+8*W/13, y+6*H/13)
points.push(x+8*W/13, y+6*H/13)
  ctx.lineTo(x+10*W/13, y+6*H/13)
points.push(x+10*W/13, y+6*H/13)
  ctx.lineTo(x+12*W/13, y+8*H/13)
points.push(x+12*W/13, y+8*H/13)
  ctx.lineTo(x+12*W/13, y+9*H/13)
points.push(x+12*W/13, y+9*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/13, y+1*H/13)
points.push(x+6*W/13, y+1*H/13)
  ctx.lineTo(x+6*W/13, y+2*H/13)
points.push(x+6*W/13, y+2*H/13)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+7*W/13, y+1*H/13)
points.push(x+7*W/13, y+1*H/13)
  ctx.lineTo(x+7*W/13, y+2*H/13)
points.push(x+7*W/13, y+2*H/13)
  ctx.stroke()
  drawStars(x,y,W,points,0.5)
}

function everythingSymb () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let N = randomPick([2,3,4])
  if (document.getElementById("grungy").checked)
    N = 1
  let functions = shuffle(["origamiAt", "airplaneAt", "envelopeAt", "sardinesAt", "refractionAt", "mothAt", "firebirdAt", "spiralAt", "gunAt", "elephantAt", "coreAt", "orbitAt", "lensAt", "pythagAt", "floppyAt", "spiderAt", "shoesAt",
  "mushroomAt", "catAt", "birbAt", "pantsAt", "tvAt", "drAt", "fishAt", "cactusAt", "umbrellaAt", "flameAt",
  "appleAt", "bridgeAt", "bugAt", "mailboxAt", "rowhousesAt", "jumpropeAt",
  "pointhouseAt", "breadAt", "flathouseAt", "flatchairAt", "birdhouseAt", "factoryAt",
  "dashedAt", "phaseAt", "leafAt", "allAt", "thenAt", "existAt", "tildeAt", "userAt",
  "heartAt", "glassAt", "prayerAt", "thoughtAt", "skullAt", "lampAt", "chairAt",
  "stairsAt", "treeAt", "slideAt", "ladderAt", "swingAt"])
  let pad = 60
  padT = 2*pad + (N-1) * pad
  let delta = Math.round(W/N) - padT/N
  let colors = getCurrentPalette()
  let x = pad, y = pad, i = 0
  let cnt = 0, f
  for (; i < N*N; i++) {
    window[functions[i]](x,y,delta,randomPick (colors))
    x += delta+pad
    cnt++
    if (cnt > 1 && cnt%N === 0) {
      x = pad
      y += delta+pad
    }
  }
}

function shoesAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  let points = []
  ctx.beginPath()
  ctx.moveTo(x+10*W/10, y+1*H/10)
  cpx = x+10*W/10
  cpy = y+0*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/10, y+0*H/10)
points.push( x+8*W/10, y+0*H/10)
  cpx = x+6*W/10
  cpy = y+0*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+1*H/10)
points.push( x+6*W/10, y+1*H/10)
  cpx = x+6*W/10
  cpy = y+2*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/10, y+2*H/10)
points.push( x+8*W/10, y+2*H/10)
  cpx = x+10*W/10
  cpy = y+2*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/10, y+1*H/10)
points.push( x+10*W/10, y+1*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+0*W/10, y+5*H/10)
  cpx = x+0*W/10
  cpy = y+4*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/10, y+4*H/10)
points.push( x+2*W/10, y+4*H/10)
  cpx = x+4*W/10
  cpy = y+4*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/10, y+5*H/10)
points.push( x+4*W/10, y+5*H/10)
  cpx = x+4*W/10
  cpy = y+6*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/10, y+6*H/10)
points.push( x+2*W/10, y+6*H/10)
  cpx = x+0*W/10
  cpy = y+6*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/10, y+5*H/10)
points.push( x+0*W/10, y+5*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/10, y+5*H/10)
  cpx = x+4*W/10
  cpy = y+7*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/10, y+7*H/10)
points.push( x+7*W/10, y+7*H/10)
  cpx = x+10*W/10
  cpy = y+7*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/10, y+9*H/10)
points.push( x+10*W/10, y+9*H/10)
  cpx = x+10*W/10
  cpy = y+10*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/10, y+10*H/10)
points.push( x+9*W/10, y+10*H/10)
  ctx.lineTo(x+1*W/10, y+10*H/10)
  cpx = x+0*W/10
  cpy = y+10*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/10, y+9*H/10)
points.push( x+0*W/10, y+9*H/10)
  ctx.lineTo(x+0*W/10, y+5*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+10*W/10, y+1*H/10)
  ctx.lineTo(x+10*W/10, y+5*H/10)
  cpx = x+10*W/10
  cpy = y+6*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/10, y+6*H/10)
points.push( x+9*W/10, y+6*H/10)
  ctx.lineTo(x+4.27*W/10, y+6*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/10, y+1*H/10)
  cpx = x+6*W/10
  cpy = y+3*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/10, y+3*H/10)
points.push( x+3*W/10, y+3*H/10)
  cpx = x+0*W/10
  cpy = y+3*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/10, y+5*H/10)
points.push( x+0*W/10, y+5*H/10)
  ctx.stroke()
  drawStars(x,y,W,points)
}

function hourglassAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+1*W/10, y+0*H/10)
  cpx = x+1*W/10
  cpy = y+4*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/10, y+4*H/10)
  cpx = x+4*W/10
  cpy = y+4*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/10, y+5*H/10)
  cpx = x+4*W/10
  cpy = y+6*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/10, y+6*H/10)
  cpx = x+1*W/10
  cpy = y+6*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/10, y+10*H/10)
  ctx.lineTo(x+9*W/10, y+10*H/10)
  cpx = x+9*W/10
  cpy = y+6*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/10, y+6*H/10)
  cpx = x+6*W/10
  cpy = y+6*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+5*H/10)
  cpx = x+6*W/10
  cpy = y+4*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/10, y+4*H/10)
  cpx = x+9*W/10
  cpy = y+4*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/10, y+0*H/10)
  ctx.lineTo(x+1*W/10, y+0*H/10)
  ctx.stroke()

  ctx.beginPath()
  ctx.moveTo(x+2*W/10, y+2*H/10)
  cpx = x+2*W/10
  cpy = y+3*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/10, y+3*H/10)
  cpx = x+5*W/10
  cpy = y+3*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/10, y+4*H/10)
  cpx = x+5*W/10
  cpy = y+3*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/10, y+3*H/10)
  cpx = x+8*W/10
  cpy = y+3*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/10, y+2*H/10)
  cpx = x+5*W/10
  cpy = y+2*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/10, y+2*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/10, y+6*H/10)
  cpx = x+5*W/10
  cpy = y+10*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/10, y+10*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/10, y+6*H/10)
  cpx = x+5*W/10
  cpy = y+10*H/10
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/10, y+10*H/10)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/10, y+4*H/10)
  ctx.lineTo(x+5*W/10, y+6*H/10)
  ctx.stroke()
}

function umbrellaAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy
  let alt = true
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  let points = []
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+6*H/12)
  cpx = x+1*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+6*H/12)
points.push( x+2*W/12, y+6*H/12)
  cpx = x+3*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+6*H/12)
points.push( x+4*W/12, y+6*H/12)
  cpx = x+5*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+6*H/12)
points.push( x+6*W/12, y+6*H/12)
  cpx = x+7*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+6*H/12)
points.push( x+8*W/12, y+6*H/12)
  cpx = x+9*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+6*H/12)
points.push( x+10*W/12, y+6*H/12)
  cpx = x+11*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+6*H/12)
points.push( x+12*W/12, y+6*H/12)
  cpx = x+12*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+0*H/12)
points.push( x+6*W/12, y+0*H/12)
  cpx = x+0*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+6*H/12)
points.push( x+0*W/12, y+6*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+6*H/12)
  ctx.lineTo( x+6*W/12, y+11*H/12)
points.push( x+6*W/12, y+11*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+11*H/12)
  cpx = x+6*W/12
  cpy = y+12*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+12*H/12)
points.push( x+7*W/12, y+12*H/12)
  cpx = x+8*W/12
  cpy = y+12*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+11*H/12)
points.push( x+8*W/12, y+11*H/12)
  ctx.stroke()
  drawStars(x,y,W,points)
}

function drawStars (x,y,W, points, T) {
  if (!document.getElementById("grungy").checked)
    return
  if (!T)
    T = 0.25
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  let i = 0
  for (;i < points.length; i+=2) {
    ctx.fillStyle = "#ffffff"
    ctx.beginPath()
    x = points[i]
    y = points[i+1]
    r = 1 * Math.random() * W/40
    ctx.beginPath()
    ctx.arc(x,y,r,0,Math.PI*2)
    ctx.closePath()
    if (Math.random() > T)
      ctx.fill()
  }
}

function existAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  let x0 = x, y0 = y, off = W/10
  let r = W/4
  ctx.beginPath()
  ctx.moveTo(x+off, y)
  ctx.lineTo(x+W-off, y)
  ctx.lineTo(x+W-off, y+H)
  ctx.lineTo(x+off, y+H)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+W/4, y+H/2)
  ctx.lineTo(x+W-off, y+H/2)
  ctx.stroke()
}

function thenAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  let x0 = x, y0 = y, off = W/10
  let r = W/4
  ctx.beginPath()
  ctx.moveTo(x+off, y)
  ctx.arc(x+W/2-off, y+H/2, W/2, Math.PI * 1.5, Math.PI/2)
  ctx.lineTo(x+off, y+H)
  ctx.stroke()
}

function dashedAt (x,y,W,color) { // phase
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  let x0 = x, y0 = y, off = W/10
  let R2 = W/2
  let INNER = Math.random() > 0.5
  let dash = ctx.lineWidth * 4
  x = x + W/2, y = y +H/2
  if (INNER)
    ctx.setLineDash([dash, dash/2])
  else
    ctx.setLineDash([])
  ctx.beginPath()
  ctx.arc(x, y, R2, 0, Math.PI*2)
  ctx.stroke()
  
  if (!INNER)
    ctx.setLineDash([dash, dash/2])
  else
    ctx.setLineDash([])
  ctx.beginPath()
  ctx.arc(x, y, R2/2, 0, Math.PI*2)
  ctx.stroke()
  ctx.setLineDash([])
}

function core3At (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let oc = document.createElement('canvas')
  let occtx = oc.getContext("2d")
  oc.height = canvas.height, oc.width = canvas.width
  let colors = shuffle(getCurrentPalette(true,13))
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.lineJoin = "bevel"

  fillOC(oc, occtx)
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+6*H/12)
  ctx.lineTo(x+12*W/12, y+6*H/12)
  ctx.lineTo(x+12*W/12, y+0*H/12)
  ctx.lineTo(x+0*W/12, y+0*H/12)
  ctx.lineTo(x+0*W/12, y+6*H/12)
  ctx.clip()
  ctx.drawImage(oc, 0, 0, canvas.width, canvas.height)
  ctx.restore()
  fillOC(oc, occtx)
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+6*H/12)
  ctx.lineTo(x+0*W/12, y+12*H/12)
  ctx.lineTo(x+12*W/12, y+12*H/12)
  ctx.lineTo(x+12*W/12, y+6*H/12)
  ctx.lineTo(x+0*W/12, y+6*H/12)
  ctx.clip()
  ctx.drawImage(oc, 0, 0, canvas.width, canvas.height)
  ctx.restore()
  fillOC(oc, occtx)
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(x+4*W/12, y+6*H/12)
  cpx = x+4*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+4*H/12)
  ctx.lineTo(x+6*W/12, y+8*H/12)
  cpx = x+4*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+6*H/12)
  ctx.clip()
  ctx.drawImage(oc, 0, 0, canvas.width, canvas.height)
  ctx.restore()
  fillOC(oc, occtx)
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+4*H/12)
  cpx = x+8*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+6*H/12)
  cpx = x+8*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+8*H/12)
  ctx.lineTo(x+6*W/12, y+4*H/12)
  cpx = x+2*W/12
  cpy = y+6*H/12
  ctx.clip()
  ctx.drawImage(oc, 0, 0, canvas.width, canvas.height)
  ctx.restore()
  fillOC(oc, occtx)
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(x+2*W/12, y+6*H/12)
  cpx = x+2*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+2*H/12)
  ctx.lineTo(x+6*W/12, y+4*H/12)
  cpx = x+4*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+6*H/12)
  ctx.lineTo(x+2*W/12, y+6*H/12)
  ctx.clip()
  ctx.drawImage(oc, 0, 0, canvas.width, canvas.height)
  ctx.restore()
  fillOC(oc, occtx)
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+8*H/12)
  cpx = x+6*W/12
  cpy = y+10*H/12
  ctx.clip()
  ctx.drawImage(oc, 0, 0, canvas.width, canvas.height)
  ctx.restore()
  fillOC(oc, occtx)
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+10*H/12)
  cpx = x+10*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+6*H/12)
  ctx.lineTo(x+8*W/12, y+6*H/12)
  cpx = x+8*W/12
  cpy = y+8*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+8*H/12)
  ctx.lineTo(x+6*W/12, y+10*H/12)
  ctx.clip()
  ctx.drawImage(oc, 0, 0, canvas.width, canvas.height)
  ctx.restore()
  fillOC(oc, occtx)
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(x+2*W/12, y+6*H/12)
  cpx = x+2*W/12
  cpy = y+10*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+10*H/12)
  ctx.lineTo(x+6*W/12, y+12*H/12)
  cpx = x+0*W/12
  cpy = y+12*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+6*H/12)
  ctx.lineTo(x+2*W/12, y+6*H/12)
  ctx.clip()
  ctx.drawImage(oc, 0, 0, canvas.width, canvas.height)
  ctx.restore()
  fillOC(oc, occtx)
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(x+12*W/12, y+6*H/12)
  cpx = x+12*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+0*H/12)
  ctx.lineTo(x+6*W/12, y+2*H/12)
  cpx = x+10*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+6*H/12)
  ctx.lineTo(x+12*W/12, y+6*H/12)
  ctx.clip()
  ctx.drawImage(oc, 0, 0, canvas.width, canvas.height)
  ctx.restore()
}

function core2At (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let oc = document.createElement('canvas')
  let occtx = oc.getContext("2d")
  oc.height = canvas.height, oc.width = canvas.width
  let colors = shuffle(getCurrentPalette(true,13))
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.lineJoin = "bevel"

  fillOC(oc, occtx)
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+0*H/12)
  ctx.lineTo(x+12*W/12, y+0*H/12)
  ctx.lineTo(x+12*W/12, y+12*H/12)
  ctx.lineTo(x+0*W/12, y+12*H/12)
  ctx.lineTo(x+0*W/12, y+1*H/12)
  ctx.lineTo(x+0*W/12, y+0*H/12)
  ctx.clip()
  ctx.drawImage(oc, 0, 0, canvas.width, canvas.height)
  ctx.restore()
  fillOC(oc, occtx)
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(x+1*W/12, y+6*H/12)
  cpx = x+1*W/12
  cpy = y+1*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+1*H/12)
  ctx.lineTo(x+6*W/12, y+3*H/12)
  cpx = x+3*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+6*H/12)
  cpx = x+3*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+9*H/12)
  ctx.lineTo(x+6*W/12, y+11*H/12)
  cpx = x+1*W/12
  cpy = y+11*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/12, y+6*H/12)
  ctx.clip()
  ctx.drawImage(oc, 0, 0, canvas.width, canvas.height)
  ctx.restore()
  fillOC(oc, occtx)
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+1*H/12)
  cpx = x+11*W/12
  cpy = y+1*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+11*W/12, y+6*H/12)
  cpx = x+11*W/12
  cpy = y+11*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+11*H/12)
  ctx.lineTo(x+6*W/12, y+9*H/12)
  cpx = x+9*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+6*H/12)
  cpx = x+9*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+3*H/12)
  ctx.lineTo(x+6*W/12, y+1*H/12)
  ctx.clip()
  ctx.drawImage(oc, 0, 0, canvas.width, canvas.height)
  ctx.restore()
  fillOC(oc, occtx)
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(x+3*W/12, y+6*H/12)
  cpx = x+3*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+3*H/12)
  cpx = x+9*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+9*W/12, y+6*H/12)
  cpx = x+9*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+9*H/12)
  cpx = x+3*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+3*W/12, y+6*H/12)
  ctx.clip()
  ctx.drawImage(oc, 0, 0, canvas.width, canvas.height)
  ctx.restore()
}

function gunAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy, points = []
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+4*W/12, y+5*H/12)
  points.push(x+4*W/12, y+5*H/12)
  cpx = x+7*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+5*H/12)
  points.push(x+4*W/12, y+5*H/12)
  ctx.lineTo(x+10*W/12, y+5*H/12)
  points.push(x+10*W/12, y+5*H/12)
  cpx = x+12*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+4*H/12)
  points.push(x+12*W/12, y+4*H/12)
  cpx = x+12*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+3*H/12)
  points.push(x+10*W/12, y+3*H/12)
  ctx.lineTo(x+4*W/12, y+3*H/12)
  points.push(x+4*W/12, y+3*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/12, y+11*H/12)
  points.push(x+4*W/12, y+11*H/12)
  ctx.lineTo(x+2*W/12, y+11*H/12)
  points.push(x+2*W/12, y+11*H/12)
  cpx = x+0*W/12
  cpy = y+11*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+9*H/12)
  points.push(x+0*W/12, y+9*H/12)
  ctx.lineTo(x+0*W/12, y+6*H/12)
  points.push(x+0*W/12, y+6*H/12)
  ctx.lineTo(x+0*W/12, y+3*H/12)
  points.push(x+0*W/12, y+3*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+5*W/12, y+3*H/12)
  points.push(x+5*W/12, y+3*H/12)
  cpx = x+7*W/12
  cpy = y+3*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+1*H/12)
  points.push(x+7*W/12, y+1*H/12)
  cpx = x+7*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+0*H/12)
  points.push(x+6*W/12, y+0*H/12)
  cpx = x+5*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+1*H/12)
  points.push(x+5*W/12, y+1*H/12)
  ctx.lineTo(x+2*W/12, y+1*H/12)
  points.push(x+2*W/12, y+1*H/12)
  cpx = x+0*W/12
  cpy = y+1*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+3*H/12)
  points.push(x+0*W/12, y+3*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/12, y+11*H/12)
  points.push(x+4*W/12, y+11*H/12)
  cpx = x+5*W/12
  cpy = y+11*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+10*H/12)
  points.push(x+5*W/12, y+10*H/12)
  cpx = x+5*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+9*H/12)
  points.push(x+4*W/12, y+9*H/12)
  cpx = x+6*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+8*H/12)
  points.push(x+6*W/12, y+8*H/12)
  cpx = x+6*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+7*H/12)
  points.push(x+4*W/12, y+7*H/12)
  cpx = x+6*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+6*H/12)
  points.push(x+6*W/12, y+6*H/12)
  cpx = x+6*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+5*H/12)
  points.push(x+4*W/12, y+5*H/12)
  ctx.stroke()
  drawStars(x,y,W,points)
}

function telephoneAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W, cpx, cpy
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  ctx.lineCap = "square"
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+3*H/12)
  ctx.lineTo(x+0*W/12, y+1*H/12)
  cpx = x+0*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/12, y+0*H/12)
  ctx.lineTo(x+11*W/12, y+0*H/12)
  cpx = x+12*W/12
  cpy = y+0*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+3*H/12)
  cpx = x+10*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+3*H/12)
  cpx = x+10*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+3*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+0*W/12, y+3*H/12)
  cpx = x+2*W/12
  cpy = y+2*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+4*W/12, y+3*H/12)
  cpx = x+2*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+0*W/12, y+3*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/12, y+3*H/12)
  ctx.lineTo(x+4*W/12, y+2*H/12)
  cpx = x+4*W/12
  cpy = y+1*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+1*H/12)
  ctx.lineTo(x+7*W/12, y+1*H/12)
  cpx = x+8*W/12
  cpy = y+1*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+8*W/12, y+2*H/12)
  ctx.lineTo(x+8*W/12, y+3*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+4*W/12, y+4*H/12)
  ctx.lineTo(x+4*W/12, y+3*H/12)
  ctx.lineTo(x+5*W/12, y+3*H/12)
  ctx.lineTo(x+5*W/12, y+4*H/12)
  ctx.lineTo(x+7*W/12, y+4*H/12)
  ctx.lineTo(x+7*W/12, y+3*H/12)
  ctx.lineTo(x+8*W/12, y+3*H/12)
  ctx.lineTo(x+8*W/12, y+4*H/12)
  ctx.lineTo(x+11*W/12, y+4*H/12)
  cpx = x+12*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+12*W/12, y+5*H/12)
  ctx.lineTo(x+12*W/12, y+12*H/12)
  ctx.lineTo(x+0*W/12, y+12*H/12)
  ctx.lineTo(x+0*W/12, y+5*H/12)
  cpx = x+0*W/12
  cpy = y+4*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+1*W/12, y+4*H/12)
  ctx.lineTo(x+4*W/12, y+4*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+11*H/12)
  cpx = x+10*W/12
  cpy = y+11*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+10*W/12, y+8*H/12)
  cpx = x+10*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+5*H/12)
  cpx = x+2*W/12
  cpy = y+5*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+2*W/12, y+8*H/12)
  cpx = x+2*W/12
  cpy = y+11*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+11*H/12)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(x+6*W/12, y+7*H/12)
  cpx = x+5*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+5*W/12, y+8*H/12)
  cpx = x+5*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+9*H/12)
  cpx = x+7*W/12
  cpy = y+9*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+7*W/12, y+8*H/12)
  cpx = x+7*W/12
  cpy = y+7*H/12
  ctx.quadraticCurveTo(cpx, cpy, x+6*W/12, y+7*H/12)
  ctx.stroke()
}

function phaseAt (x,y,W,color) { // phase
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  let x0 = x, y0 = y, off = W/10
  let R2 = W/2
  let mult = Math.random()
  x = x + W/2, y = y +H/2
  ctx.beginPath()
  ctx.ellipse(x, y, R2, R2, 0, 0, Math.PI*2)
  ctx.stroke()
  if (Math.random() > 0.5) {
    ctx.beginPath()
    ctx.ellipse(x, y, R2*mult, R2, 0, Math.PI * 1.5, Math.PI/2)
    ctx.ellipse(x, y, R2, R2, 0, Math.PI/2, Math.PI*1.5, true)
    ctx.stroke()
  } else {
    ctx.beginPath()
    ctx.ellipse(x, y, R2*mult, R2, 0, Math.PI * 1.5, Math.PI/2, true)
    ctx.ellipse(x, y, R2, R2, 0, Math.PI/2, Math.PI*1.5)
    ctx.stroke()
  }
}

function tildeAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  let x0 = x, y0 = y, off = W/10
  let r = W/4
  y += W/2
  ctx.beginPath()
  ctx.moveTo(x+off, y)
  let cpx1 = x + 1/6*W, cpx2 = x + 2/6*W
  let cpy1 = y - 1/6*H, cpy2 = y - 1/6*H
  ctx.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x+W/2, y)
  cpx1 = x + 4/6*W, cpx2 = x + 5/6*W
  cpy1 = y + 1/6*H, cpy2 = y + 1/6*H
  ctx.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x+W-off, y)
  ctx.stroke()
}

function allAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  let x0 = x, y0 = y, off = W/10
  let r = W/4
  ctx.beginPath()
  ctx.moveTo(x+off, y)
  ctx.lineTo(x+W/2, y+H)
  ctx.lineTo(x-off+W, y)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x+W/4+off/2, y+H/2)
  ctx.lineTo(x+3*W/4-off/2, y+H/2)
  ctx.stroke()
}

function heartAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  let x0 = x, y0 = y
  let r = W/4
  ctx.beginPath()
  ctx.moveTo(x+W/2, y+H)
  cpx = x0
  cpy = y0+H*0.57
  ctx.quadraticCurveTo(cpx,cpy,x+0, y+r)
  x += W/4
  y += r
  ctx.arc(x, y, r, Math.PI, Math.PI*2) // thumb
  x += r*2
  ctx.arc(x, y, r, Math.PI, Math.PI*2) // thumb
  cpx = x0+W
  cpy = y0+H*0.57
  ctx.quadraticCurveTo(cpx,cpy,x0+W/2, y0+H)
  ctx.stroke()
}

function glassAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  let cx = x+W/2, cy = 0
  let r1 = W/3, r2 = r1/2.3
  let points = []
  let x0 = x, y0 = y
  ctx.beginPath()
  ctx.ellipse(cx, y+r2, r1, r2, 0, 0, 2 * Math.PI)
  ctx.ellipse(cx, y+H-r2*0.5-ctx.lineWidth*2, r1*0.8, r2*0.8, 0, 0, 2 * Math.PI)
  ctx.ellipse(cx, y+H-r2*0.5-ctx.lineWidth*2, r1*0.8, r2*0.8, 0, 0, Math.PI)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(cx-r1, y+r2)
  ctx.lineTo(cx-r1*0.8, y+H-r2/2-ctx.lineWidth*2)
  ctx.stroke()

  // inner fill
  r1 *= 0.9
  r2 *= 0.9
  
  ctx.beginPath()
  ctx.ellipse(cx, y+H/2, r1, r2, 0, 0, 2 * Math.PI)
  ctx.stroke()
}

function userAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  let hip = W * 0.8
  // fill
  ctx.lineJoin = "round"
  ctx.strokeStyle = color
  let cx = x + W/2, cy = y + H/2
  let r = hip/6
  //left shoulder
  ctx.beginPath()
  ctx.moveTo(x+hip/8, y+H)
  ctx.ellipse(x+hip/8+r, y+H/2+r, r, r, 0, Math.PI, 1.5 * Math.PI)
  //left neck
  ctx.ellipse(x+(hip/8+2*r/2), y+H/2-r, r, r, 0, Math.PI/2, 0, true)
  ctx.ellipse(x+W/2, y+r + Math.floor(Math.random()*H/20), r, r, 0, Math.PI, Math.PI*2)
  
  ctx.ellipse(x+W-(hip/8+2*r/2), y+H/2-r, r, r, 0, Math.PI, Math.PI/2, true) // crown
  // right shoulder
  ctx.ellipse(x+W-hip/8-r, y+H/2+r, r, r, 0, Math.PI * 1.5, 0)
  ctx.lineTo( x+W-hip/8,   y+H)
  ctx.stroke()
}

function cubeAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  let pad = 0 //+ Math.random() *40,
  ctx.strokeStyle = color
  let d = (W-2*pad)/2
  d *= 1.3
  let da = randomPick([3,5,8,13,24])
  let div = d/da
  x += W/2
  let x0 = x
  ctx.fillStyle = (colors[0])
  ctx.beginPath()
  ctx.moveTo(x,y+div)
  ctx.lineTo(x+d/2,y+d/2)
  ctx.lineTo(x,y+d-div)
  ctx.lineTo(x-d/2,y+d/2)
  ctx.lineTo(x,y+div)
  ctx.closePath()
  ctx.stroke()
  
  ctx.fillStyle = (colors[1])
  ctx.beginPath()
  x -= d/2, y += pad + d/2
  ctx.moveTo(x,y)         // top left
  ctx.lineTo(x+d/2,y+d/2-div) // top right
  ctx.lineTo(x+d/2,y+d-div) // bottom right
  ctx.lineTo(x,y+d/2)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.stroke()
  
  ctx.fillStyle = (colors[2])
  ctx.beginPath()
  x = x0, y += pad + d/2
  ctx.moveTo(x,y-div)
  ctx.lineTo(x+d/2,y-d/2)
  ctx.lineTo(x+d/2,y)
  ctx.lineTo(x,y+d/2-div)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.stroke()
}

function dressers () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width
  let H = W
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let i = 0, pad = 40,x = pad, y = pad
  let w = (W-pad)/9
  let alpha = ctx.globalAlpha
  for (; i < 9*9; i++) {
    if (i > 0 && i % 9 === 0) {
      x = pad
      y += w
    }
    if (i < 40) {
      squareAt(x,y,w,randomPick(colors))
      alpha *= 0.95
      ctx.globalAlpha = alpha
    } else {
      dresserAt(x,y,w,randomPick(colors))
      alpha *= 1.05
      ctx.globalAlpha = alpha
    }
    x += w
  }
}

function squareAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
 // ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 2 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  let d = (W-2*2)/2
  d *= 1.3
  let di = d/10
  let x0 = x
  ctx.fillStyle = (colors[0])
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x+pet(3),y+d)
  ctx.lineTo(x+d,y+d+pet(3))
  ctx.lineTo(x+d+pet(3), y)
  ctx.closePath()
  ctx.fill()
  //ctx.stroke()
}

function dresserAt (x,y,W,color) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = W
  //ctx.globalAlpha = +document.getElementById("opacity").value/100
  //let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 2 + document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  let d = (W-2*2)/2
  d *= 1.3
  let di = d/10
  let x0 = x
  ctx.fillStyle = color
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x+pet(3),y+d)
  ctx.lineTo(x+di,y+d+pet(3))
  ctx.lineTo(x+di+pet(3), y+d-di)
  ctx.lineTo(x+di*6,y+d-di+pet(3))
  ctx.lineTo(x+di*6+pet(3),y+d)
  ctx.lineTo(x+di*7, y+d+pet(3))

  ctx.lineTo(x+di*7, y+d+pet(3))
  ctx.lineTo(x+di*7, y+d-di+pet(3))

  ctx.lineTo(x+d-di+pet(3),y+8*di)
  ctx.lineTo(x+d-di+pet(3),y+8.5*di)
  ctx.lineTo(x+d+pet(3),y+8.5*di)

  ctx.lineTo(x+d,y+2*di+pet(3))
  ctx.lineTo(x+d-3*di+pet(3),y-di)
  ctx.closePath()
  ctx.fill()
  //ctx.stroke()
}

function cube () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/10
  let pad = 40 //+ Math.random() *40,
  let x = W/2, y = pad
  let sqrW = W/2 + pad/2 -(2*pad), sqrH = sqrW
  let d = (W-2*pad)/2
  d *= 1.3
  let da = randomPick([2.1,3,5,8,13,100,200])
  let div = d/da
  
  ctx.fillStyle = (colors[0])
  ctx.beginPath()
  ctx.moveTo(x,y+div)
  ctx.lineTo(x+d/2,y+d/2)
  ctx.lineTo(x,y+d-div)
  ctx.lineTo(x-d/2,y+d/2)
  ctx.lineTo(x,y+div)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = (colors[1])
  ctx.beginPath()
  x = W/2-d/2, y = pad + d/2
  ctx.moveTo(x,y)         // top left
  ctx.lineTo(x+d/2,y+d/2-div) // top right
  ctx.lineTo(x+d/2,y+d-div) // bottom right
  ctx.lineTo(x,y+d/2)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = (colors[2])
  ctx.beginPath()
  x = W/2, y = pad + d
  ctx.moveTo(x,y-div)
  ctx.lineTo(x+d/2,y-d/2)
  ctx.lineTo(x+d/2,y)
  ctx.lineTo(x,y+d/2-div)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.fill()
}

function dflags () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let N = randomPick([4,5,6,7,8,9])
  let delta = Math.round(W/N)
  let x = 0, y = 0, i = 0
  let cnt = 0
  for (; i < N*N; i++) {
    adiagflag(x,y,delta,delta,i)
    x += delta
    cnt++
    if (cnt > 1 && cnt%N === 0) {
    //if (x >= W) {
      x = 0
      y += delta
    }
  }
}

function hstripes (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let colors = shuffle(getCurrentPalette())
  let W = canvas.width, H = canvas.height
  let fs = 3 + document.getElementById("featuresize").value/2
  let N = Math.floor(H/fs)
  let idx =shuffle([0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,2,2,2,3,3,4])
  let delta = H/N
  
  let pad = 0, div = 2, mult = 1.4
  //if (document.getElementById("grungy").checked)
  //  pad = W/20, mult = 1.9
  
  let x = 0, y = pad/5, i = 0
  for (; i < N/mult; i++) {
    ctx.fillStyle = colors[randomPick(idx)]
    ctx.beginPath()
    let y0 = y+pet(delta/div)+pad
    let x0 = x+pet(delta/div)+pad
    ctx.moveTo(x0,y0)
    ctx.lineTo(W-2*pad+pet(delta/div), y + pet(delta/div))
    ctx.lineTo(W- 2*pad+pet(delta/div), y + delta*2 + pet(delta/div))
    ctx.lineTo(pad+pet(delta/div), y + delta*2 + pet(delta/div))
    ctx.lineTo(x0, y0)
    ctx.closePath()
    ctx.fill()
    y += delta*mult
  }
}

function flags () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let N = 3
  let delta = W/N
  let x = 0, y = 0, i = 0
  let cnt = 0
  for (; i < N*N; i++) {
    aflag(x,y,delta,delta,i)
    x += delta
    cnt++
    if (cnt > 1 && cnt%N === 0) {
      x = 0
      y += delta
    }
  }
}

function adiagflag (x,y,w,h,V) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/10
  let div = 3, m = 1
  if (alt) {
    ;//div = 4, m = 2
  }
  let i = 0
  if (Math.random() > 0.5) {
      ctx.fillStyle = colors[0]
      ctx.beginPath()
      ctx.moveTo(x+pet(4),y+pet(4))
      ctx.lineTo(x+w+pet(4),y+h+pet(4))
      ctx.lineTo(x+2*w/div+pet(4),y+h+pet(4))
      ctx.lineTo(x+pet(4),y+h/div+pet(4))
      ctx.lineTo(x+pet(4),y+pet(4))
      ctx.closePath()
      ctx.fill()
      
      ctx.fillStyle = colors[1]
      ctx.beginPath()
      ctx.moveTo(x+pet(4),y+pet(4))
      ctx.lineTo(x+w/div+pet(4),y+pet(4))
      ctx.lineTo(x+w+pet(4),y+2*h/div+pet(4))
      ctx.lineTo(x+w+pet(4),y+h+pet(4))
      ctx.lineTo(x+pet(4),y+pet(4))
      ctx.closePath()
      ctx.fill()
      
      ctx.fillStyle = colors[2]
      ctx.beginPath()
      ctx.moveTo(x+w/div+pet(4),y+pet(4))
      ctx.lineTo(x+2*w/div+pet(4),y+pet(4))
      ctx.lineTo(x+w+pet(4),y+h/div+pet(4))
      ctx.lineTo(x+w+pet(4),y+2*h/div+pet(4))
      ctx.lineTo(x+w/div+pet(4),y+pet(4))
      ctx.closePath()
      ctx.fill()
      
      ctx.fillStyle = colors[3]
      ctx.beginPath()
      ctx.moveTo(x+pet(4),y+h/div+pet(4))
      ctx.lineTo(x+2*w/div+pet(4),y+h+pet(4))
      ctx.lineTo(x+w/div+pet(4),y+h+pet(4))
      ctx.lineTo(x+pet(4),y+2*h/div+pet(4))
      ctx.lineTo(x+pet(4),y+h/div+pet(4))
      ctx.closePath()
      ctx.fill()
      
      ctx.fillStyle = colors[4]
      ctx.beginPath()
      ctx.moveTo(x+2*w/div+pet(4), y+pet(4))
      ctx.lineTo(x+w+pet(4),y+pet(4))
      ctx.lineTo(x+w+pet(4),y+h/div+pet(4))
      ctx.lineTo(x+2*w/div+pet(4),y+pet(4))
      ctx.closePath()
      ctx.fill()
      
      ctx.beginPath()
      ctx.moveTo(x+pet(4), y+2*h/div+pet(4))
      ctx.lineTo(x+w/div+pet(4),y+h+pet(4))
      ctx.lineTo(x+pet(4),y+h+pet(4))
      ctx.lineTo(x+pet(4), y+2*h/div+pet(4))
      ctx.closePath()
      ctx.fill()

    } else {
      
      ctx.fillStyle = colors[0]
      ctx.beginPath()
      ctx.moveTo(x+w+pet(4),y+pet(4))
      ctx.lineTo(x+w+pet(4),y+h/div+pet(4))
      ctx.lineTo(x+w/div+pet(4),y+h+pet(4))
      ctx.lineTo(x+pet(4),y+h+pet(4))
      ctx.lineTo(x+h+pet(4),y+pet(4))
      ctx.closePath()
      ctx.fill()
      
      ctx.fillStyle = colors[1]
      ctx.beginPath()
      ctx.moveTo(x+w+pet(4),y+pet(4))
      ctx.lineTo(x+pet(4),y+h+pet(4))
      ctx.lineTo(x+pet(4),y+2*h/div+pet(4))
      ctx.lineTo(x+2*w/div+pet(4),y+pet(4))
      ctx.lineTo(x+w+pet(4),y+pet(4))
      ctx.closePath()
      ctx.fill()
      
      ctx.fillStyle = colors[2]
      ctx.beginPath()
      ctx.moveTo(x+w+pet(4),y+h/div+pet(4))
      ctx.lineTo(x+w+pet(4),y+2*h/div+pet(4))
      ctx.lineTo(x+2*w/div+pet(4),y+h+pet(4))
      ctx.lineTo(x+w/div+pet(4),y+h+pet(4))
      ctx.lineTo(x+w+pet(4),y+h/div+pet(4))
      ctx.closePath()
      ctx.fill()
      
      ctx.fillStyle = colors[3]
      ctx.beginPath()
      ctx.moveTo(x+w/div+pet(4),y+pet(4))
      ctx.lineTo(x+2*w/div+pet(4),y+pet(4))
      ctx.lineTo(x+pet(4),y+2*h/div+pet(4))
      ctx.lineTo(x+pet(4),y+h/div+pet(4))
      ctx.lineTo(x+w/div+pet(4),y+pet(4))
      ctx.closePath()
      ctx.fill()
      
      ctx.fillStyle = colors[4]
      ctx.beginPath()
      ctx.moveTo(x+pet(4), y+pet(4))
      ctx.lineTo(x+w/div+pet(4),y+pet(4))
      ctx.lineTo(x+pet(4),y+h/div+pet(4))
      ctx.lineTo(x+pet(4),y+pet(4))
      ctx.closePath()
      ctx.fill()
      
      ctx.beginPath()
      ctx.moveTo(x+w+pet(4), y+2*h/div+pet(4))
      ctx.lineTo(x+w+pet(4),y+h+pet(4))
      ctx.lineTo(x+2*w/div+pet(4), y+h+pet(4))
      ctx.lineTo(x+w+pet(4), y+2*h/div+pet(4))
      ctx.closePath()
      ctx.fill()
    }
}

function pointys () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let CX = W/2, CY = H/2
  let N = randomPick([2,29,37,3,4,5,6,7,8,13,20])
  let colors = shuffle(getCurrentPalette(true,13))

  let delta = Math.floor(W/N), dv = Math.floor(H/N)
  let x = 0, y = 0, i = 0, cnt = 0
  for (; i < N*N; i++) {
    apoint(x,y,delta,dv,CX,CY,colors)
    x += delta
    cnt++
    if (cnt > 1 && cnt%N === 0) {
      x = 0
      y += dv
    }
  }
}

function apoint (x,y,w,h,CX,CY,colors) { //Natalia Cacchiarelli
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let alt = document.getElementById("grungy").checked
  //let colors = getCurrentPalette(true,13)
  if (!alt)
    ;//colors = shuffle(colors)
  let idx =shuffle([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,3,4])
  let cx = Math.floor(x+(w)/2) //+ pet(w*0.96))
  let cy = Math.floor(y+(h)/2)// + pet (h*0.96))

  cx -= (LASTCLICK[0]-cx)/W * 0.8*w
  cy -= (LASTCLICK[1]-cy)/H * 0.8*h
  
  //let dist = distance((cx),(cy),CX,CY)
  //let percent = (100 - (dist/CX)*100)*2
  ctx.fillStyle = colors[0]
  if (alt)
    ctx.fillStyle = colors[randomPick(idx)]
  //ctx.fillStyle = shadeColor(ctx.fillStyle,percent)
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x+w,y)
  ctx.lineTo(cx, cy)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = colors[1]
  if (alt)
    ctx.fillStyle = colors[randomPick(idx)]
  //ctx.fillStyle = shadeColor(ctx.fillStyle,percent)
  ctx.beginPath()
  ctx.moveTo(x+w,y)
  ctx.lineTo(x+w,y+h)
  ctx.lineTo(cx, cy)
  ctx.lineTo(x+w,y)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = colors[2]
  if (alt)
    ctx.fillStyle = colors[randomPick(idx)]
  //ctx.fillStyle = shadeColor(ctx.fillStyle,percent)
  ctx.beginPath()
  ctx.moveTo(x+w,y+h)
  ctx.lineTo(x,y+h)
  ctx.lineTo(cx, cy)
  ctx.lineTo(x+w,y+h)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = colors[3]
  if (alt)
    ctx.fillStyle = colors[randomPick(idx)]
 // ctx.fillStyle = shadeColor(ctx.fillStyle,percent)
  ctx.beginPath()
  ctx.moveTo(x,y+h)
  ctx.lineTo(x,y)
  ctx.lineTo(cx, cy)
  ctx.lineTo(x,y+h)
  ctx.closePath()
  ctx.fill()
}


function aflag (x,y,w,h,V) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/10
  let div = 3, m = 1
  if (alt) {
    div = 4, m = 2
  }
  let i = 0
  if (V % 2 === 0)
    for (; i < div; i++) {
      ctx.fillStyle = (colors[i])
      ctx.beginPath()
      ctx.moveTo(x+pet(4),y+pet(4))
      ctx.lineTo(x+w+pet(4),y+pet(4))
      ctx.lineTo(x+w+pet(4),y+h/div+pet(4))
      ctx.lineTo(x+pet(4),y+h/div+pet(4))
      ctx.lineTo(x+pet(4),y+pet(4))
      ctx.closePath()
      ctx.fill()
      y+=h/div
    }
    else
    for (; i < div; i++) {
      ctx.fillStyle = (colors[i])
      ctx.beginPath()
      ctx.moveTo(x+pet(4),y+pet(4))
      ctx.lineTo(x+w/div+pet(4),y+pet(4))
      ctx.lineTo(x+w/div+pet(4)+pet(4),y+h+pet(4))
      ctx.lineTo(x+pet(4),y+h+pet(4))
      ctx.lineTo(x+pet(4),y)+pet(4)
      ctx.closePath()
      ctx.fill()
      x+=h/div
    }
}

function pinwheels () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let N = randomPick([3,4,5,6,7,8,9])
  let delta = W/N
  let x = 0, y = 0, i = 0, cnt = 0
  for (; i < N*N; i++) {
    apinwheel(x,y,delta,delta,i)
    x += delta
    cnt++
    if (cnt > 1 && cnt%N === 0) {
      x = 0
      y += delta
    }
  }
}

function wheel1 (ctx,x,y,w,h,div,m) {
  ctx.beginPath()
  ctx.moveTo(x+pet(4),y)
  ctx.lineTo(x+m*w/div+pet(4),y)
  ctx.lineTo(x+2*w/div,y+h+pet(4))
  ctx.lineTo(x+2*w/div+pet(4),y+h)
  ctx.lineTo(x,y+h+pet(4))
  ctx.closePath()
  ctx.fill()
}

function wheel2 (ctx,x,y,w,h,div,m) {
  ctx.beginPath()
  ctx.moveTo(x+w/3+pet(4),y)
  ctx.lineTo(x+w+pet(4),y)
  ctx.lineTo(x+w,y+h+pet(4))
  ctx.lineTo(x+2*w/div+pet(4),y+h)
  ctx.lineTo(x+w/div,y+pet(4))
  ctx.closePath()
  ctx.fill()
}

function wheel3 (ctx,x,y,w,h,div,m) {
  ctx.beginPath()
  ctx.moveTo(x+pet(4),y)
  ctx.lineTo(x+w+pet(4),y)
  ctx.lineTo(x+w,y+2*h/3+pet(4))
  ctx.lineTo(x+pet(4),y+h/div)
  ctx.lineTo(x+pet(4),y+pet(4))
  ctx.closePath()
  ctx.fill()
}

function wheel4 (ctx,x,y,w,h,div,m) {
  ctx.beginPath()
  ctx.moveTo(x+pet(4),y+h/div)
  ctx.lineTo(x+w,y+2*h/div+pet(4))
  ctx.lineTo(x+w+pet(4),y+h)
  ctx.lineTo(x+pet(4),y+h+pet(4))
  ctx.lineTo(x+pet(4),y+h/div)
  ctx.closePath()
  ctx.fill()
}

function wheel5 (ctx,x,y,w,h,div,m) {
  ctx.beginPath()
  ctx.moveTo(x+2*w/div,y+pet(4))
  ctx.lineTo(x+w+pet(4),y)
  ctx.lineTo(x+w,y+h+pet(4))
  ctx.lineTo(x+w/div+pet(4),y+h)
  ctx.lineTo(x+2*w/div,y+pet(4))
  ctx.closePath()
  ctx.fill()
}

function wheel6 (ctx,x,y,w,h,div,m) {
  ctx.beginPath()
  ctx.moveTo(x+w+pet(4),y+h/div)
  ctx.lineTo(x+w,y+h+pet(4))
  ctx.lineTo(x+pet(4),y+h)
  ctx.lineTo(x,y+2*h/3+pet(4))
  ctx.lineTo(x+w+pet(4),y+h/div)
  ctx.closePath()
  ctx.fill()
}

function apinwheel (x, y, w, h) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/10
  let sides = shuffle([0,1,2,3,4,5]).slice(0,4)
  let funs = shuffle(["wheel1", "wheel2", "wheel3", "wheel4", "wheel5", "wheel6"])
  let div = 3, m = 1
  if (alt) {
    div = 3, m = 2
  }
  let colori = 0
  
  let i = 0
  for (; i < 5; i++) {
    ctx.fillStyle = colors[i]
    window[funs[i]](ctx,x,y,w,h, div,m)
  }
  
  return
  ctx.beginPath()
  ctx.moveTo(x+pet(4),y)
  ctx.lineTo(x+m*w/div+pet(4),y)
  ctx.lineTo(x+2*w/div,y+h+pet(4))
  ctx.lineTo(x+2*w/div+pet(4),y+h)
  ctx.lineTo(x,y+h+pet(4))
  ctx.closePath()
  if (sides.includes(0)) {
    ctx.fillStyle = colors[colori++]
    ctx.fill()
  }
  
  ctx.beginPath()
  ctx.moveTo(x+w/3+pet(4),y)
  ctx.lineTo(x+w+pet(4),y)
  ctx.lineTo(x+w,y+h+pet(4))
  ctx.lineTo(x+2*w/div+pet(4),y+h)
  ctx.lineTo(x+w/div,y+pet(4))
  ctx.closePath()
  if (sides.includes(1)) {
    ctx.fillStyle = colors[colori++]
    ctx.fill()
  }
  
  ctx.beginPath()
  ctx.moveTo(x+pet(4),y)
  ctx.lineTo(x+w+pet(4),y)
  ctx.lineTo(x+w,y+2*h/3+pet(4))
  ctx.lineTo(x+pet(4),y+h/div)
  ctx.lineTo(x+pet(4),y+pet(4))
  ctx.closePath()
  if (sides.includes(2)) {
    ctx.fillStyle = colors[colori++]
    ctx.fill()
  }

  ctx.beginPath()
  ctx.moveTo(x+pet(4),y+h/div)
  ctx.lineTo(x+w,y+2*h/div+pet(4))
  ctx.lineTo(x+w+pet(4),y+h)
  ctx.lineTo(x+pet(4),y+h+pet(4))
  ctx.lineTo(x+pet(4),y+h/div)
  ctx.closePath()
  if (sides.includes(3)) {
    ctx.fillStyle = colors[colori++]
    ctx.fill()
  }
    
  ctx.beginPath()
  ctx.moveTo(x+2*w/div,y+pet(4))
  ctx.lineTo(x+w+pet(4),y)
  ctx.lineTo(x+w,y+h+pet(4))
  ctx.lineTo(x+w/div+pet(4),y+h)
  ctx.lineTo(x+2*w/div,y+pet(4))
  ctx.closePath()
  if (sides.includes(4)) {
    ctx.fillStyle = colors[colori++]
    ctx.fill()
  }
    
  ctx.beginPath()
  ctx.moveTo(x+w+pet(4),y+h/div)
  ctx.lineTo(x+w,y+h+pet(4))
  ctx.lineTo(x+pet(4),y+h)
  ctx.lineTo(x,y+2*h/3+pet(4))
  ctx.lineTo(x+w+pet(4),y+h/div)
  ctx.closePath()
  if (sides.includes(5)) {
    ctx.fillStyle = colors[colori++]
    ctx.fill()
  }
}

function weave () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let N = randomPick([3,4,5,6,7,8,9])
  let pad = 20
  let delta = W/N
  let x = 0, y = 0, i = 0, cnt = 0
  for (; i < N*N; i++) {
    if (Math.random() > 0.5)
      aflag(x,y,delta,delta, i % 2 === 0)
    else
      adiagflag(x,y,delta,delta, i % 2 === 0)
    x += delta
    cnt++
    if (cnt > 1 && cnt%N === 0) {
      x = 0
      y += delta
    }
  }
}

function weave2 () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let N = randomPick([3,4,5,6,7,8,9])
  let pad = 20
  let delta = W/N
  let x = 0, y = 0, i = 0, cnt = 0
  for (; i < N*N; i++) {
    if (Math.random() > 0.5)
      apinwheel(x,y,delta,delta)
    else
      adiagflag(x,y,delta,delta, i % 2 === 0)
    x += delta
    cnt++
    if (cnt > 1 && cnt%N === 0) {
      x = 0
      y += delta
    }
  }
}

function monocubes () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let N = randomPick([2,3,4])
  let pad = document.getElementById("featuresize").value/10000 * W
  let delta = W/N
  let x = 0, y = 0, i = 0, cnt = 0
  for (; i < N*N; i++) {
    amonocube(x+pad,y+pad,delta-2*pad,delta-2*pad)
    x += delta
    cnt++
    if (cnt > 1 && cnt%N === 0) {
      x = 0
      y += delta
    }
  }
}

function monoblobs () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let alt = document.getElementById("grungy").checked
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  let colors = getCurrentPalette(true,13)
  let W = canvas.width, H = canvas.height
  let N = randomPick([2,3,4])
  let pad = document.getElementById("featuresize").value/10000 * W
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  let delta = W/N
  let x = 0, y = 0, i = 0, cnt = 0
  for (; i < N*N; i++) {
    //if (alt)
    ctx.strokeStyle = randomPick(colors)
    ctx.fillStyle = randomPick(colors)
    
    ablob(x+pad,y+pad,delta-2*pad,delta-2*pad)
    x += delta
    cnt++
    if (cnt > 1 && cnt%N === 0) {
      x = 0
      y += delta
    }
  }
}

function ablob (cx,cy,w,h) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let alt = document.getElementById("grungy").checked
  let alpha0 = ctx.globalAlpha
  let radius = w/2 *0.9
  cx += w/2, cy += h/2
  let x = 0
  let y = 0
  let x0,y0
  let angle = Math.floor(Math.random() * 6.42);
  let edges = randomPick([3,4,5,6,7])
  let increase = Math.PI * 2/edges*0.98;
  let points = [];
  //radius = (Math.random() * maxradius) + maxradius * 0.9;
  for (let i = 0; i < edges; i++) {
    radius += pet(radius/4)
    x = radius * Math.cos(angle)+cx;
    y = radius * Math.sin(angle)+cy;
    if (i === 0) {
      x0 = x
      y0 = y
    }
    points.push([x, y]);
    angle += increase + pet(2)/5;
  }
  points.push([x0,y0])
  if (alt)
    drawPath(points,0,0)
  else
    strokePath(points)
}


function kites () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let N = randomPick([2,3,4,5,6,7])
  let pad = document.getElementById("featuresize").value/10000 * W
  let delta = W/N
  let x = 0, y = 0, i = 0, cnt = 0
  for (; i < N*N; i++) {
    acube(x+pad,y+pad,delta-2*pad,delta-2*pad)
    x += delta
    cnt++
    if (cnt > 1 && cnt%N === 0) {
      x = 0
      y += delta
    }
  }
}

function amonocube (x,y,w,h) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  w *= 0.8, h *= 0.8
  x += w * 0.1, y += h * 0.1
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette(true,13))
  let alt = document.getElementById("grungy").checked
  let div = 3, m = 2
  ctx.fillStyle = colors[0]
  
  ctx.shadowBlur = 10 + Math.random() * 15
  ctx.shadowColor = "#666666"
  ctx.shadowOffsetX = (Math.random()-0.5) * 8
  ctx.shadowOffsetY  = (Math.random()-0.5) * 8

  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x+m*w/div,y)
  ctx.lineTo(x+w, y+1*h/div)
  ctx.lineTo(x+w,y+h)
  ctx.lineTo(x+w/div,y+h)
  ctx.lineTo(x,y+m*h/div)
  ctx.closePath()
  ctx.fill()
  ctx.shadowBlur = 0
  ctx.shadowOffsetX = 0
  ctx.shadowOffsetY = 0
}

function dotArray () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let N = randomPick([5,6,7,4,11])
  let alpha = document.getElementById("opacity").value/100
  let r = 4+document.getElementById("featuresize").value/20
  let delta = W/N
  let pad = delta/2, inset = 0
  let x = 0, y = 0, i = 0, cnt = 0
  ctx.fillStyle = randomPick(getCurrentPalette())
  for (; i < N*N; i++) {
    ctx.globalAlpha = alpha + pet(1)/2
    ctx.beginPath()
    if (Math.random() < 0.91)
      ctx.ellipse(x+pad+pet(3), y+pad+pet(2), r*1.3+pet(4), r+pet(2),0, 0, Math.PI*2)
    //else
   //   ctx.ellipse(x+pad+pet(3), y+pad+pet(2), r*1.3, r, 0, Math.PI/2, Math.PI*1.5,true)
    ctx.closePath()
    if (Math.random() < 0.83 && x+pad < W-10)
      ctx.fill()
    if (Math.random() > 0.6 && x+pad < W-10) {
      ctx.globalAlpha = alpha/2
      ctx.beginPath()
      ctx.ellipse(x+pad+pet(2)+4, y+pad+pet(2), r*1.5, r+pet(2), 0, 0, Math.PI*2)
      ctx.closePath()
      ctx.fill()
    }
    ctx.globalAlpha = alpha
    x += delta
    cnt++
    if (cnt > 1 && cnt%N === 0) {
      if (inset === 0)
        inset = pad
      else
        inset = 0
      x = inset
      y += delta
    }
  }
}

function monoballs () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let N = randomPick([2,3,4])
  let pad = document.getElementById("featuresize").value/10000 * W
  let delta = W/N
  let x = 0, y = 0, i = 0, cnt = 0
  for (; i < N*N; i++) {
    amonoball(x+pad,y+pad,delta-2*pad,delta-2*pad)
    x += delta
    cnt++
    if (cnt > 1 && cnt%N === 0) {
      x = 0
      y += delta
    }
  }
}

function amonoball (x,y,w,h) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  w *= 0.8, h *= 0.8
  x += w * 0.1, y += h * 0.1
  let r = w/2
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette(true,13))
  let alt = document.getElementById("grungy").checked
  let div = 3, m = 2
  ctx.fillStyle = colors[0]
  if (!alt) {
    ctx.shadowBlur = 10 + Math.random() * 15
    ctx.shadowColor = colors[0]
    ctx.shadowOffsetX = (Math.random()-0.5) * 8
    ctx.shadowOffsetY  = (Math.random()-0.5) * 8
  }
  ctx.beginPath()
  ctx.moveTo(x+r,y+r)
  ctx.arc(x+r,y+r,r,0,Math.PI*2)
  
  ctx.closePath()
  ctx.fill()
  ctx.shadowBlur = 0
  ctx.shadowOffsetX = 0
  ctx.shadowOffsetY = 0
}

function acube (x,y,w,h) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/10
  let div = 2, m = 1
  if (alt) {
    div = 3, m = 2
  }
  ctx.fillStyle = (colors[3])
  ctx.beginPath()
  ctx.moveTo(x+pet(4),y)
  ctx.lineTo(x+m*w/div+pet(4),y)
  ctx.lineTo(x+m*w/div,y+m*h/div+pet(4))
  ctx.lineTo(x+pet(4),y+m*h/div)
  ctx.lineTo(x,y+pet(4))
  ctx.closePath()
  if (Math.random() < 0.81)
    ctx.fill()
  
  ctx.fillStyle = (colors[0])
  ctx.beginPath()
  ctx.moveTo(x,y+pet(4))
  ctx.lineTo(x+w/div,y+h/div+pet(4))
  ctx.lineTo(x+w/div+pet(4),y+h)
  ctx.lineTo(x+pet(4),y+m*h/div)
  ctx.lineTo(x,y+pet(4))
  ctx.closePath()
  if (Math.random() < 0.96)
    ctx.fill()
  
  ctx.fillStyle = (colors[1])
  ctx.beginPath()
  ctx.moveTo(x+m*w/div+pet(4),y)
  ctx.lineTo(x+w,y+h/div+pet(4))
  ctx.lineTo(x+w,y+h+pet(4))
  ctx.lineTo(x+m*w/div,y+m*h/div+pet(4))
  ctx.lineTo(x+m*w/div+pet(4),y)
  ctx.closePath()
  if (Math.random() < 0.96)
    ctx.fill()
  m = 1
  ctx.fillStyle = (colors[2])
  ctx.beginPath()
  ctx.moveTo(x+m*w/div,y+m*h/div+pet(4))
  ctx.lineTo(x+w+pet(4),y+m*h/div)
  ctx.lineTo(x+w+pet(4),y+h)
  ctx.lineTo(x+m*w/div+pet(4),y+h)
  ctx.lineTo(x+m*w/div,y+m*h/div+pet(4))
  ctx.closePath()
  if (Math.random() < 0.81)
    ctx.fill()
}

function facade () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/10
  let pad = 4 //+ Math.random() *40,
  let x = W/2, y = pad
  let sqrW = W/2 + pad/2 -(2*pad), sqrH = sqrW
  let yl = H - Math.random() * H/2, yr = H - Math.random() * H/2
  let xt = W/4 + Math.random() * W/2
  
  y = 0
  ctx.fillStyle = (colors[0])
  ctx.fillRect(0,0,W,H)
  
  let p = 0
  if (alt)
    p = 7
  // add windows to right pane
  let wdiv = randomPick([1,1.5,2,2.5,3])
  let wh = H/15+pet(32), ww = wh/wdiv, i = 0
  let slope = (H/2-yr)/(W-xt)
  x = ww/2, y = H
  let y0 = y
  let yd = -slope*ww, r = 1
  while (r < 38) {
    i = 0
    while (i < 48 && r> 0) {
      ctx.fillStyle = (colors[1])
      if (Math.random() > 0.87)
          ctx.fillStyle = (colors[2])
      ctx.beginPath()
      ctx.moveTo(x+pet(p),y+pet(p))       // lower left
      ctx.lineTo(x+ww+pet(p),y+yd+pet(p)) // lower right
      ctx.lineTo(x+ww+pet(p),y+yd-wh+pet(p))//upper right
      ctx.lineTo(x+pet(p),y-wh+pet(p)) // upper left
      ctx.lineTo(x+pet(p),y+pet(p)) // lower left
      ctx.closePath()
      ctx.fill()
      x += ww*1.5
      y += yd*1.5
      i++
    }
    y = H - wh*r*1.5
    x = (ww/2)
    r++
  }

}

function corner () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/10
  let pad = 4 //+ Math.random() *40,
  let x = W/2, y = pad
  let sqrW = W/2 + pad/2 -(2*pad), sqrH = sqrW
  let yl = H - Math.random() * H/2, yr = H - Math.random() * H/2
  let xt = W/4 + Math.random() * W/2
  
  y = 0
  ctx.fillStyle = (colors[0])
  ctx.beginPath()
  ctx.moveTo(xt,y)
  ctx.lineTo(W,y)
  ctx.lineTo(W,yr)
  ctx.lineTo(xt,H/2)
  ctx.lineTo(xt,y)
  ctx.closePath()
  ctx.fill()

  ctx.fillStyle = (colors[1])
  ctx.beginPath()
  ctx.moveTo(xt,y)
  ctx.lineTo(0,y)
  ctx.lineTo(0,yl)
  ctx.lineTo(xt,H/2)
  ctx.lineTo(xt,y)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = (colors[2])
  ctx.beginPath()
  ctx.moveTo(xt,H/2)
  ctx.lineTo(0,yl)
  ctx.lineTo(0,H)
  ctx.lineTo(W,H)
  ctx.lineTo(W,yr)
  ctx.closePath()
  ctx.fill()
  let p = 0
  if (alt)
    p = 7
  // add windows to right pane
  let wh = H/20+pet(32), ww = wh/2, i = 0
  let slope = (H/2-yr)/(W-xt)
  x = (xt+ww), y = H/2 - ww
  let y0 = y
  let yd = -slope*ww, r = 1
  ctx.fillStyle = (colors[1])
  while (r < 28) {
    i = 0
    while (i < 48) {
      ctx.beginPath()
      ctx.moveTo(x+pet(p),y+pet(p))       // lower left
      ctx.lineTo(x+ww,y+yd) // lower right
      ctx.lineTo(x+ww+pet(p),y+yd-wh)//upper right
      ctx.lineTo(x,y-wh+pet(p)) // upper left
      ctx.lineTo(x,y) // lower left
      ctx.closePath()
      ctx.fill()
      x += ww*1.5
      y += yd*1.5
      i++
    }
    y = H/2 - ww - wh*r*1.5
    x = (xt+ww)
    r++
  }

  // left side
  slope = (H/2-yl)/(-xt)
  x = (xt-ww*2), y = H/2 - ww
  yd = -slope*ww, r = 1
  while (r < 28) {
    i = 0
    while (i < 48) {
      if (r === 3 && i === 4)
        ctx.fillStyle = (colors[3])
      else
        ctx.fillStyle = (colors[2])
      ctx.beginPath()
      ctx.moveTo(x+ww+pet(p),y+yd) // lower right
      ctx.lineTo(x+ww,y+yd-wh+pet(p))//upper right
      ctx.lineTo(x+pet(p),y-wh) // upper left
      ctx.lineTo(x,y+pet(p))       // lower left
      ctx.lineTo(x+ww+pet(p),y+yd) // lower right
      
      ctx.closePath()
      ctx.fill()
      x -= ww*1.5
      y -= yd*1.5
      i++
    }
    y = H/2 - ww - wh*r*1.5
    x = (xt-ww*2)
    r++
  }
  flipV()
}

function cube2 () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/10
  let pad = 4 //+ Math.random() *40,
  let x = W/2, y = pad
  let sqrW = W/2 + pad/2 -(2*pad), sqrH = sqrW
  let d = 1
  //let div = d/da
  
  x = W/3, y = H/3
  ctx.fillStyle = (colors[0])
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(W,y)
  ctx.lineTo(W,H)
  ctx.lineTo(x,H)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = (colors[1])
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(0,0)
  ctx.lineTo(2*W/3,0)
  ctx.lineTo(W,H/3)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = (colors[2])
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(0,0)
  ctx.lineTo(0,2*H/3)
  ctx.lineTo(W/3,H)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.fill()
}

function twosquares () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/10
  let xpad = 40 + pet(70), ypad = 180 +pet(174), x = xpad, y = ypad
  let sqrW = W/2-(1.1*xpad)
  let sqrH = H - (2*ypad)

  ctx.shadowBlur = 15
  ctx.shadowColor = colors[0]
  ctx.shadowOffsetX = (Math.random()-0.5) * 8
  ctx.shadowOffsetY  = (Math.random()-0.5) * 8
  
  ctx.fillStyle = colors[0]
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x+sqrW,y)
  ctx.lineTo(x+sqrW,y+sqrH)
  ctx.lineTo(x,y+sqrH)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.fill()
  
  x = W/2+xpad/10
  /*ctx.fillStyle = colors[0]
  if (alt) {
    ctx.fillStyle = colors[1]
    ctx.shadowColor = colors[1]
  }*/
  let c2 = randomPick(colors)
  ctx.fillStyle = c2
  ctx.shadowColor = c2
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x+sqrW,y)
  ctx.lineTo(x+sqrW,y+sqrH)
  ctx.lineTo(x,y+sqrH)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.fill()
  
  ctx.shadowBlur = 0
  ctx.shadowOffsetX = 0
  ctx.shadowOffsetY  = 0
}

function twohemispheres () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  let mult = document.getElementById("featuresize").value/500
  
  let r = 1+ W/2 * 0.98 * mult
  let sa = Math.PI * 0.5, ea = Math.PI * 1.5
  let x = W/2 - 7 * Math.random(), y = H/2 + pet(9)
  if (alt && Math.random() > 0.5) {
    x = 7 * Math.random()
    sa = Math.PI * 1.5
    ea = Math.PI * 0.5
  }
  ctx.fillStyle = colors[0]
  ctx.beginPath()
  ctx.arc(x,y,r, sa, ea)
  ctx.closePath()
  ctx.fill()

  sa = Math.PI * 1.5, ea = Math.PI * 0.5
  x = W/2 + 7 * Math.random()
  if (alt && Math.random() > 0.5) {
    x = W - 7 * Math.random()
    sa = Math.PI * 0.5
    ea = Math.PI * 1.5
  }
  y = H/2 + pet(9)
  ctx.fillStyle = randomPick(colors)
  ctx.beginPath()
  ctx.arc(x,y,r, sa, ea)
  ctx.closePath()
  ctx.fill()
}

function cornercurve () { // ragged (ctx,endX,endY,x,y)
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette(13,true))
  let alt = document.getElementById("grungy").checked
  delta = 11 + document.getElementById("featuresize").value/2
  let pad = 20, x = pad, y = pad
  let p = 30
  if (alt) {
    H /= 2
    H += pad
    W /= 2
    W += pad - 3
  }
  ctx.fillStyle = colors[0]
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x,H - pad)
  //ragged (ctx,x,H - pad,x,y)
  ragged (ctx,W - pad,H - pad,x,H - pad)
  let cpx1 = W - pad, cpy1 = 3*H/4 - pad
  let cpx2 = 3*W/4+pet(p), cpy2 = H/2+pet(p)
  ctx.bezierCurveTo(cpx1,cpy1, cpx2,cpy2, W/2, H/2)
  cpx1 = W/4 +pet(p),       cpy1 = H/2+pet(p)
  cpx2 = pad,       cpy2 = H/4 + pad
  ctx.bezierCurveTo(cpx1,cpy1, cpx2,cpy2, pad, pad)
  ctx.closePath()
  ctx.fill()
  ctx.strokeStyle = colors[2]
  ctx.lineWidth = 8
}

function mnts () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  delta = 11 + document.getElementById("featuresize").value/2
  let xpad = 0, ypad = 0, x = xpad, y = H/3
  let sqrW = W  -(2*xpad), sqrH = H - (2*ypad), FLIP=true
  
  ctx.fillStyle = colors[0]
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x,Math.random() * H/3)
  while (x < W) {
    x += delta
    y = Math.random() * H/4
    ctx.lineTo(x,y)
  }
  ctx.lineTo(x,H-ypad)
  ctx.lineTo(xpad, H-ypad)
  ctx.closePath()
  ctx.fill()
  
  x = xpad
  y = 2*H/3
  ctx.fillStyle = colors[1]
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x,2*H/3+pet(H/3))
  while (x < W) {
    x += delta
    y = 2*H/3+pet(H/3)
    ctx.lineTo(x,y)
  }
  ctx.lineTo(x,H-ypad)
  ctx.lineTo(xpad, H-ypad)
  ctx.closePath()
  ctx.fill()
  /*
  x = xpad
  y = H - H/3
  ctx.fillStyle = colors[2]
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x,H-H/3+Math.random() * H/3)
  while (x < W) {
    x += delta
    y = H-H/3+Math.random() * H/4
    ctx.lineTo(x,y)
  }
  ctx.lineTo(x,H-ypad)
  ctx.lineTo(xpad, H-ypad)
  ctx.closePath()
 // ctx.fill()*/
}

function hairs () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/10
  let xpad = 40, ypad = 40, x = xpad, y = H-ypad
  let sqrW = W  -(2*xpad), sqrH = H - (2*ypad), FLIP=true
  ctx.fillStyle = colors[0]
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x,H-ypad -Math.random() * H/2)
  while (x < W/2) {
    x += 1
    y = H-Math.random() * H
    ctx.lineTo(x,y)
  }
  ctx.lineTo(x,H-ypad)
  ctx.lineTo(xpad, H-ypad)
  ctx.closePath()
  ctx.fill()
  
  x=W/2, y = H-ypad
  if (alt)
    ctx.fillStyle = colors[1]
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x,H-ypad -Math.random() * H/2)
  while (x < W-xpad) {
    x += 1
    y = H-Math.random() * H
    ctx.lineTo(x,y)
  }
  ctx.lineTo(x,H-ypad)
  ctx.lineTo(xpad, H-ypad)
  ctx.closePath()
  ctx.fill()
}

function onesquare () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/10
  let xpad = 100 + pet(90), ypad = 180 +pet(174), x = xpad, y = ypad
  let sqrW = W  -(2*xpad), sqrH = H - (2*ypad)

  ctx.shadowBlur = 15
  ctx.shadowColor = colors[0]
  ctx.shadowOffsetX = (Math.random()-0.5) * 8
  ctx.shadowOffsetY  = (Math.random()-0.5) * 8
  
  ctx.fillStyle = colors[0]
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x+sqrW,y)
  ctx.lineTo(x+sqrW,y+sqrH)
  ctx.lineTo(x,y+sqrH)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.fill()
  
  ctx.shadowBlur = 0
  ctx.shadowOffsetX = 0
  ctx.shadowOffsetY  = 0
}

function foursquares_l () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/10
  let pad = 10 + Math.random() *100, x = pad, y = pad
  let sqrW = W/2 + pad/2 -(2*pad), sqrH = sqrW
  
  ctx.strokeStyle = randomPick(colors)
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x+sqrW,y)
  ctx.lineTo(x+sqrW,y+sqrH)
  ctx.lineTo(x,y+sqrH)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.stroke()
  
  ctx.strokeStyle = randomPick(colors)
  x = W/2 + pad/2
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x+sqrW,y)
  ctx.lineTo(x+sqrW,y+sqrH)
  ctx.lineTo(x,y+sqrH)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.stroke()
  
  ctx.strokeStyle = randomPick(colors)
  y = H/2 + pad/2
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x+sqrW,y)
  ctx.lineTo(x+sqrW,y+sqrH)
  ctx.lineTo(x,y+sqrH)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.stroke()
  
  ctx.strokeStyle = randomPick(colors)
  x = pad
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x+sqrW,y)
  ctx.lineTo(x+sqrW,y+sqrH)
  ctx.lineTo(x,y+sqrH)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.stroke()
}


function foursquares () {
  let alt = document.getElementById("grungy").checked
  if (alt) {
    foursquares_l()
    return
  }
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  ctx.strokeStyle = colors[0]
  ctx.fillStyle = colors[0]
  let pad = 10 + Math.random() *100, x = pad, y = pad
  let sqrW = W/2 + pad/2 -(2*pad), sqrH = sqrW
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x+sqrW,y)
  ctx.lineTo(x+sqrW,y+sqrH)
  ctx.lineTo(x,y+sqrH)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = colors[1]
  x = W/2 + pad/2
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x+sqrW,y)
  ctx.lineTo(x+sqrW,y+sqrH)
  ctx.lineTo(x,y+sqrH)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = colors[2]
  //x = W/2 + pad
  y = H/2 + pad/2
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x+sqrW,y)
  ctx.lineTo(x+sqrW,y+sqrH)
  ctx.lineTo(x,y+sqrH)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = colors[3]
  //x = W/2 + pad
  x = pad
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x+sqrW,y)
  ctx.lineTo(x+sqrW,y+sqrH)
  ctx.lineTo(x,y+sqrH)
  ctx.lineTo(x,y)
  ctx.closePath()
  ctx.fill()
}

function spiral () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width
  let C = W/2 + (Math.random() - 0.5) * W/4
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let grunge = document.getElementById("grungy").checked
  ctx.lineWidth = 2+document.getElementById("featuresize").value/20
  ctx.lineCap = "round"
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  let radius = 250, r0 = W/2.3 +Math.random() * 250, angle = Math.random() * 6.28
  let n = 0, end = 2400
  let shrink = 100 + Math.random() * 300
  let grow = end -100 - Math.random() * 300
  ctx.beginPath();
  for (; n < end; n++) {
    radius = r0
    // make a complete circle every 50 iterations
    angle += (Math.PI * 2) / 250;
    var x = C + radius * Math.cos(angle);
    var y = C + radius * Math.sin(angle);
    ctx.lineTo(x, y);
    r0 += 0.02 + pet(2)
    if (n > grow)
      r0 += 0.9 + pet(1)
    if (n < shrink)
     r0 -= 0.9 + pet(1)
  }
  ctx.stroke();
}

function spiral2 () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width
  let cx = W/2
  let cy = cx
  let C = W/2 + (Math.random() - 0.5) * W/4
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let colors = shuffle(['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let grunge = document.getElementById("grungy").checked
  ctx.lineWidth = 2+document.getElementById("featuresize").value/20
  ctx.lineCap = "round"
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  let radius = 250, r0 = W/4 +Math.random() * 250, angle = Math.random() * 6.28
  let n = 0, end = 3000
  let shrink = W * 0.37
  let grow = W * 0.05
  ctx.beginPath();
  let inc = false, dec = false
  for (; n < end; n++) {
    radius = r0
    // make a complete circle every 50 iterations
    angle += (Math.PI * 2) / 250;
    var x = C + radius * Math.cos(angle);
    var y = C + radius * Math.sin(angle);
    ctx.lineTo(x, y);
    r0 += 0.02 + pet(2)
    let gs = distance(x,y,cx,cy)
    if (n > 151 && gs > shrink) {
      inc = false
      dec = true
    }
    if (gs < grow) {
      inc = true
      dec = false
    }
    if (inc)
      r0 += 3 + pet(0.5)
    else
    if (dec)
      r0 -= 1 + pet(0.5)
  }
  ctx.stroke();
}

function rose () { // chemotaxis like
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width
  let H = canvas.height
  let cx = LASTCLICK[0]
  let cy = LASTCLICK[1]
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1+document.getElementById("featuresize").value/400
  let fs = ctx.lineWidth * 4
  ctx.lineCap = "round"
  ctx.strokeStyle = randomPick(getCurrentPalette())
  let color = randomPick(getCurrentPalette())
  let size = 0.0001 + document.getElementById("number").value/50000
  console.log(size)
  ctx.fillStyle = color
  let angle = Math.random() * 6.28
  let n = 0, end = 5000
  let shrink = W * 0.37
  let grow = W * 0.05
  let inc = false, dec = false
  let turn = false
  let A = 0.01 + Math.random()/90
  let lw = fs/4, a = 1.6*Math.PI
  let turnAt = W*0.33*size
  let k = lw/7
  let x = cx
  let y = cy
  let increment = 1.001, DIR = true
  let INC = 0, BEC = end/2, gs = 0
  for (; n < end; n++) {
    x = x + Math.sin(angle) * 1
    y = y + Math.cos(angle) * 1
    ctx.lineTo(x, y);
    if (n % 2 === 0) {
      ctx.beginPath()
      ctx.ellipse(x, y, 1.3*lw+pet(lw/2), lw, a, 0, 2* Math.PI)
      ctx.closePath()
      ctx.fill()
      if (Math.random() > 0.98)
        DIR = !DIR
      if (DIR)
        lw *= increment
      else
        lw /= increment
      gs = distance(x,y,cx,cy,fs)
      if (gs > turnAt+50) {
        turn = true
      } else
      if (gs < turnAt-50) {
        turn = false
      }
      if (turn)
        angle += A + pet(k/4)/k/2
      else
        angle += pet(k)
    }
  }
}

function spiral4 () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width
  let cx = W/2
  let cy = cx
  let C = W/2 + (Math.random() - 0.5) * W/4
  ctx.globalAlpha = +document.getElementById("opacity").value/100
  //let colors = shuffle(['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let grunge = document.getElementById("grungy").checked
  ctx.lineWidth = 2+document.getElementById("featuresize").value/20
  ctx.lineCap = "round"
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  let radius = W/4 + Math.random() * W/10
  let angle = Math.random() * 6.28
  let n = 0, end = 17000
  let turnAt = W/6+ Math.random() * W/6
  let inc = false, dec = false
  let turn = false
  let A = 0.001 + Math.random()/140
  var x = cx + radius * Math.cos(angle);
  var y = cy + radius * Math.sin(angle);
  let pf = 19
  if (grunge)
    pf = 7
  let dis = distance(x,y,C,C)
  ctx.beginPath();
  ctx.moveTo(x, y);
  for (; n < end; n++) {
    x = x + Math.sin(angle) * 1
    y = y + Math.cos(angle) * 1
    ctx.lineTo(x, y);
    let gs = distance(x,y,cx,cy) - dis
    if (gs > 0) {
      turn = true
      angle += gs/W * 0.02 + pet(1)/pf
    } else
    if (gs <= 0) {
      turn = false
      angle -= gs/W *0.02 + pet(1)/pf
    }
  }
  ctx.stroke();
}

function drops () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
 // ctx.save()
  clip()
  let W = canvas.width
  let c = W/2
  let margin = W/20
  let w4 = (W-2*margin)/(2+Math.floor(Math.random() * 10))*8//document.getElementById("rows").value
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let grunge = document.getElementById("grungy").checked
  let scale = 7+document.getElementById("featuresize").value/5
  let parts = Math.floor(W/(scale*2-1)) *1.8
  let rule = true
  if (Math.random() > 0.5)
    rule = false
  if (!grunge) {
    let t = 0
    colors = []
    for (; t < 21; t++)
      colors.push(randomColor())
  }
  let x = scale, y = 71 + pet(1)
  let i = 0, r = scale/2
  let d = 0, drift = 0
  for (; i < parts; i++) {
    let x1 = x
    let xf = 20 + Math.random() * 100
    let yf = 0.001 + Math.random()/3 * 0.002
    r = scale/2 + pet(scale/4)
    while (y < 72) {
      d = (x1-c)
      if (d < 1)
        d += -1
      drift = xf/(d+0.01)
      if (rule) {
        if (x1 > c)
          drift -= y * yf
        else
          drift += y * yf
      } else {
        if (x1 < c)
          drift -= y * yf
        else
          drift += y * yf
      }
      x1 += drift
      y += 2
      x1 += pet(1.25)
      if (r < 0.5)
        r = 0.5
      ctx.beginPath();
      ctx.moveTo(x1, y)
      ctx.arc(x1,y,1+r+pet(2) ,0,2*Math.PI)
      ctx.closePath()
      ctx.fillStyle = colors[i%colors.length]
      ctx.fill()
      r*= 0.998
    }
    x += scale * 1.05
    y = 41 + pet(41)
  }
  ctx.restore()
}

function chair () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  //clip()
  let W = canvas.width
  let H = canvas.height
  let margin = W/5
  margin = H/5 + Math.floor(Math.random() * H/5)
  
  ctx.globalAlpha = document.getElementById("opacity").value/100
  //let colors = shuffle(['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let grunge = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + Math.floor(document.getElementById("featuresize").value/50)
  ctx.lineCap = "round"
  let points = []
  points[0] = [margin, W/2+margin/2]
  points[1] = [margin*2, W/2-margin+margin/2]
  points[2] = [W-margin, W/2-margin+margin/2]
  points[3] = [W-margin*2, W/2+margin/2]
  points[4] = [margin, margin*2+margin/2]
  points[5] = [margin, margin+margin/2]
  points[6] = [margin*2, 0+margin/2]
  
  points[7] = [margin, W-margin+margin/2]
  points[8] = [margin*2, W-margin*2+margin/2]
  points[9] = [W-margin, W-margin*2+margin/2]
  points[10] = [W-margin*2, W-margin+margin/2]
  
  points[11] = [W-margin, margin/2]
  
  //ctx.clearRect(0,0, W,H)
  let g = 11
  if (grunge)
    g *= 2
  let i = 0
  for (; i < points.length; i++) {
    points[i][0] += pet(g)
    points[i][1] += pet(g)
  }
  
  ctx.lineCap = "round"
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  
  let flip = Math.random() > 0.5
  if (flip) {
    ctx.beginPath();
    ctx.moveTo(points[2][0], points[2][1])
    ctx.lineTo(points[11][0], points[11][1])
    if (grunge)
      ctx.lineWidth += pet(2)
    ctx.stroke()
    
    ctx.beginPath();
    ctx.moveTo(points[6][0], points[6][1])
    ctx.lineTo(points[11][0], points[11][1])
    if (grunge)
      ctx.lineWidth += pet(2)
    ctx.stroke()
  } else {
    ctx.beginPath();
    ctx.moveTo(points[0][0], points[0][1])
    ctx.lineTo(points[5][0], points[5][1])
    if (grunge)
      ctx.lineWidth += pet(2)
    ctx.stroke()
    
    ctx.beginPath();
    ctx.moveTo(points[5][0], points[5][1])
    ctx.lineTo(points[6][0], points[6][1])
    if (grunge)
      ctx.lineWidth += pet(2)
    ctx.stroke()
  }
  
  ctx.beginPath();
  ctx.moveTo(points[0][0], points[0][1])
  ctx.lineTo(points[7][0], points[7][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[1][0], points[1][1])
  ctx.lineTo(points[8][0], points[8][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[2][0], points[2][1])
  ctx.lineTo(points[9][0], points[9][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[3][0], points[3][1])
  ctx.lineTo(points[10][0], points[10][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[0][0], points[0][1])
  ctx.lineTo(points[1][0], points[1][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[1][0], points[1][1])
  ctx.lineTo(points[2][0], points[2][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[1][0], points[1][1])
  ctx.lineTo(points[6][0], points[6][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[2][0], points[2][1])
  ctx.lineTo(points[3][0], points[3][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[0][0], points[0][1])
  ctx.lineTo(points[3][0], points[3][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
 // ctx.restore()
}

function point (x, y) {
  this.x = x
  this.y = y
}

function drawLine (ctx, pt1, pt2) {
  ctx.beginPath()
  ctx.moveTo(pt1.x, pt1.y)
  ctx.lineTo(pt2.x, pt2.y)
  ctx.stroke()
}
/*
function person () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  ctx.lineWidth = 0.5+document.getElementById("featuresize").value/10
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  let W = canvas.width
  let margin = W/8
  margin = 50 + (W-2*margin)/(2+Math.floor(Math.random() * 10))//document.getElementById("rows").value
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let grunge = document.getElementById("grungy").checked
  ctx.lineWidth = 0.5+document.getElementById("featuresize").value/10
  let r = 47 + Math.random() * 11

  let points = []
  points[0] = new point(W/2 + margin/2, W/2+margin/2)
  points[1] = new point(W/2 - margin/2, W/2+margin/2)
  //armpits
  points[2] = new point(W/2 + margin/2.2, margin*1.5)
  points[3] = new point(W/2 - margin/2.2, margin*1.5)
  points[5] = new point(W/2, margin*1.5) // shoulders

  points[6] = new point(W/2, margin*0.7) // head
  //hands
  points[7] = new point(margin*1.7, W/2-margin/3)
  points[8] = new point(W - margin*1.7, W/2-margin/3)
  //elbows
  points[13] = new point(margin*1.8, W/2+margin/3)
  points[14] = new point(W - margin*1.8, W/2+margin/3)
  //legs
  points[9] = new point(W/2 + margin/3, W/2+margin/2)
  points[10] = new point(W/2 - margin/3, W/2+margin/2)
  // feet
  points[11] = new point(W/2 + margin/3, W - margin/2)
  points[12] = new point(W/2 - margin/3, W - margin/2)
  // knees
  points[15] = new point(W/2 + margin/3, W-margin*1.5)
  points[16] = new point(W/2 - margin/3, W-margin*1.5)

  // 2,3,5 get petted together
  let py = pet(24)
  let px = pet(24)
  points[2].x += px
  points[2].y += py
  points[3].x += px
  points[3].y += py
  points[5].x += px
  points[5].y += py
  
  points[0].x += pet(24)
  points[0].y += pet(24)
  points[1].x += pet(24)
  points[1].y += pet(24)
  points[6].x += pet(24)
  points[6].y += pet(24)
  points[7].x += pet(24)
  points[7].y += pet(24)
  points[8].x += pet(24)
  points[8].y += pet(24)
  points[9].x += pet(24)
  points[9].y += pet(24)
  points[10].x += pet(24)
  points[10].y += pet(24)
  points[11].x += pet(24)
  points[11].y += pet(24)
  points[12].x += pet(24)
  points[12].y += pet(24)
  points[13].x += pet(24)
  points[13].y += pet(24)
  points[14].x += pet(24)
  points[14].y += pet(24)
  points[15].x += pet(24)
  points[15].y += pet(24)
  points[16].x += pet(24)
  points[16].y += pet(24)

  drawLine(ctx, points[0], points[1])
  drawLine(ctx, points[1], points[3])
  drawLine(ctx, points[0], points[2])
  drawLine(ctx, points[2], points[8])
  drawLine(ctx, points[3], points[7])

  drawLine(ctx, points[14], points[8])
  drawLine(ctx, points[13], points[7])

  drawLine(ctx, points[9], points[15])
  drawLine(ctx, points[10], points[16])
  drawLine(ctx, points[15], points[11])
  drawLine(ctx, points[16], points[12])

  ctx.beginPath()
  ctx.arc(points[5].x, points[5].y, margin/2.2, Math.PI, 2*Math.PI)
  ctx.stroke()
  ctx.beginPath()
  ctx.ellipse(points[6].x, points[6].y,  margin/4, margin/3, pet(100)/100,  0, 2*Math.PI) //head
  ctx.stroke()
}

function lamp () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  ctx.lineWidth = 0.5+document.getElementById("featuresize").value/10
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  let W = canvas.width
  let margin = W/8
  margin = 50 + (W-2*margin)/(2+Math.floor(Math.random() * 10))//document.getElementById("rows").value
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let grunge = document.getElementById("grungy").checked
  ctx.lineWidth = 0.5+document.getElementById("featuresize").value/10
  let r = 47 + Math.random() * 11

  let points = []
  points[0] = [W/2, margin]
  points[1] = [W/2, W/2]
  points[2] = [W/2, W-margin]

  points[3] = [W/2 - margin, W/2]
  points[4] = [W/2 - margin/3, margin]

  points[5] = [W/2 + margin, W/2]
  points[6] = [W/2 + margin/3, margin]

  points[7] = [W/2, W - margin]
  points[8] = [W/2, W/2-margin/2+25]

  points[9] = [W/2-20, W - 2*margin]
  points[10] = [W/2-20, W/2-margin/2+6]

  points[11] = [W/2, W/2-margin/2] //bulb

  let g = 11
  if (grunge)
    g *= 2
  let i = 0
  for (; i < points.length; i++) {
    points[i][0] += pet(g)
    points[i][1] += pet(g)
  }

  ctx.beginPath()
  ctx.moveTo(points[3][0], points[3][1])
  ctx.lineTo(points[4][0], points[4][1])
  ctx.stroke()

  ctx.beginPath()
  ctx.moveTo(points[5][0], points[5][1])
  ctx.lineTo(points[6][0], points[6][1])
  ctx.stroke()

  ctx.beginPath()
  ctx.moveTo(points[7][0], points[7][1])
  ctx.lineTo(points[8][0], points[8][1])
  ctx.stroke()

  ctx.beginPath()
  ctx.moveTo(points[9][0], points[9][1])
  ctx.lineTo(points[10][0], points[10][1]+25)
  ctx.stroke()

  ctx.beginPath()
  ctx.arc(points[9][0], points[9][1], 6+pet(3), 0, 2*Math.PI)
  ctx.stroke()

  ctx.beginPath()
  ctx.arc(points[11][0], points[11][1]-28, 54+pet(8), 0, 2*Math.PI)
  ctx.stroke()

  let radiusX = margin/3+pet(20), radiusY = margin/6+pet(10)
  ctx.beginPath()
  ctx.ellipse(points[0][0], points[0][1], radiusX, radiusY, pet(10)/100, 0, 2* Math.PI )
  ctx.stroke()

  radiusX = margin+pet(10), radiusY = margin/3+pet(20)
  ctx.beginPath()
  ctx.ellipse(points[1][0], points[1][1], radiusX, radiusY, pet(30)/100, 0, 2* Math.PI )
  ctx.stroke()

  radiusX = margin/3+pet(10), radiusY = margin/6+pet(10)
  ctx.beginPath()
  ctx.ellipse(points[2][0], points[2][1], radiusX, radiusY, pet(10)/100, 0, 2* Math.PI )
  ctx.stroke()

  ctx.beginPath()
  ctx.ellipse(points[2][0], points[2][1]+20+pet(10), radiusX, radiusY, 0, 0, 2* Math.PI )
  ctx.stroke()
}

function birdhouse () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  clip()
  let W = canvas.width
  let margin = W/5
  margin = 100 + (W-2*margin)/(2+Math.floor(Math.random() * 10))//document.getElementById("rows").value
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let grunge = document.getElementById("grungy").checked
  ctx.lineWidth = 0.5+document.getElementById("featuresize").value/10
  let r = 47 + Math.random() * 11

  let points = []
  points[0] = [margin, W/2+margin/2]
  points[1] = [margin*2, W/2-margin+margin/2]
  points[2] = [W-margin, W/2-margin+margin/2]
  points[3] = [W-margin*2, W/2+margin/2]
  
  points[4] = [(W/2), margin/2] //peak
  
  points[5] = [margin, margin+margin/2]
  points[6] = [margin*2, 0+margin/2]
  
  points[7] = [margin, W-margin+margin/2]
  points[8] = [margin*2, W-margin*2+margin/2]
  points[9] = [W-margin, W-margin*2+margin/2]
  points[10] = [W-margin*2, W-margin+margin/2]
  
  points[11] = [(W-margin*2+margin)/2 , (W-margin+margin/2+W/2+margin/2)/2]
  
  let g = 11
  if (grunge)
    g *= 2
  let i = 0
  for (; i < points.length; i++) {
    points[i][0] += pet(g)
    points[i][1] += pet(g)
  }
  
  ctx.lineCap = "round"
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  
  let flip = Math.random() > 0.5
  
  ctx.beginPath();
  ctx.moveTo(points[0][0], points[0][1])
  ctx.lineTo(points[4][0], points[4][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[1][0], points[1][1])
  ctx.lineTo(points[4][0], points[4][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[2][0], points[2][1])
  ctx.lineTo(points[4][0], points[4][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[3][0], points[3][1])
  ctx.lineTo(points[4][0], points[4][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[0][0], points[0][1])
  ctx.lineTo(points[7][0], points[7][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[1][0], points[1][1])
  ctx.lineTo(points[8][0], points[8][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[2][0], points[2][1])
  ctx.lineTo(points[9][0], points[9][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[3][0], points[3][1])
  ctx.lineTo(points[10][0], points[10][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[0][0], points[0][1])
  ctx.lineTo(points[1][0], points[1][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[1][0], points[1][1])
  ctx.lineTo(points[2][0], points[2][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[2][0], points[2][1])
  ctx.lineTo(points[3][0], points[3][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
   ctx.beginPath();
  ctx.moveTo(points[0][0], points[0][1])
  ctx.lineTo(points[3][0], points[3][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[9][0], points[9][1])
  ctx.lineTo(points[10][0], points[10][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()

  ctx.beginPath();
  ctx.moveTo(points[8][0], points[8][1])
  ctx.lineTo(points[9][0], points[9][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[7][0], points[7][1])
  ctx.lineTo(points[8][0], points[8][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.moveTo(points[7][0], points[7][1])
  ctx.lineTo(points[10][0], points[10][1])
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  
  ctx.beginPath();
  ctx.arc(points[11][0], points[11][1], r, 0, Math.PI * 2)
  if (grunge)
    ctx.lineWidth += pet(2)
  ctx.stroke()
  ctx.restore()
}
*/

function quads () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/4
  let R = canvas.height * 0.43
  let margin = R/20
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  if (document.getElementById("grungy").checked)
    colors = shuffle(['red', 'blue', 'yellow', 'orange', 'purple', "green"])

  let grunge = document.getElementById("grungy").checked
  let IA = 0
 // if (grunge)
 //   IA = Math.PI * 0.25
  let x = canvas.width/2, y = canvas.height/2
  ctx.fillStyle = (colors[0])
  ctx.beginPath()
  ctx.arc(x,y,R, IA+Math.PI * 0.25, IA+Math.PI * 1.25)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = (colors[1])
  ctx.beginPath()
  ctx.arc(x,y,R, IA+Math.PI * 1.25, IA+Math.PI * 0.25)
  ctx.closePath()
  ctx.fill()
  /*
  if (grunge) {
    ctx.fillStyle = (colors[2])
    ctx.beginPath()
    ctx.arc(x,y,R/2, Math.PI * 0, Math.PI * 2)
    ctx.closePath()
    ctx.fill()
  } else {*/
    ctx.fillStyle = (colors[2])
    ctx.beginPath()
    ctx.arc(x,y,R, IA+Math.PI * 0.75, IA+Math.PI * 1.75)
    ctx.closePath()
    ctx.fill()
    
    ctx.fillStyle = (colors[3])
    ctx.beginPath()
    ctx.arc(x,y,R, IA+Math.PI * 1.75, IA+Math.PI * 0.75)
    ctx.closePath()
    ctx.fill()
 // }
}

function venn () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/50
  let R = canvas.height * 0.31
  let margin = R/20
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  if (Math.random() > 0.5)
    colors = shuffle(['#ff00ff', '#ffff00', '#00ffff', '#7fff7f'])
  let inset = 20
  let grunge = document.getElementById("grungy").checked
  let IA = 0
  if (grunge)
    IA = Math.PI * 0.25
  let x = canvas.width/2, y = canvas.height/3+inset
  ctx.fillStyle = (colors[0])
  ctx.beginPath()
  ctx.arc(x,y,R, 0, Math.PI * 2)
  ctx.closePath()
  ctx.fill()
  
  x = canvas.width/3+inset, y = 2*canvas.height/3-inset
  ctx.fillStyle = (colors[1])
  ctx.beginPath()
  ctx.arc(x,y,R, 0, Math.PI * 2)
  ctx.closePath()
  ctx.fill()
  
  x = 2*canvas.width/3-inset, y = 2*canvas.height/3-inset
  ctx.fillStyle = (colors[3])
  ctx.beginPath()
  ctx.arc(x,y,R, 0, Math.PI * 2)
  ctx.closePath()
  ctx.fill()
}

function clock () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/4
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = W/2, cy = H/2
  let r1 = W/2.4, r2 = r1/2
  let today = new Date()
  let minute = today.getMinutes()
  let hour = today.getHours()*(60) + minute
  let minutescale = Math.PI*2/60
  let hourscale = Math.PI*2/(12*60)

  ctx.fillStyle = (colors[1])
  ctx.beginPath()
  ctx.moveTo(cx, cy+pet(9))
  ctx.arc(cx+pet(9), cy, r1+pet(4), Math.PI*1.5, minutescale*minute-Math.PI/2) // minutes
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = (colors[2])
  ctx.beginPath()
  ctx.moveTo(cx, cy)
  ctx.arc(cx, cy, r1, minutescale*minute-Math.PI/2, Math.PI*1.5) // anti minutes
  ctx.closePath()
  ctx.fill()
  
  ctx.save()
  ctx.beginPath()
  ctx.arc(cx+pet(13), cy+pet(13), r2+pet(3), 0, Math.PI*2) // anti minutes
  ctx.clip()
  ctx.clearRect(0,0,W,H)
  ctx.restore()
  
  ctx.fillStyle = (colors[3])
  ctx.beginPath()
  ctx.moveTo(cx, cy)
  ctx.arc(cx, cy, r2, Math.PI*1.5, hourscale*hour-Math.PI/2) // minutes
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = (colors[4])
  ctx.beginPath()
  ctx.moveTo(cx, cy)
  ctx.arc(cx, cy, r2, hourscale*hour-Math.PI/2, Math.PI*1.5) // anti minutes
  ctx.closePath()
  ctx.fill()
  
  let r3 = r2
  let step = (r1-r2)/4
  let a = 2 * Math.PI * Math.random()
  let i = 0
  for (; i < 5; i++) {
    
    x = cx + r3*Math.cos(a)
    y = cy + r3*Math.sin(a)
    ctx.save()
    ctx.beginPath()
    ctx.arc(x+pet(13), y+pet(8), r3/10+pet(13), 0, Math.PI*2)
    ctx.clip()
    ctx.clearRect(0,0,W,H)
    ctx.restore()
    ctx.fillStyle = randomPick(colors)
    ctx.beginPath()
    ctx.arc(x,y,r3/10 +pet(8),0,Math.PI*2)
    ctx.closePath()
    ctx.fill()
    r3 += step
    a = 2 * Math.PI * Math.random()
  }
}
function dayandnight () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/4
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = W/2, cy = cx
  let r1 = W/2.4, r2 = r1/2
 
  ctx.fillStyle = (colors[1])
  ctx.beginPath()
  ctx.moveTo(cx, cy+pet(9))
  ctx.arc(cx+pet(9), cy+pet(9), r1+pet(4), 0, Math.PI) // minutes
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = (colors[2])
  ctx.beginPath()
  ctx.moveTo(cx, cy+pet(9))
  ctx.arc(cx+pet(9), cy+pet(9), r1+pet(4), Math.PI, Math.PI*2) // minutes
  ctx.closePath()
  ctx.fill()

  let r3 = r1/15 + (Math.random() * 10)
  i = 0
  ctx.fillStyle = colors[0]
  for (; i < 25; i++) {
    cx = W * Math.random()
    cy = H/2 * Math.random()
    x = cx //+ r3*Math.cos(a)
    y = cy //+ r3*Math.sin(a)
    ctx.save()
    ctx.beginPath()
    ctx.arc(x+pet(8), y+pet(8), r3+pet(5), 0, Math.PI*2)
    ctx.clip()
    ctx.clearRect(0,0,W,H)
    ctx.restore()
   
    ctx.beginPath()
    ctx.arc(x,y,r3+pet(5),0,Math.PI*2)
    ctx.closePath()
    ctx.fill()
    r3 = r1/(10 + (Math.random() * 20))
    a = 2 * Math.PI * Math.random()
  }
  i = 0
  ctx.fillStyle = colors[3]
  for (; i < 25; i++) {
    cx = W * Math.random()
    cy = H/2+H/2 * Math.random()
    x = cx //+ r3*Math.cos(a)
    y = cy //+ r3*Math.sin(a)
    ctx.save()
    ctx.beginPath()
    ctx.arc(x+pet(8), y+pet(8), r3+pet(5), 0, Math.PI*2)
    ctx.clip()
    ctx.clearRect(0,0,W,H)
    ctx.restore()
    ctx.beginPath()
    ctx.arc(x,y,r3+pet(5),0,Math.PI*2)
    ctx.closePath()
    ctx.fill()
    r3 = r1/(10 + (Math.random() * 20))
    a = 2 * Math.PI * Math.random()
  }
}

function floral () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/4
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let CCW = true
  let x = 200, y = 200
  let r = W/8
  let i = 0
  for (; i < 100; i++) {
    x = Math.random() * W, y = Math.random() * H
    let a = Math.random() * 2 * Math.PI
    ctx.fillStyle = randomPick(colors)
    ctx.beginPath()
    let start = Math.PI*0.75, end = start + Math.PI/2
    //ctx.moveTo(x,y)
    ctx.ellipse(x, y, r, r, a, start, end)
    ctx.ellipse(x - r*1.44, y, r, r, a, end+Math.PI/2, end+Math.PI)
    ctx.closePath()
    ctx.fill()
  }
}

function system () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/4
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let pad = W/20 - pet(30)
  let points = randomPick([90,18,31,33,50,52,56,76,43,44,45])
  ctx.fillStyle = colors[1]
  ctx.clearRect(0,0,W,H)
  ctx.fillStyle = colors[2]
  let incs = (Math.PI* 2)/(points*2)
  let r1 = W/8, r2 = r1/1.2+pet(30)
  let a = 0, cx = W/4, cy = H/4
  let i = 1, maxp = points*2
  ctx.beginPath()
  let x = cx + r1 * Math.cos(a),
      y = cy + r1 * Math.sin(a)
  ctx.moveTo(x,y)
  for (; i < maxp; i++) {
    let r = (i % 2 === 0)? r1: r2;
    a += incs
    x = cx + r * Math.cos(a)
    y = cy + r * Math.sin(a)
    ctx.lineTo(x,y)
  }
  ctx.closePath()
  ctx.fill()
  ctx.save()
  ctx.beginPath()
  ctx.arc(cx+pet(13), cy+pet(13), r2+pet(3), 0, Math.PI*2) // anti minutes
  ctx.clip()
  ctx.clearRect(0,0,W,H)
  ctx.restore()
  ctx.fillStyle = colors[3]
  ctx.beginPath()
  ctx.arc(cx,cy,r2,0,Math.PI*2)
  ctx.closePath()
  ctx.fill()
  
  i = 0//, cy += H/7
  for (; i < 3; i++) {
   // cy += H/6
    cy += r2 * 2.5
    r2 /= 1.4 //+ pet(16)
    ctx.beginPath()
    x = cx + r1 * Math.cos(a),
    y = cy + r1 * Math.sin(a)
    ctx.save()
    ctx.beginPath()
    ctx.arc(cx+pet(13), cy+pet(13), r2+pet(3), 0, Math.PI*2) // anti minutes
    ctx.clip()
    ctx.clearRect(0,0,W,H)
    ctx.restore()
    ctx.fillStyle = randomPick(colors)
    ctx.beginPath()
    ctx.arc(cx,cy,r2,0,Math.PI*2)
    ctx.closePath()
    ctx.fill()
  }
  
  cx = 3*W/4, cy = 2*r1/1.2, i = 0
  for (; i < 5; i++) {
    r2 = 7 + Math.random() * 5
    if (i > 2)
      r2 *= 1.5
    ctx.beginPath()
    x = cx + r1 * Math.cos(a),
    y = cy + r1 * Math.sin(a)
   
    ctx.save()
    ctx.beginPath()
    ctx.arc(cx+pet(13), cy+pet(13), r2+pet(3), 0, Math.PI*2) // anti minutes
    ctx.clip()
    ctx.clearRect(0,0,W,H)
    ctx.restore()
    ctx.fillStyle = randomPick(colors)
    ctx.beginPath()
    ctx.arc(cx,cy,r2,0,Math.PI*2)
    ctx.closePath()
    ctx.fill()
    cy += H/6

  }
}

function star () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/4
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let pad = W/20 - pet(30)
  let points = randomPick([180, 100, 90, 18,31,33,20,21,22,76,43,44,45])
  ctx.fillStyle = colors[1]
  ctx.clearRect(0,0,W,H)
  ctx.fillStyle = colors[2]
  let incs = (Math.PI* 2)/(points*2)
  let r1 = W/2.5, r2 = r1/1.6+pet(90)
  let a = 0, cx = W/2, cy = H/2
  let i = 1, maxp = points*2
  ctx.beginPath()
  let x = cx + r1 * Math.cos(a),
      y = cy + r1 * Math.sin(a)
  ctx.moveTo(x,y)
  for (; i < maxp; i++) {
    let r = (i % 2 === 0)? r1: r2;
    a += incs
    x = cx + r * Math.cos(a)
    y = cy + r * Math.sin(a)
    ctx.lineTo(x,y)
  }
  ctx.closePath()
  ctx.fill()
  ctx.save()
  ctx.beginPath()
  ctx.arc(cx+pet(13), cy+pet(13), r2+pet(3), 0, Math.PI*2) // anti minutes
  ctx.clip()
  ctx.clearRect(0,0,W,H)
  ctx.restore()
  ctx.fillStyle = colors[3]
  ctx.beginPath()
  ctx.arc(cx,cy,r2,0,Math.PI*2)
  ctx.closePath()
  ctx.fill()
  if (document.getElementById("grungy").checked) {
    document.getElementById("caption").value = randomPick(placenames_stars)
    randomPick(getCurrentPalette()) // was paintcolor = colors[0]
    caption()
  }
}

function makePalette () {
  let canvas = document.getElementById("palettecanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/4
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let alt = document.getElementById("grungy").checked
  let colors = getCurrentPalette()
  if (ctx.globalAlpha == 1)
    alert("Set opacity to < 1.0 for remix.")
  let mixcolor = randomPick(getCurrentPalette()) // was paintcolor
  if (!alt) {
    ctx.fillStyle = mixcolor // mix with paintcolor
    ctx.fillRect(0,0,W,H)
    ctx.fillStyle = colors[0]
    ctx.fillRect(0, 0, W/5, H)
    ctx.fillStyle = colors[1]
    ctx.fillRect(W/5, 0, W/5, H)
    ctx.fillStyle = colors[2]
    ctx.fillRect(2*W/5, 0, W/5, H)
    ctx.fillStyle = colors[3]
    ctx.fillRect(3*W/5, 0, W/5, H)
    ctx.fillStyle = colors[4]
    ctx.fillRect(4*W/5, 0, W/5, H)
  } else {
    //color = shuffle(colors) // internal mix
    ctx.fillStyle = colors[0]
    ctx.fillRect(0, 0, W, H)
    ctx.fillStyle = colors[1]
    ctx.fillRect(W/5, 0, W, H)
    ctx.fillStyle = colors[2]
    ctx.fillRect(2*W/5, 0, W, H)
    ctx.fillStyle = colors[3]
    ctx.fillRect(3*W/5, 0, W, H)
    ctx.fillStyle = colors[4]
    ctx.fillRect(4*W/5, 0, W, H)
  }
  extractPalette(canvas)
}

function waves () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  ctx.lineWidth = 1 + Math.floor(document.getElementById("featuresize").value/10)
  inc = ctx.lineWidth * 2
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let pad = 0
  let x = pad, y = -20//pad
  ctx.strokeStyle = color
  ctx.fillStyle = color
  let i = 0, offset = 0
  while (y < H+40) {
    ctx.beginPath()
    ctx.moveTo(x,y)
    while (x < W - pad) {
      x += 3
      y = y + Math.sin((x+offset)/inc) * 2
      ctx.lineTo(x,y)
    }
    ctx.stroke()
    y += inc
    x = pad
    //offset += inc * 8
  }
}

function rings () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/4
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let pad = W/20 - pet(30)
  ctx.fillStyle = colors[1]
  ctx.clearRect(0,0,W,H)
  ctx.fillStyle = colors[2]
  ctx.clearRect(pad,pad,W-pad*2,H-pad*2)

  let r = H*0.75 + pet(200), r2 = r*(0.6 + (Math.random()/3))
  let x = W/2 + pet(W/1.2), y = H + H/9
 
  let i = 0
  
  // fill center
  ctx.fillStyle = randomPick(colors)
  ctx.beginPath()
  ctx.arc(x, y, r2 * 0.5, 2*Math.PI, 0)
  ctx.closePath()
  ctx.fill()
    
  for ( ; i < 3; i++) {
    ctx.fillStyle = randomPick(colors)
    ctx.beginPath()
    ctx.arc(x,y,r,Math.PI, 0)
    ctx.arc(x,y,r2,0, Math.PI, true)
    ctx.closePath()
    ctx.fill()
    r = r2 * 0.95
    r2 = r * 0.8
  }
  i = 0
  for (; i < 5; i++) {
    y = Math.random() * H
    x = Math.random() * W
    r = 25+pet(10)
    ctx.save()
    ctx.beginPath()
    ctx.arc(x+pet(13), y+pet(13), r+2+pet(7), 0, Math.PI*2) // anti minutes
    ctx.clip()
    ctx.clearRect(0,0,W,H)
    ctx.restore()
    ctx.fillStyle = randomPick(colors)
    ctx.beginPath()
    ctx.arc(x,y,r+pet(7),0,Math.PI*2)
    ctx.closePath()
    ctx.fill()
  }
}

function planet () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/4
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let pad = W/20 - pet(30)
  
  ctx.fillStyle = colors[1]
  ctx.clearRect(0,0,W,H)
  ctx.fillStyle = colors[2]
  
  ctx.clearRect(pad,pad,W-pad*2,H-pad*2)

  ctx.fillRect(pad+pet(13), pad+pet(13), W-pad*2+pet(13), H-pad*2+pet(13))
  let r = (H - 3 * pad)/2.9
  let x = W/2, y = 1.3*pad + r
  
  ctx.save()
  ctx.beginPath()
  ctx.arc(x+pet(13), y+pet(13), r+pet(3), 0, Math.PI*2) // anti minutes
  ctx.clip()
  ctx.clearRect(0,0,W,H)
  ctx.restore()
  ctx.fillStyle = colors[3] // clip each arc
  ctx.beginPath()
  ctx.arc(x,y,r,0,Math.PI*2)
  ctx.closePath()
  ctx.fill()
  
  y = H - pad*3.2
  x = W/4
  ctx.save()
  ctx.beginPath()
  ctx.arc(x+pet(13), y+pet(13), r/7+pet(3), 0, Math.PI*2) // anti minutes
  ctx.clip()
  ctx.clearRect(0,0,W,H)
  ctx.restore()
  
  ctx.fillStyle = colors[4]
  ctx.beginPath()
  ctx.arc(x,y,r/7,0,Math.PI*2)
  ctx.closePath()
  ctx.fill()
  
  y = H - pad*2.4
  x = W/2
  ctx.save()
  ctx.beginPath()
  ctx.arc(x+pet(13), y+pet(13), r/12+pet(3), 0, Math.PI*2) // anti minutes
  ctx.clip()
  ctx.clearRect(0,0,W,H)
  ctx.restore()
  ctx.fillStyle = colors[0]
  ctx.beginPath()
  ctx.arc(x,y,r/12,0,Math.PI*2)
  ctx.closePath()
  ctx.fill()
  
  y = H - pad*3.2
  x = W-W/4
  ctx.save()
  ctx.beginPath()
  ctx.arc(x+pet(13), y+pet(13), r/19+pet(3), 0, Math.PI*2) // anti minutes
  ctx.clip()
  ctx.clearRect(0,0,W,H)
  ctx.restore()
  ctx.fillStyle = colors[1]
  ctx.beginPath()
  ctx.arc(x,y,r/19,0,Math.PI*2)
  ctx.closePath()
  ctx.fill()
}

function bust () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/4
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let CCW = true
  let x = 0, y =  H/2, cx, cy
  let r = W/6
  
  ctx.fillStyle = (colors[1])
  ctx.beginPath()
 // ctx.moveTo(W, H)
 // ctx.lineTo(0,H) // left bottom
  // control point first
  x = 50
  y =  H/2
  cx = 100
  cy = H/3
  ctx.moveTo(0,H)
  ctx.quadraticCurveTo(cx, cy, 2*W/5, H/2)
  ctx.arc(2*W/5, H/2, 250, Math.PI*0.75, Math.PI*0.25)
  cx = W-100
  
  ctx.quadraticCurveTo(cx, cy, 4*W/5, H)

  x = W
  y = H/2
  cx = W
  cy = H

 // ctx.quadraticCurveTo(cx, cy, x, y)

  ctx.lineTo(W, H)

  ctx.closePath()
  ctx.fill()
}

function bust__ () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/4
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let CCW = true
  let x = 0, y = H - H/6 + 30
  let r = W/6
  
  ctx.fillStyle = (colors[1])
  ctx.beginPath()
  ctx.moveTo(W, H)
  ctx.lineTo(0,H)
  ctx.lineTo(0,y)
  x = W/6
  ctx.arc(x, y, r, Math.PI, Math.PI * 1.5) // left shoulder
  x = W/2-W/3
  y = H/2 + 30
  ctx.arc(x, y, r, Math.PI/2, 0, CCW) // left neck

  /*x = W/2
  y = H/2- 60
  ctx.arc(x, y, r*1.05, Math.PI, 0, CCW) // chin*/
  x = W/2, y = H/3
   // ctx.beginPath()
  ctx.ellipse(x, y, r*1.2, r*1.7, 0, Math.PI * 0.8, Math.PI * 0.2)
  x = W/2+W/3

  y = H/2 + 30
  ctx.arc(x, y, r, Math.PI, Math.PI/2, CCW)  // right neck
  
  x = W-W/6, y = H - H/6+30
  ctx.arc(x, y, r, Math.PI*1.5, 0) // right shoulder
  ctx.closePath()
  ctx.lineTo(W,H)
  ctx.fill()

   // lower face
    x = W/2, y = H/3
    ctx.beginPath()
    ctx.ellipse(x, y, r*1.2, r*1.7, 0, Math.PI * 0.8, Math.PI * 0.2)
    ctx.closePath()
   // ctx.fill()
    /*
x = W/2, y =  r + r/2
    ctx.beginPath()
    ctx.arc(x, y, r, Math.PI, 0) // right shoulder
    ctx.closePath()
    ctx.fill()*/
}

function seasons () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/4
  let R = canvas.height * 0.15, r = R*2
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let a = Math.random() * 2 * Math.PI

  let R2 = R*0.7
  //sun
  /*
  ctx.lineWidth = 10
  ctx.setLineDash([28, 28]);
  ctx.strokeStyle = colors[3]
  ctx.beginPath()
  //ctx.arc(cx, cy, R*2.3, 0, Math.PI * 2)
  ctx.ellipse(cx, cy, R*2.3, R*1.5, 0, 0, Math.PI*2);
  ctx.stroke()*/
  
  // bottomr disc
  ctx.fillStyle = (colors[1])
  ctx.beginPath()
  ctx.arc(cx, cy/1.8, R2, 0, Math.PI * 2)
  ctx.closePath()
  ctx.fill()
  ctx.fillStyle = (colors[2])
  ctx.beginPath()
  ctx.arc(cx, cy/1.8, R2, 0, Math.PI*3)
  ctx.closePath()
  ctx.fill()
  //moon
  ctx.fillStyle = (colors[1])
  ctx.beginPath()
  ctx.arc(canvas.width - cx/3, cy, R2, 0, Math.PI * 2)
  ctx.closePath()
  ctx.fill()
  ctx.fillStyle = (colors[2])
  ctx.beginPath()
  ctx.arc(canvas.width - cx/3, cy, R2, Math.PI*0.75, Math.PI * 1.75)
  ctx.closePath()
  ctx.fill()
  // sun
  ctx.fillStyle = colors[0]
  ctx.beginPath()
  ctx.arc(cx, cy, R, 0, Math.PI * 2)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = (colors[1])
  ctx.beginPath()
  ctx.arc(cx/3, cy, R2, 0, Math.PI * 2)
  ctx.closePath()
  ctx.fill()
  ctx.fillStyle = (colors[2])
  ctx.beginPath()
  ctx.arc(cx/3, cy, R2, Math.PI*1.75, Math.PI * 0.75)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = (colors[1])
  ctx.beginPath()
  ctx.arc(cx, canvas.height - cy/1.8, R2, 0, Math.PI * 2)
  ctx.closePath()
  ctx.fill()
  
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function roomOG () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/4
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())//['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  //moons
  let mult = Math.random()
  let i = 0
  ctx.lineJoin = "round"
  ctx.fillStyle = (colors[0])
  ctx.strokeStyle = (colors[0])
  let max = 5*360 + Math.random()*120
  let x,y
  let H = canvas.height, W = canvas.width
  ctx.beginPath()
  x = 0, y = H/3
  ctx.moveTo(x+pet(30),y+pet(30))
  x = 2*W/3
  ctx.lineTo(x+pet(30),y+pet(30))
  y *= 2
  ctx.lineTo(x+pet(30),y+pet(30))
  x = 0
  ctx.lineTo(x+pet(30),y+pet(30))
  x = 2*W/3
  ctx.lineTo(x+pet(30),y+pet(30))
  y = 3*H/4
  x = W
  ctx.lineTo(x+pet(30),y+pet(30))
  y = 2*H/3
  x = 2*W/3
  ctx.lineTo(x+pet(30),y+pet(30))
  y = H/3
  x = 2*W/3
  ctx.lineTo(x+pet(30),y+pet(30))
  y = H/4
  x = W
  ctx.lineTo(x+pet(30),y+pet(30))
  ctx.stroke()
  
  ctx.beginPath()
  x = W/2-W/20, y = 2*H/3
  ctx.moveTo(x+pet(30),y+pet(30))
  x = W/2 + W/10
  ctx.lineTo(x+pet(30),y+pet(30))
  y = H/2 -H/10
  ctx.lineTo(x+pet(30),y+pet(30))
  x = W/2-W/20
  ctx.lineTo(x+pet(30),y+pet(30))
  y = 2 *H/3+pet(2)
  ctx.lineTo(x+pet(30),y+pet(30))

  ctx.stroke()
  
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function automatic () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/50
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())//['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let R = 20//canvas.height * 0.1, r = R*2
  let R2 = R*3
  R = R2*0.85
  let alt = true//document.getElementById("grungy").checked
  let mult = Math.random()
  let i = 0
  let start = Math.PI *1.7
  let inc = Math.PI * 2/360
  x=18,y=180

  R = R2
  ctx.lineJoin = "round"
  ctx.fillStyle = (colors[0])
  let b = 0, sign = 1
  ctx.strokeStyle = (colors[0])
  ctx.beginPath()
  let max = 5*360
  let a = Math.random() * 2 * Math.PI, ax = start
  let drift = 0.01
  let dir = true//(Math.random() > 0.5)? true : false;

  for (; i < max; i++) {
   // R += b
    if (R < 0.1 || R > R2)
      R = R2*0.8
    ctx.ellipse(x, y, R2, R, a, start, start-inc, dir)
    start -= inc
    if (Math.random() > 0.98)
      sign *= -1
    b += sign * 0.02

    x += 0.4 + pet (0.6)
    y += pet(3)
  }
  ctx.stroke()
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}
 
function natural () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let x = LASTCLICK[0], y = LASTCLICK[1]
  let R = 11 + document.getElementById("featuresize").value/2
  ctx.lineWidth = 1 + R/34
  let R2 = R*2
  let alt = document.getElementById("grungy").checked
  let mult = Math.random()
  let i = 0
  let start = Math.PI *1.7
  let inc = Math.PI * 2/360
  ctx.lineJoin = "round"
  let b = 0, sign = 1
  ctx.strokeStyle = (colors[0])
  ctx.beginPath()
  let max = 2.4*360 + Math.random()*120
 // max = R*10
  console.log(max, R)
  if (alt) {
    ctx.lineWidth = 1
  }
  let a = Math.random() * 2 * Math.PI, ax = start
  let drift = 0.01
  let dir = true
  for (; i < max; i++) {
    ctx.ellipse(x, y, R2, R+b, a, start, start-inc, dir)
    ax = inc
    start -= inc
    if (Math.random() > 0.98)
      sign *= -1
    b += sign * 0.3
    if (R+b < 0)
      R = R2
     R2 /= 1.00002
     R *= 1.0002
     if (R2 < 0)
       R2 *= -1
  }
  ctx.stroke()
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function room () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/50
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())//['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let a = Math.random() * 2 * Math.PI
  let H = canvas.height, W = canvas.width
  let pad = 100
  ctx.strokeStyle = (colors[0])
  ctx.lineCap = "square"
  ctx.lineJoin = "square"
  ctx.fillStyle = (colors[0])
  ctx.beginPath()
  x = W - pad - ctx.lineWidth*1.5, y = H-pad
  //ctx.strokeRect(pad, pad, W-pad*2, H-pad*2)
  let i = 0
  for (; i < 1; i++) {
    ctx.beginPath()
    ctx.moveTo(2*W/3-pad,pad)
    ctx.lineTo(pad,pad)
    ctx.lineTo(pad,H-pad)
    ctx.lineTo(W-pad,H-pad)
    ctx.lineTo(W-pad,pad)
    ctx.lineTo(W-pad-40,pad)
    ctx.lineTo(W-pad-W/4,pad*2.5)
    ctx.stroke()
    pad*=2
  }

  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}


function thought_og () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/50
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())//['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let a = Math.random() * 2 * Math.PI
  let H = canvas.height, W = canvas.width
  let pad = 80, cpx = 0, cpy = 0
  ctx.strokeStyle = (colors[0])
  ctx.lineCap = "round"
  ctx.lineJoin = "round"
  ctx.fillStyle = (colors[0])
  x = W - pad - ctx.lineWidth*1.5, y = H-pad
  let r = W/3, xo = r
 // ctx.beginPath()
  let alt = document.getElementById("grungy").checked
  x = W/2
  y = H/2-pad
  ctx.beginPath()
  ctx.arc(x, y, r, 0, Math.PI*2)
  if (alt)
    ctx.fill()
  else
    ctx.stroke()
  ctx.beginPath()
  ctx.arc(W/4 +r/15, H-pad*3, r/7, 0, Math.PI*2)
  if (alt)
    ctx.fill()
  else
    ctx.stroke()
  ctx.beginPath()
  ctx.arc(W/6, H-pad*2, r/12, 0, Math.PI*2)
  if (alt)
    ctx.fill()
  else
    ctx.stroke()
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}


function talk () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/50
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())//['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let a = Math.random() * 2 * Math.PI
  let H = canvas.height, W = canvas.width
  let pad = 80, cpx = 0, cpy = 0
  ctx.strokeStyle = (colors[0])
  ctx.lineCap = "round"
  ctx.lineJoin = "round"
  ctx.fillStyle = (colors[0])
  x = W - pad - ctx.lineWidth*1.5, y = H-pad
  let r = W/3, xo = r
  ctx.beginPath()
  x = W/2
  y = H/2-pad
  ctx.arc(x, y, r, Math.PI/2 + Math.PI/5, Math.PI/2 +Math.PI/10) // thumb
  ctx.lineTo(W/5, H-pad*2)
  ctx.closePath()

  if (document.getElementById("grungy").checked) {
    ctx.fill()
  } else
    ctx.stroke()
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}


function heart () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/50
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())//['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let a = Math.random() * 2 * Math.PI
  let H = canvas.height, W = canvas.width
  let pad = 80, cpx = 0, cpy = 0
  ctx.strokeStyle = (colors[0])
  ctx.lineCap = "round"
  ctx.lineJoin = "round"
  ctx.fillStyle = (colors[0])
  ctx.beginPath()
  x = W - pad - ctx.lineWidth*1.5, y = H-pad
  let r = W/4-pad, xo = r
  ctx.beginPath()
  ctx.moveTo(W/2, H-pad*2)
  cpx = pad*2
  cpy = H*.57
  ctx.quadraticCurveTo(cpx,cpy,pad*2, H/3)
  x = W/4+pad
  y = H/3
  ctx.arc(x, y, r, Math.PI, Math.PI*2) // thumb
  x += r*2
  ctx.arc(x, y, r, Math.PI, Math.PI*2) // thumb
  cpx = W - pad*2
  cpy = H*.57
  ctx.quadraticCurveTo(cpx,cpy,W/2, H-pad*2)
  
  if (document.getElementById("grungy").checked) {
    ctx.closePath()
    ctx.fill()
  } else
    ctx.stroke()
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function ivy () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/50
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())//['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let x = 0, y = 0
  let a = Math.random() * 2 * Math.PI
  let H = canvas.height, W = canvas.width
  let pad = 40, i = 0
  let r1 = W/2-pad, r2 = W/4, r3 = 20
  let cx = W/2, cy = W*0.55
  ctx.clearRect(0,0,W,H)
  ctx.strokeStyle = (colors[0])
  ctx.lineCap = "round"
  ctx.lineJoin = "round"
  ctx.fillStyle = (colors[0])
  
  let K = randomPick([3,4,5])
  let angle = Math.PI + Math.PI/6 // good for three K
  let cangle = Math.PI

  if (K === 4) {
    angle = Math.PI
    cangle = angle - Math.PI/6
  }
    
  if (K === 5) {
    angle = Math.PI - Math.PI/6
    cangle = angle - Math.PI/6
  }
  ctx.beginPath()
  x = W - pad - ctx.lineWidth*1.5, y = H-pad
  let cpx = r1 * Math.cos(cangle)+cx;
  let cpy = r1 * Math.sin(cangle)+cy;
  let rx = 9 * Math.cos(cangle)+cx;
  let ry = 9 * Math.sin(cangle)+cy;
  let x0 = rx, y0 = ry
  ctx.beginPath()
  ctx.moveTo(rx,ry)
  for (;i < K; i++) {
    x = r1 * Math.cos(angle)+cx;
    y = r1 * Math.sin(angle)+cy;
    x+= pet(66), y += pet(66)
    ctx.quadraticCurveTo(cpx,cpy,x,y)
    cangle += Math.PI/3
    cpx = r1 * Math.cos(cangle)+cx;
    cpy = r1 * Math.sin(cangle)+cy;
    cpx+= pet(66), cpy += pet(66)

    rx = 9 * Math.cos(cangle)+cx;
    ry = 9 * Math.sin(cangle)+cy;
    rx+= pet(33), ry += pet(33)

    ctx.quadraticCurveTo(cpx,cpy,rx,ry)
    angle += Math.PI/3
  }
  ctx.lineTo(rx+15,H-80)
  ctx.lineTo(rx-25,H-80)
  ctx.lineTo(x0, y0)
  if (document.getElementById("grungy").checked) {
    ctx.closePath()
    ctx.fill()
  } else
    ctx.stroke()

  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function hand () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/50
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())//['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let a = Math.random() * 2 * Math.PI
  let H = canvas.height, W = canvas.width
  let pad = 40
  ctx.strokeStyle = (colors[0])
  ctx.lineCap = "round"
  ctx.lineJoin = "round"
  ctx.fillStyle = (colors[0])
  ctx.beginPath()
  x = W - pad - ctx.lineWidth*1.5, y = H-pad
  let r = H*0.25, xo = r/10
  ctx.beginPath()
  ctx.arc(W/2, W*0.65, r, 0, Math.PI)
  ctx.lineTo(W/2 - r, H/2)
  x = W/2-r+xo*2
  y = H/2
  ctx.arc(x, y, xo*2, Math.PI, Math.PI*2) // thumb
  x += xo*2
  y = H/2 + H/8
  ctx.lineTo(x, y)
  y = H/4
  ctx.lineTo(x, y)
  x += xo*2
  ctx.arc(x, y, xo*2, Math.PI, Math.PI*2) // index
  
  x += xo*2
  y = H/2
  ctx.lineTo(x, y)
  y =H/5
  ctx.lineTo(x, y)
  x += xo*2
  ctx.arc(x, y, xo*2, Math.PI, Math.PI*2) // middle

  x += xo*2
  y = H/2
  ctx.lineTo(x, y)
  y =H/4
  ctx.lineTo(x, y)
  x += xo*2
  ctx.arc(x, y, xo*2, Math.PI, Math.PI*2) // ring
  
  x += xo*2
  y = H/2 + H/20
  ctx.lineTo(x, y)
  y =H/2.8
  ctx.lineTo(x, y)
  x += xo*2
  ctx.arc(x, y, xo*2, Math.PI, Math.PI*2) // pinkey
  x += xo*2
  y = H/2 +H/6.1
  ctx.lineTo(x, y)
  if (document.getElementById("grungy").checked) {
    ctx.closePath()
    ctx.fill()
  } else
    ctx.stroke()
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function tv () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/50
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())//['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let a = Math.random() * 2 * Math.PI
  let H = canvas.height, W = canvas.width
  let pad = 40
  ctx.strokeStyle = (colors[0])
  ctx.lineCap = "round"
  ctx.lineJoin = "round"
  ctx.fillStyle = (colors[0])
  ctx.beginPath()
  x = W - pad - ctx.lineWidth*1.5, y = H-pad
  ctx.strokeRect(pad, pad, W-pad*2, H-pad*2)
  roundedRectFrame (pad*3, pad*3, W-pad*9, H-pad*6, pad*2, ctx)
  
  ctx.beginPath()
  ctx.arc(W-pad*3.5, pad*5, pad, 0, Math.PI*2)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.arc(W-pad*3.5, pad*8, pad/2, 0, Math.PI*2)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.arc(W-pad*3.5, pad*10, pad/2, 0, Math.PI*2)
  ctx.stroke()
  
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}


function envelope () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/50
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())//['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let a = Math.random() * 2 * Math.PI
  let H = canvas.height, W = canvas.width
  let pad = 40
  ctx.strokeStyle = (colors[0])
  ctx.lineCap = "round"
  ctx.lineJoin = "round"
  ctx.fillStyle = (colors[0])
  ctx.beginPath()
  x = W - pad - ctx.lineWidth*1.5, y = H-pad
  ctx.moveTo(x,y)
  x = pad
  ctx.lineTo(x,y)
  y = cy
  ctx.lineTo(x,y)
  x = cx, y = pad*2
  ctx.lineTo(x,y)
  x = W - pad, y = cy
  ctx.lineTo(x,y)
  x = pad + ctx.lineWidth * 1.5
  ctx.lineTo(x,y)
  x = W - pad
  y = H - pad - ctx.lineWidth*0
  ctx.lineTo(x,y)
  y = cy + ctx.lineWidth
  ctx.lineTo(x,y)
  x = pad + ctx.lineWidth
  y = H - pad - ctx.lineWidth
  ctx.lineTo(x,y)
  ctx.stroke()
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function phase () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/50
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())//['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let a = Math.random() * 2 * Math.PI
  let R = canvas.height * 0.1, r = R*2
  let R2 = R*3
  ctx.strokeStyle = (colors[0])
  //moon
  let mult = Math.random()
  x=cx,y=cy
  ctx.fillStyle = (colors[0])
  if (Math.random() > 0.5) {
    ctx.beginPath()
    ctx.ellipse(x, y, R2*mult, R2, 0, Math.PI * 1.5, Math.PI/2)
    ctx.ellipse(x, y, R2, R2, 0, Math.PI/2, Math.PI*1.5, true)
    ctx.stroke()
  } else {
    ctx.beginPath()
    ctx.ellipse(x, y, R2*mult, R2, 0, Math.PI * 1.5, Math.PI/2, true)
    ctx.ellipse(x, y, R2, R2, 0, Math.PI/2, Math.PI*1.5)
    ctx.stroke()
  }
  ctx.beginPath()
  ctx.ellipse(x, y, R2, R2, 0, 0, Math.PI * 2, true)
  ctx.stroke()
  ctx.strokeRect(cx-r*2, cy-r*2, r*4, r*4)
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function phases () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/50
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())//['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let a = Math.random() * 2 * Math.PI
  let R = canvas.height * 0.1, r = R*2
  let R2 = R
  // background
  let R3 = R+r
  // left disc
  ctx.fillStyle = colors[2]
  ctx.beginPath()
  ctx.arc(-R/4, cy, R+r, 0, Math.PI * 2)
  ctx.closePath()
  ctx.fill()
  // bottomr disc
  ctx.fillStyle = (colors[2])
  ctx.beginPath()
  ctx.arc(cx+cx/3, cy, R2, Math.PI/2, Math.PI * 1.5)
  ctx.closePath()
  ctx.fill()
  ctx.fillStyle = (colors[3])
  ctx.beginPath()
  ctx.arc(cx+cx/3, cy, R2, Math.PI * 1.5, Math.PI/2)
  ctx.closePath()
  ctx.fill()
  //moons
  R2 *= 0.4
  ctx.fillStyle = (colors[2])
  ctx.beginPath()
  ctx.arc(cx+cx/3, cy+cy/3, R2, Math.PI/2, Math.PI * 1.5)
  ctx.closePath()
  ctx.fill()
  ctx.fillStyle = (colors[3])
  ctx.beginPath()
  ctx.arc(cx+cx/3, cy+cy/3, R2, Math.PI * 1.5, Math.PI/2)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = (colors[2])
  ctx.beginPath()
  ctx.arc(cx+cx/3, cy-cy/3, R2, Math.PI/2, Math.PI * 1.5)
  ctx.closePath()
  ctx.fill()
  ctx.fillStyle = (colors[3])
  ctx.beginPath()
  ctx.arc(cx+cx/3, cy-cy/3, R2, Math.PI * 1.5, Math.PI/2)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = (colors[2])
  ctx.beginPath()
  ctx.arc(cx+2*cx/3, cy, R2, Math.PI/2, Math.PI * 1.5)
  ctx.closePath()
  ctx.fill()
  ctx.fillStyle = (colors[3])
  ctx.beginPath()
  ctx.arc(cx+2*cx/3, cy, R2, Math.PI * 1.5, Math.PI/2)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = (colors[2])
  ctx.beginPath()
  ctx.arc(cx, cy, R2, Math.PI/2, Math.PI * 1.5)
  ctx.closePath()
  ctx.fill()
  ctx.fillStyle = (colors[3])
  ctx.beginPath()
  ctx.arc(cx, cy, R2, Math.PI * 1.5, Math.PI/2)
  ctx.closePath()
  ctx.fill()
  
  // phases across top
  y = canvas.height/10
  x = 80, mult = 1.0
  let i = 0
  for (; i < 5; i++) {
    ctx.fillStyle = (colors[2])
    ctx.beginPath()
    ctx.ellipse(x, y, R2*mult, R2, 0, Math.PI * 1.5, Math.PI/2)
    ctx.ellipse(x, y, R2, R2, 0, Math.PI/2, Math.PI * 1.5, true)
    ctx.closePath()
    ctx.fill()
    
    ctx.fillStyle = (colors[3])
    ctx.beginPath()
    ctx.ellipse(x, y, R2, R2, 0, Math.PI/2, Math.PI * 1.5)
    ctx.ellipse(x, y, R2*mult, R2, 0, Math.PI * 1.5, Math.PI/2)
    ctx.closePath()
    ctx.fill()
    x += R2 * 3
    mult -= 0.25
  }
  
  i = 0, mult = 0.25
  for (; i < 3; i++) {
    ctx.fillStyle = (colors[3])
    ctx.beginPath()
    ctx.ellipse(x, y, R2*mult, R2, 0, Math.PI/2, Math.PI * 1.5)
    ctx.ellipse(x, y, R2, R2, 0, Math.PI * 1.5, Math.PI/2, true)
    ctx.closePath()
    ctx.fill()
    
    ctx.fillStyle = (colors[2])
    ctx.beginPath()
    ctx.ellipse(x, y, R2, R2, 0, Math.PI * 1.5, Math.PI/2)
    ctx.ellipse(x, y, R2*mult, R2, 0, Math.PI/2, Math.PI * 1.5)
    ctx.closePath()
    ctx.fill()
    x += R2 * 3
    mult += 0.25
  }
  
  i = 0, x = 80, y = canvas.height - canvas.height/10, mult = 1.0
  for (; i < 5; i++) {
    ctx.fillStyle = (colors[3])
    ctx.beginPath()
    ctx.ellipse(x, y, R2*mult, R2, 0, Math.PI * 1.5, Math.PI/2)
    ctx.ellipse(x, y, R2, R2, 0, Math.PI/2, Math.PI * 1.5, true)
    ctx.closePath()
    ctx.fill()
    
    ctx.fillStyle = (colors[2])
    ctx.beginPath()
    ctx.ellipse(x, y, R2, R2, 0, Math.PI/2, Math.PI * 1.5)
    ctx.ellipse(x, y, R2*mult, R2, 0, Math.PI * 1.5, Math.PI/2)
    ctx.closePath()
    ctx.fill()
    x += R2 * 3
    mult -= 0.25
  }
    
  i = 0, mult = 0.25
  for (; i < 3; i++) {
    ctx.fillStyle = (colors[2])
    ctx.beginPath()
    ctx.ellipse(x, y, R2*mult, R2, 0, Math.PI/2, Math.PI * 1.5)
    ctx.ellipse(x, y, R2, R2, 0, Math.PI * 1.5, Math.PI/2, true)
    ctx.closePath()
    ctx.fill()
    
    ctx.fillStyle = (colors[3])
    ctx.beginPath()
    ctx.ellipse(x, y, R2, R2, 0, Math.PI * 1.5, Math.PI/2)
    ctx.ellipse(x, y, R2*mult, R2, 0, Math.PI/2, Math.PI * 1.5)

    ctx.closePath()
    ctx.fill()
    x += R2 * 3
    mult += 0.25
  }
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function tides () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/4
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/4, x = 0, y = 0
  let a = Math.random() * 2 * Math.PI
  let R = canvas.height * 0.24
  let R2 = R/2
  let moon = randomPick([1,2])
  // background
  let k = 0
  for (; k < 2; k++) {
    let R3 = R
    ctx.beginPath()
    ctx.moveTo(0,cy-R3)
    ctx.lineTo(0,cy+R3)
    ctx.lineTo(canvas.width,cy+R3)
    ctx.lineTo(canvas.width,cy-R3)
    ctx.closePath()
    // sun
    ctx.fillStyle = colors[0]
    ctx.beginPath()
    ctx.arc(-R/4, cy, R, 0, Math.PI * 2)
    ctx.closePath()
    ctx.fill()
    // earth
    let rotation = 0, mult = 0.9
    if (moon === 3 || moon === 4) // plane of sun
      rotation = Math.PI/2
    // moon tide
    ctx.fillStyle = (colors[2])
    ctx.beginPath()
    ctx.ellipse(cx+cx/3, cy, R2*0.8, R2*1.3, rotation, 0, Math.PI * 2)
    ctx.closePath()
    ctx.fill()
    // solar tide
    rotation = Math.PI/2
    ctx.fillStyle = (colors[0])
    ctx.beginPath()
    ctx.ellipse(cx+cx/3, cy, R2*0.8, R2*1.0, rotation, 0, Math.PI * 2)
    ctx.closePath()
    ctx.fill()
    // earth
    ctx.fillStyle = (colors[1])
    ctx.beginPath()
    ctx.arc(cx+cx/3, cy, R2*0.7, 0, Math.PI * 2)
    ctx.closePath()
    ctx.fill()
    //moons
    R3 = R2 * 0.3
    if (moon === 1) { // bottom
      ctx.fillStyle = (colors[2])
      ctx.beginPath()
      ctx.arc(cx+cx/3, cy+R2*1.3+70, R3, 0, Math.PI * 2)
      ctx.closePath()
      ctx.fill()
    }
    if (moon === 2) { // top
      ctx.fillStyle = (colors[2])
      ctx.beginPath()
      ctx.arc(cx+cx/3, cy-R2*1.3-70, R3, 0, Math.PI * 2)
      ctx.closePath()
      ctx.fill()
    }
    if (moon === 3) { // right
      ctx.fillStyle = (colors[2])
      ctx.beginPath()
      ctx.arc(cx+2*cx/3+80, cy, R3, 0, Math.PI * 2)
      ctx.closePath()
      ctx.fill()
    }
    if (moon === 4) {  //left
      ctx.fillStyle = (colors[2])
      ctx.beginPath()
      ctx.arc(cx-80, cy, R3, 0, Math.PI * 2)
      ctx.closePath()
      ctx.fill()
    }
    moon = randomPick([3,4])
    cy = canvas.height - canvas.height/4
  }
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function aura () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let alpha = document.getElementById("opacity").value
  let mode = document.getElementById("mode").value
  let size = 1+document.getElementById("featuresize").value/50
  let offset = size//canvas.width/200
  if (Math.random() > 0.5)
    offset *= -1
  offset *= size
  document.getElementById("rednumber").value = offset
  clearOff()
  copyToOff()
  
  if (document.getElementById("grungy").checked)
    motionblur()
  else {
    nudgeRight()
    if (Math.random() > 0.5)
      offset *= -1
    document.getElementById("rednumber").value = offset
    nudgeDown()
  }
  swapWithOff()
  swapWithOff()
  document.getElementById("mode").value = "difference"
  pasteFromOff()
  document.getElementById("mode").value = "source-over"
  tint()
  tint()
  tint()
  tint()
  alphaBlack(15)
  swapWithOff()
  document.getElementById("mode").value = "color"
  pasteFromOff()
  document.getElementById("opacity").value = alpha
  document.getElementById("mode").value = mode
}

function nudgehalfdown () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let alpha = document.getElementById("opacity").value
  clearOff()
  copyToOff()
  document.getElementById("rednumber").value = canvas.width/2
  LASTCLICK[0] = canvas.width/2
  leftClip()
  swapWithOff()
  flipH()
  leftClip()
  document.getElementById("rednumber").value = 10
  nudgeRight()
  flipH()
  swapWithOff()
  document.getElementById("rednumber").value = 30
  nudgeDown()
  let a = document.getElementById("opacity")
  document.getElementById("opacity").value = 100
  pasteFromOff()
  document.getElementById("opacity").value = a
  ctx.globalAlpha = alpha/100
}

function network () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 2+document.getElementById("featuresize").value/5
  ctx.lineCap = "round"
  let H  = canvas.height, W = canvas.width
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let colors = getCurrentPalette()
  if (document.getElementById("grungy").checked)
    colors = [randomPick(getCurrentPalette())] // was paintcolor]
  colors = shuffle(colors)
  ctx.strokeStyle = colors[0]
  let i = 0, numpoints = randomPick([6,7,8])
  let x = 0, y = 0
  let r = W/4 * 0.8
  let cx = W/4, cy = H/4
  let s = 0
  for (; s < 4; i++) {
    let points = []
    let a = Math.random() * 2 * Math.PI
    i = 0
    while (i < numpoints) {
      x = cx + r * Math.cos(a)
      y = cy + r * Math.sin(a)
      points.push([x+pet(9), y+pet(9)])
      a += Math.PI * 2/numpoints
      i++
    }
    let j = 0
    i = 0
    for (;i < points.length; i++) {
      j = i + 1
      for (; j < points.length; j++) {
        if (Math.random() < 0.2) {
          ctx.beginPath()
          ctx.moveTo(points[i][0], points[i][1])
          ctx.lineTo(points[j][0], points[j][1])
          ctx.stroke()
        }
      }
    }
    cx += W/2
    if (cx > W) {
      cy += H/2
      cx = W/4
    }
    s++
  }
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function lattice () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 5
  ctx.lineCap = "round"
  let rads = [3,4,5,6,7,8,3,4,5,6,7,8,13]
  let widths = [1,2,3, 4, 5]
  let H  = canvas.height, W = canvas.width
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let colors = getCurrentPalette()
  colors = shuffle(colors)
  let points = []
  let i = 0, numpoints = randomPick([27,37,47])
  let Rf = W/7
  numpoints = (W/Rf*H/Rf) * 2
  let row = 0
  
  let pad = 50
  let div = Math.floor(document.getElementById("featuresize").value/5)
  div = 12 + 100 - div
  let d = (canvas.width-2*pad)/div

  let space = 3
  let mindist = W/3.14 //(space+2)*d*2

  if (document.getElementById("grungy").checked)
    space = 1.5
  ctx.strokeStyle = "#000000"
  ctx.lineWidth = 2//2+Math.floor(document.getElementById("featuresize").value/100)
  let x = pad*1.5, y = pad*1.5
  let values = []
  while (y < H - pad*1.5) {
    while (x < W - pad*1.5) {
      points.push([x,y, 0])
      x += space * d
    }
    x = pad*1.5
    y += space * d
  }
 // return
  let j = 0
  i = 0
  ctx.strokeStyle = colors[0]
  for (;i < points.length; i++) {
   // j = i + 1
   // for (; j < points.length; j++) {
      if (distance(points[i][0],points[i][1],points[j][0],points[j][1]) < mindist*1.3) {
        //ctx.lineWidth = randomPick(widths)
        j = Math.floor(Math.random() * points.length)
        if (points[j][2] < 4 && points[i][2] < 4) {
          ctx.beginPath()
          ctx.moveTo(points[i][0], points[i][1])
          ctx.lineTo(points[j][0], points[j][1])
          ctx.stroke()
          points[j][2] += 1
          points[i][2] += 1
        }
      }
   // }
  }
  i = 0
  ctx.fillStyle = colors[1]
  while (i < points.length) {
    ctx.beginPath()
    ctx.arc(points[i][0], points[i][1], randomPick(rads), 0, Math.PI * 2)
    ctx.closePath()
    //ctx.fill()
    i++
  }
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}


function constellations () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 5//+ document.getElementById("featuresize").value/4
  ctx.lineCap = "round"
  let rads = [3,4,5,6,7,8,3,4,5,6,7,8,13]
  let widths = [1,2,3, 4, 5]
  let H  = canvas.height, W = canvas.width
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let colors = getCurrentPalette()
  colors = shuffle(colors)
  let points = []
  let i = 0, numpoints = randomPick([27,37,47])
  let x = 0, y = 0
  let Rf = W/7
  let mindist = Rf/1.1
  numpoints = (W/Rf*H/Rf) * 2
  let row = 0
  while (i < numpoints) {
    points.push([W*Math.random(), H*Math.random(), 0])
    i++
  }
  let j = 0
  i = 0
  ctx.strokeStyle = colors[0]
  for (;i < points.length; i++) {
    j = i + 1
    for (; j < points.length; j++) {
      if (distance(points[i][0],points[i][1],points[j][0],points[j][1]) < mindist*1.3) {
        ctx.lineWidth = randomPick(widths)
        if (points[j][2] < 2 && points[i][2] < 4) {
          ctx.beginPath()
          ctx.moveTo(points[i][0], points[i][1])
          ctx.lineTo(points[j][0], points[j][1])
          ctx.stroke()
          points[j][2] += 1
          points[i][2] += 1
        }
      }
    }
  }
  i = 0
  ctx.fillStyle = colors[1]
  while (i < points.length) {
    ctx.beginPath()
    ctx.arc(points[i][0], points[i][1], randomPick(rads), 0, Math.PI * 2)
    ctx.closePath()
    ctx.fill()
    i++
  }
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function glass () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/50
  let R = canvas.width * 0.3
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  if (document.getElementById("grungy").checked)
    colors = shuffle(['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let a = Math.random() * 2 * Math.PI
  let pad = 50
  let R2 = R/2
  // top
  let height = cy*0.4
  r = (canvas.height + height*-0.5) * 0.3
  ctx.fillStyle = (colors[3])
  ctx.beginPath()
  ctx.ellipse(cx, height, r, r/2, 0, Math.PI, 2 * Math.PI)
  //bottom
  height = canvas.height*0.85
  r = (canvas.height + height*-0.5) * 0.3
  ctx.ellipse(cx, height, r, r/2, 0,  0, Math.PI)
  ctx.closePath()
  ctx.fill()
  ctx.globalAlpha /= 2
  height = cy*0.4
  r = (canvas.height + height*-0.5) * 0.3
  ctx.beginPath()
  ctx.ellipse(cx, height, r, r/2, 0, 0, Math.PI)
  height = canvas.height*0.85
  r = (canvas.height + height*-0.5) * 0.3
  ctx.ellipse(cx, height, r, r/2, 0,  Math.PI, 0, true)
  ctx.closePath()
  ctx.fill()
  ctx.globalAlpha = alpha/10*20
  // fill
  ctx.fillStyle = (colors[0])
  ctx.beginPath()
  height = cy+pet(cy*1.2)
  let savedheight = height
  r = (canvas.height + height*-0.5) * 0.28 // slightly smaller
  ctx.ellipse(cx, height, r, r/2, 0, Math.PI, 2 * Math.PI) // level -> top of filled
  height = canvas.height*0.83
  r = (canvas.height + height*-0.5) * 0.28 // bottom of glass
  ctx.ellipse(cx, height, r, r/2, 0, 0, Math.PI)
  ctx.closePath()
  ctx.fill()
  ctx.globalAlpha /= 2
  ctx.beginPath()
  height = savedheight
  r = (canvas.height + height*-0.5) * 0.28 // slightly smaller
  ctx.ellipse(cx, height, r, r/2, 0, 0, 2 * Math.PI) // level -> top of filled
  ctx.closePath()
  ctx.fill()
  ctx.globalAlpha = alpha/100
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function braid () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 16
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let hip = canvas.width * 0.85
  let waist = canvas.width - hip *0.9
  let div = 1 + Math.random() * 5
  let height = 0
  let savedheight = 0
  // fill
  ctx.lineJoin = "round"
  ctx.strokeStyle = (colors[0])
  height = cy+pet(cy*1.2)
  let r = hip/6
  let savedr = r
  y = H - hip/4

  savedy = y
  //left shoulder
  ctx.beginPath()
  ctx.moveTo(hip/8, H)
  ctx.ellipse(hip/8+r, y, r, r, 0, Math.PI, 1.5 * Math.PI)
  ctx.stroke()
  //left neck
  ctx.beginPath()
  ctx.ellipse(hip/8+2*r/2, y-r*2, r, r, 0, Math.PI/2, 0, true)
  ctx.lineTo(hip/8+2*r/2+r, 0)
  ctx.stroke()
  // second strand
  ctx.strokeStyle = (colors[1])
  ctx.beginPath()
  ctx.moveTo(hip/8+2*r/2+r, H)
  ctx.ellipse(hip/8+r, y, r, r, 0, 0, 1.5 * Math.PI, true)
  ctx.stroke()
  ctx.beginPath()
  ctx.ellipse(hip/8+2*r/2, y-r*2, r, r, 0, Math.PI/2, Math.PI)
  ctx.lineTo(hip/8, 0)
  ctx.stroke()
}

function brush () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1 + Math.floor(document.getElementById("featuresize").value/10)
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let hip = canvas.width * 0.5
  let div = 1 + Math.random() * 5
  let height = 0
  let savedheight = 0
  // fill
  ctx.lineJoin = "round"
  ctx.strokeStyle = (colors[0])
  ctx.fillStyle = (colors[0])
  height = cy+pet(cy*1.2)
  let r = hip/9, bottompad = H/4
  let savedr = r
  y = H - H*0.4//hip/4
  savedy = y
  //left shoulder
  ctx.beginPath()
  ctx.moveTo(hip/8, H-bottompad)
  ctx.ellipse(hip/8+r, y, r, r, 0, Math.PI, 1.5 * Math.PI)
  //left neck
  ctx.ellipse(hip/8+2*r/2,  y-r*2, r, r, 0, Math.PI/2, 0, true)
  ctx.ellipse(hip/8+2*r/2+r*2, r*2.6 +Math.floor(Math.random()*40), r, r, 0, Math.PI, Math.PI*2)
  ctx.ellipse(hip/8+2*r/2 + r*4, y-r*2, r, r, 0, Math.PI, Math.PI/2, true)
  ctx.ellipse(hip/8+2*r/2 + r*4, y, r, r, 0, Math.PI * 1.5, 0)
  ctx.lineTo(hip/8+2*r/2 + r*5, H-bottompad)
  if (document.getElementById("grungy").checked) {
    ctx.closePath()
    ctx.fill()
  } else
    ctx.stroke()
    
  // hand inverted
  let i = 0
  r = H*0.20
  let xo = r/20
  y = H - bottompad/2
  x = hip/8
  ctx.beginPath()
  ctx.moveTo(x, y)
  x = hip/8+xo*2

  for (;i < 8; i++) {
   // ctx.lineTo(W/2 - r, H/2)
    //y = H*0.4
    ctx.arc(x, y, xo*2, Math.PI, 0, true) // thumb
    x += xo*4
  }
  if (document.getElementById("grungy").checked) {
    ctx.closePath()
    ctx.fill()
  } else
    ctx.stroke()
}

function user () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1 + Math.floor(document.getElementById("featuresize").value/10)
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let hip = canvas.width * 0.8
  let div = 1 + Math.random() * 5
  let height = 0
  let savedheight = 0
  // fill
  ctx.lineJoin = "round"
  ctx.strokeStyle = (colors[0])
  ctx.fillStyle = (colors[0])
  height = cy+pet(cy*1.2)
  let r = hip/6, bottompad = 50
  let savedr = r
  y = H - hip/4
  savedy = y
  //left shoulder
  ctx.beginPath()
  ctx.moveTo(hip/8, H-bottompad)
  ctx.ellipse(hip/8+r, y, r, r, 0, Math.PI, 1.5 * Math.PI)
  //left neck
  ctx.ellipse(hip/8+2*r/2, y-r*2, r, r, 0, Math.PI/2, 0, true)
  ctx.ellipse(hip/8+2*r/2+r*2, r*2.6 +Math.floor(Math.random()*40), r, r, 0, Math.PI, Math.PI*2)
  ctx.ellipse(hip/8+2*r/2 + r*4, y-r*2, r, r, 0, Math.PI, Math.PI/2, true)
  ctx.ellipse(hip/8+2*r/2 + r*4, y, r, r, 0, Math.PI * 1.5, 0)
  ctx.lineTo(hip/8+2*r/2 + r*5, H-bottompad)
  if (document.getElementById("grungy").checked) {
    ctx.closePath()
    ctx.fill()
  } else
    ctx.stroke()
}

function blocksX () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 4 + Math.floor(document.getElementById("featuresize").value/10)
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  //let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let H = canvas.height, W = canvas.width
  let cx = W/2, cy = H/2, x = 0, y = 0
  
  ctx.fillStyle = colors[0]
  ctx.fillRect(0,0,W,H)

  ctx.fillStyle = randomPick([colors[1]])
  ctx.fillRect(pet(300),pet(160),W*0.96,H/2)
  
  ctx.fillStyle = randomPick([colors[1]])
  ctx.fillRect(pet(300),cy+pet(160),W*0.96,H/2)
  
  ctx.fillStyle = randomPick([colors[0], colors[0]])
  ctx.fillRect(cx+pet(200),H*0.1+pet(120),W*0.8+pet(100),H*0.8+pet(100))

  if (Math.random() > 0.5)
    flipV()
  if (Math.random() > 0.5)
    rc()
  if (Math.random() > 0.5)
    rc()
}

function blocks () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 4 + Math.floor(document.getElementById("featuresize").value/10)
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let alpha = document.getElementById("opacity").value
  let H = canvas.height, W = canvas.width
  let cx = W/2, cy = H/2, x = 0, y = 0
  
  ctx.fillStyle = colors[0]
  
  ctx.fillRect(0,0,W,H)

  ctx.fillStyle = colors[1]
  ctx.fillRect(pet(100),pet(80),W*0.96,H/2)
  ctx.fillRect(pet(100),cy+pet(80),W*0.96,H/2)
  
  ctx.fillStyle = colors[0]
  ctx.fillRect(W*0.1+pet(80),H*0.1+pet(120),W*0.8+pet(100),H*0.8+pet(100))

  if (Math.random() > 0.5)
    flipV()
  if (Math.random() > 0.5)
    rc()
  if (Math.random() > 0.5)
    rc()
}

function drawFold (x,y,x2,y2, ctx, big) {
  if (!document.getElementById("grungy").checked) {
    ctx.lineWidth = randomPick([0.5,3,0.5,1,1,1,1,1,1,2])
    ctx.beginPath()
    ctx.moveTo(x,y)
    ctx.lineTo(x2+pet(2),y2+pet(2))
    if (Math.random() > 0.11)
  ctx.stroke()
  } else
    chipAt(x+pet(2),y+pet(2),big)
}

function bkg_unfolded_bkg () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  ctx.fillStyle = "#606060"
  //ctx.clearRect(0,0,canvas.width,canvas.height)
  //ctx.fillRect(0,0,canvas.width,canvas.height)
  let widths = [1,2,3,4,0,0,0,2,0,2,2,1,1]
  ctx.strokeStyle = "#606060"
  ctx.lineWidth = 0.5
  ctx.lineCap = "round"
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let i = 0, x = 0, y = 4, L = 1, skip = 5
  let x2 = 0, y2 = 0
  while (x < W) { // \ L = 1// + pet(1)
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y+L,ctx,true)
    x += L, y += L
  }
  x = W/4, y = 1
  while (y < H) { // \
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L/2,y+L,ctx)
    x += L/2, y += L
  }
  x = 3*W/4, y = 1
  while (y < H) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x-L/2,y+L,ctx)
    x -= L/2, y += L
  }
  x = 0, y = H+1
  while (x < W) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y-L,ctx,true)
    x += L, y -= L
  }
  x = 0, y = H/2+1
  while (x < W) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y,ctx)
    x += L
  }
  x = 0, y = H/4+1
  while (x < W) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y,ctx)
    x += L
  }
  x = 0, y = 3*H/4+1
  while (x < W) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y,ctx)
    x += L
  }
  x = W/2, y = 0+1
  while (y < H) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x,y+L,ctx)
    y += L
  }
  x = W/4, y = 0
  while (y < H) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x,y+L,ctx)
    y += L
  }
  x = 3*W/4, y = 0
  while (y < H) {
    L = 3 + pet(2)
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x,y+L,ctx)
    y += L
  }
  x = 0, y = H/4
  while (y < H) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y+L/2,ctx)
    y += L/2, x += L
  }
  x = 0, y = 3*H/4
  while (x < W) {
   L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y-L/2,ctx)
    y -= L/2, x += L
  }
  x = 0, y = H/2
  while (x < W/2) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y-L,ctx)
    y -= L, x += L
  }
  x = 0, y = H/2
  while (x < W/2) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y+L,ctx)
    y += L, x += L
  }
  x = 0, y = 3*H/4
  while (x < W/4) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y+L,ctx)
    y += L, x += L
  }
  x = 0, y = H/4
  while (x < W/4) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y-L,ctx)
    y -= L, x += L
  }
  x = W/2, y = 0
  while (x < W) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y+L,ctx)
    y += L, x += L
  }
  x = W/2, y = H
  while (x < W) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y-L,ctx)
    y -= L, x += L
  }
  x = 3*W/4, y = 0
  while (x < W) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y+L,ctx)
    y += L, x += L
  }
  x = 3*W/4, y = H
  while (x < W) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y-L,ctx)
    y -= L, x += L
  }
}

function unfolded () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  ctx.fillStyle = "#ffffff"
  //ctx.clearRect(0,0,canvas.width,canvas.height)
  //ctx.fillRect(0,0,canvas.width,canvas.height)
  let widths = [1,2,3,4,0,0,0,2,0,2,2,1,1]
  ctx.strokeStyle = "#ffffff"
  ctx.lineWidth = 0.5
  ctx.lineCap = "round"
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let i = 0, x = pet(4), y = pet(4), L = 1, skip = 5
  while (x < W) { // \ L = 1// + pet(1)
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y+L,ctx, true)
    x += L, y += L
  }
  x = W/4, y = 0
  while (y < H) { // \
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L/2,y+L,ctx)
    x += L/2, y += L
  }
  x = 3*W/4, y = 0
  while (y < H) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x-L/2,y+L,ctx)
    x -= L/2, y += L
  }
  x = 0, y = H
  while (x < W) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y-L,ctx, true)
    x += L, y -= L
  }
  x = 0, y = H/2
  while (x < W) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y,ctx)
    x += L
  }
  x = 0, y = H/4
  while (x < W) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y,ctx)
    x += L
  }
  x = 0, y = 3*H/4
  while (x < W) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y,ctx)
    x += L
  }
  x = W/2, y = 0
  while (y < H) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x,y+L,ctx)
    y += L
  }
  x = W/4, y = 0
  while (y < H) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x,y+L,ctx)
    y += L
  }
  x = 3*W/4, y = 0
  while (y < H) {
    L = 3 + pet(2)
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x,y+L,ctx)
    y += L
  }
  x = 0, y = H/4
  while (y < H) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y+L/2,ctx)
    y += L/2, x += L
  }
  x = 0, y = 3*H/4
  while (x < W) {
   L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y-L/2,ctx)
    y -= L/2, x += L
  }
  x = 0, y = H/2
  while (x < W/2) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y-L,ctx)
    y -= L, x += L
  }
  x = 0, y = H/2
  while (x < W/2) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y+L,ctx)
    y += L, x += L
  }
  x = 0, y = 3*H/4
  while (x < W/4) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y+L,ctx)
    y += L, x += L
  }
  x = 0, y = H/4
  while (x < W/4) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y-L,ctx)
    y -= L, x += L
  }
  x = W/2, y = 0
  while (x < W) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y+L,ctx)
    y += L, x += L
  }
  x = W/2, y = H
  while (x < W) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y-L,ctx)
    y -= L, x += L
  }
  x = 3*W/4, y = 0
  while (x < W) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y+L,ctx)
    y += L, x += L
  }
  x = 3*W/4, y = H
  while (x < W) {
    L = 1
    if (Math.random() > 0.9)
      L += skip
    drawFold(x,y,x+L,y-L,ctx)
    y -= L, x += L
  }
  
  
  x = 0, y = 1
  while (x < W) {
    L = 1
    if (Math.random() > 0.9)
      ;//L += skip
    drawFold(x,y,x+L,y,ctx,true)
    x += L
  }
  x = 0, y = H-1
  while (x < W) {
    L = 1
    if (Math.random() > 0.9)
      ;//L += skip
    drawFold(x,y,x+L,y,ctx,true)
    x += L
  }
  
  x = 1, y = 0
  while (y < H) {
    L = 1
    if (Math.random() > 0.9)
      ;//L += skip
    drawFold(x,y,x,y+L,ctx,true)
    y += L
  }
  
  x = W-1, y = 0
  while (y < H) {
    L = 1
    if (Math.random() > 0.9)
      ;//L += skip
    drawFold(x,y,x,y+L,ctx,true)
    y += L
  }
  
  for (; i < 69; i++)
    chipAt(Math.random()*W,Math.random()*H)

}

function foldings () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  //ctx.clearRect(0,0,canvas.width,canvas.height)
 // ctx.lineWidth = 4 + Math.floor(document.getElementById("featuresize").value/10)
  ctx.lineWidth *= 1.6
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let H = canvas.height, W = canvas.width
  let cx = 2*W/3, cy = H/2, x = 0, y = 0
  let pad = 0
  ctx.strokeStyle = colors[0]
  ctx.fillStyle = colors[1]
  let r = W/9 + Math.random() * W/12
  ctx.fillRect(pad,pad,W-2*pad,H-2*pad)
  pad = 80
  ctx.beginPath()
  ctx.moveTo(cx/2+pad, cy/2+pad*2)
  ctx.lineTo(pad*2, cy/4+pad*2)
  ctx.lineTo(cx/2+pad, pad*2)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(pad*2, cy)
  ctx.lineTo(pad*2, H-pad)
  ctx.stroke()
  ctx.strokeStyle = colors[2]
  ctx.beginPath()
  ctx.moveTo(cx/2, pad+cy) // start
  ctx.lineTo(cx, pad+cy) // top right
  ctx.lineTo(cx, cy*2-pad) // bottom right
  ctx.lineTo(cx/2, cy*2-pad) // bottom right
  ctx.stroke()
  ctx.strokeStyle = randomPick(colors)
  ctx.lineWidth *= 1.5
  ctx.beginPath()
  ctx.moveTo(W-pad*2, pad) // start
  ctx.lineTo(W-pad*2, H-pad)
  ctx.stroke()
  if (Math.random() > 0.5)
    flipV()
  if (Math.random() > 0.5)
    rc()
  if (Math.random() > 0.5)
    rcc()
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function arch () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 4 + Math.floor(document.getElementById("featuresize").value/10)
  ctx.lineWidth *= 1.6
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let H = canvas.height, W = canvas.width
  let cx = 2*W/3, cy = H/2, x = 0, y = 0
  let pad = 0//H/20
  ctx.strokeStyle = colors[0]
  ctx.fillStyle = colors[1]
  let r = W/9 + Math.random() * W/12
  ctx.fillRect(pad,pad,W-2*pad,H-2*pad)
  if (Math.random() > 0.5) {
    ctx.fillStyle = colors[2]
    ctx.beginPath()
    ctx.arc(cx+pet(5), cy+pet(5)-cy/3, r-2-pet(3), 0, Math.PI*2)
    ctx.closePath()
    ctx.fill()
  } else {
    ctx.fillStyle = colors[2]
    ctx.fillRect(cx+pet(7)-r, H-cy/3-r*2+pet(7), r*2+pet(7), r*2+pet(7)-ctx.lineWidth/2)
  }
  ctx.beginPath()
  ctx.arc(cx, cy-cy/3 , r+ctx.lineWidth/2, Math.PI,Math.PI*2)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(cx-r, H-cy/3)
  ctx.lineTo(cx+r+ctx.lineWidth/2, H-cy/3)
  ctx.lineTo(cx+r + ctx.lineWidth/2, cy-cy/3)//-ctx.lineWidth)
  ctx.stroke()
  cx = W/4
  ctx.strokeStyle = randomPick(colors)
  ctx.beginPath()
  ctx.moveTo(cx-r/2, cy/3-ctx.lineWidth/2)
  ctx.lineTo(cx-r/2, H-cy/3+ctx.lineWidth/2)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(cx-r/2, cy/3)
  ctx.lineTo(cx+ctx.lineWidth/2, cy/3)
  ctx.stroke()
  if (Math.random() > 0.5)
    flipV()
  if (Math.random() > 0.5)
    rc()
  if (Math.random() > 0.5)
    rcc()
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function venus () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1 + Math.floor(document.getElementById("featuresize").value/10)
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let hip = canvas.width * 0.76
  let waist = canvas.width - hip *0.9
  let div = 1 + Math.random() * 5
  let height = 0
  let savedheight = 0
  // fill
  ctx.lineJoin = "round"
  ctx.lineCap = "round"
  ctx.strokeStyle = (colors[0])
  height = cy+pet(cy*1.2)
  let r = hip/9
  let savedr = r
  let DY = 30, DX = 100
  y = cy + r
  ctx.beginPath()
  ctx.ellipse(cx-r*2+35+DX, canvas.height+r+DY, r*2, r*3.5, 0, Math.PI, Math.PI * 1.35) // left hip
  ctx.ellipse(hip/4+r/2+DX, y+r+DY, r*0.85, r*0.50, -Math.PI/10, Math.PI/2, Math.PI)   // left arm
  ctx.ellipse(hip/4+r/2+DX, y+r+DY, r*0.85, r*0.50, -Math.PI/10, Math.PI, Math.PI*2)
  ctx.ellipse(hip/4+r/2+DX, y+r+DY, r*0.85, r*0.50, -Math.PI/10, Math.PI*2, Math.PI)
  ctx.ellipse(hip/4+r/2-20+DX, y-r*1.5+40+DY, r, r, 0, Math.PI, Math.PI*1.3) // left shoulder
  ctx.ellipse(hip/4+r-90+DX,  y-r*3.5+40+DY, r*0.9, r, 0, Math.PI/2-0.1, Math.PI *1.95, true) // left neck
  ctx.ellipse(cx-r*1.5-20+DX, r*1.9+DY, r*1.7, r*1.2, Math.PI/2.1, Math.PI/2, Math.PI*1.5) // face
  ctx.ellipse(cx-r*1.5-20+DX, r*1.9+DY, r*1.7, r*1.2, Math.PI/2.1, Math.PI*1.5, Math.PI/2) // face
  ctx.stroke()
  //left boob
  ctx.beginPath()
  ctx.ellipse(cx-hip/6+DX, y+DY, r, r, 0, Math.PI*1.35, 0, true)
  ctx.stroke()
  ctx.beginPath()
  ctx.ellipse(cx+r/2+DX, canvas.height+DY, r*2, r*3.0, 0, Math.PI/2, Math.PI * 1.7, true) // right hip
  ctx.ellipse(cx+hip/9+DX, y-r/2+DY, r, r, 0, Math.PI*2.1, Math.PI*0.9)  //right boob
  ctx.ellipse(cx+hip/9+DX, y-r/2+DY, r, r, 0, Math.PI*0.9, Math.PI*1.8,true)  //right boob
  ctx.ellipse(canvas.width - 360+DX, 428+DY, 8, 70, 0, Math.PI/2, Math.PI*2) // right arm
  ctx.ellipse(canvas.width - 360+DX, 428+DY, 8, 70, 0, Math.PI*2, 0) // right arm
  ctx.ellipse(canvas.width - 360+DX, 428+DY, 8, 70, 0, 0, Math.PI*1.5, true) // right arm
  ctx.ellipse(canvas.width - 420+DX, 420+DY, 90, 90, 0, Math.PI*1.7, Math.PI *1.3, true) // right shoulder
  ctx.lineTo(cx-58+DX, 330+DY)
  ctx.lineTo(cx-64+DX, 270+DY)
  ctx.stroke()
  ctx.beginPath()
  ctx.ellipse(cx-20+DX, canvas.height-r-10+DY, 6, 2, 0, Math.PI*2, 0, true) // navel
  ctx.stroke()
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function buns () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1 + Math.floor(document.getElementById("featuresize").value/10)
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let hip = canvas.width * 0.76
  let waist = canvas.width - hip *0.9
  let div = 1 + Math.random() * 5
  let height = 0
  let savedheight = 0
  // fill
  ctx.lineJoin = "round"
  ctx.strokeStyle = (colors[0])
  height = cy+pet(cy*1.2)
  let r = hip/4
  let savedr = r
  y = cy*0.5 + r
  savedheight = y
  //upper part
  ctx.beginPath()
  ctx.moveTo(waist/2,0)
  ctx.ellipse(cx-hip/4, y, r, r, 0, Math.PI, 0, true)
  ctx.ellipse(cx+hip/4, y, r, r, 0, Math.PI, 0, true)
  ctx.lineTo(canvas.width-waist/2,0)
  ctx.stroke()
  //legs inner
  ctx.beginPath()
  ctx.moveTo(cx, y)
  ctx.lineTo(cx-30, canvas.height)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(cx, y)
  ctx.lineTo(cx+30, canvas.height)
  ctx.stroke()
  // legs outer
  ctx.beginPath()
  ctx.moveTo(cx-r*2, y)
  ctx.lineTo(cx-r*2+30, canvas.height)
  ctx.stroke()
  ctx.beginPath()
  ctx.moveTo(cx+r*2, y)
  ctx.lineTo(cx+2*r-30, canvas.height)
  ctx.stroke()
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function formDec (canvas) {
  form1(canvas)
  rc(canvas)
  form1(canvas)
  rc(canvas)
}

function paperize (canvas) {
  let ctx = canvas.getContext("2d")
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let fs = document.getElementById("featuresize").value
  let alt = document.getElementById("grungy").checked
  let functions = ["smudgestreaks2", "smudgearcs", "smudgestars", "smudgehorizontal2"]
  checkAlt(false)
  setFeaturesize (Math.floor(75+Math.random()*75))
  setPaintColor("#ffffff")
  smudgestreaks2(canvas)
  window[randomPick(functions)](canvas)
  setPaintColor("#333333")
  setFeaturesize (Math.floor(75+Math.random()*75))
  window[randomPick(functions)](canvas)
  setFeaturesize(fs)
  checkAlt(alt)
  setPaintColor(color)
}

function scripto (canvas) {
  let fs = document.getElementById("featuresize").value
  LASTCLICK[0] = 24+Math.random() * 10
  LASTCLICK[1] = 24+Math.random() * 10
  setFeaturesize (Math.floor(350+Math.random() * 80))
  let N = 5, i = 0
  for (; i < N; i++)
    script(canvas)
  setFeaturesize (fs)
}

function typo (canvas) {
  let fs = document.getElementById("featuresize").value
  LASTCLICK[0] = 24+Math.random() * 40
  LASTCLICK[1] = 24+Math.random() * 40
  setFeaturesize (Math.floor(80+Math.random() * 80))
  let N = 27, i = 0
  for (; i < N; i++)
    placeTextAt(null, canvas)
  setFeaturesize (fs)
}

 
function hstripes_sml (canvas) {
  let fs = document.getElementById("featuresize").value
  setFeaturesize (Math.floor(2+Math.random() * 41))
  hstripes(canvas)
  setFeaturesize (fs)
}

function multiScraps () {
  let canvas = document.getElementById("myCanvas")
  let W = canvas.width, H = canvas.height
  let functions = shuffle(["typo", "scripto", "pageOfBook", "formDec",
  "form2", "gridpaper", "snow",
  "hstripes_sml", "crosswordPad", "gridLog", "moleText", "index"])
  let N = 7, i = 0
  for (; i < N; i++) {
    tapeText(functions[i])
  }
}

function tapeText (f) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let oc = document.createElement('canvas')
  let occtx = oc.getContext("2d");
  oc.height = canvas.height, oc.width = canvas.width
  let colors = shuffle(getCurrentPalette())
  occtx.fillStyle = randomPick(colors)
  occtx.fillRect(0,0, canvas.width, canvas.height)
  window[f](oc)
  if (Math.random() < 0.5)
    paperize(oc)
  if (Math.random() > 0.5)
    rc(oc)
  let D = 80+Math.floor(document.getElementById("featuresize").value)
  let mults = [0.8, 0.9, 1.1, 1.3, 0.4, 1.7]
  let DH = D*randomPick(mults)
  // vary length, but not width
  D -= Math.random()*(D/2)
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let alt = document.getElementById("grungy").checked
  ctx.fillStyle = randomPick(colors)
  let cx =  Math.random() * oc.width//LASTCLICK[0]
  let cy =  Math.random() * oc.height//LASTCLICK[1]
  let rotate = (cx < D*1.5 || canvas.width - cx < D*1.5)
  let angle = Math.PI/19
  
  ctx.save()
  ctx.fillStyle = colors[0]
  if (rotate)
    angle += Math.PI/2
  if (Math.random() > 0.5)
    angle *= -1
  ctx.translate(cx,cy)
  ctx.rotate(angle)
  ctx.translate(-cx,-cy)

  let xe = cx-D+pet(D*0.8)
  let ye = cy-DH
  let y0 = ye, x0 = xe
  
  ctx.beginPath()
  ctx.moveTo(xe,ye)
  x = xe
  y = ye
  xe = cx+D+pet(D*0.8)
  ragged(ctx,xe,ye,x,y,25)
  x = xe
  y = ye
  xe += pet(D*0.8)
  ye = cy+DH
  ragged(ctx,xe,ye,x,y)
  x = xe
  y = ye
  xe = cx-D-pet(D*0.8)
  ragged(ctx,xe,ye,x,y)
  x = xe
  y = ye
  ye = cy-D-pet(D*0.8)
  ragged(ctx,x0,y0,x,y,25)
  if (alt) {
    ctx.shadowBlur = 3 + Math.random() * 4
    ctx.shadowColor = "#444444"
    ctx.shadowOffsetX = 3
    ctx.shadowOffsetY  = 3
  }
  ctx.fill()// for shadow
  ctx.shadowBlur = 0
  ctx.shadowOffsetX = 0
  ctx.shadowOffsetY  = 0
  ctx.clip()
  ctx.drawImage(oc, 0, 0, canvas.width, canvas.height)
  ctx.restore()
}

function fillOC (oc, occtx) { // ...with a paper pattern
  let colors = shuffle(getCurrentPalette(true,13))
  occtx.fillStyle = randomPick(colors)
  occtx.fillRect(0,0, oc.width, oc.height)
  let f = randomPick([ "stepchart", /*"scripto",*/ /*"pageOfBook", */"formDec",
  "form2", "gridpaper", "griddiag", "griddiagd",
  "gridLog"])//, "moleText", "index"])
  window[f](oc)
  //if (Math.random() < 0.5)
    //paperize(oc)
  if (Math.random() > 0.5)
    rc(oc)
  else
  if (Math.random() > 0.5)
    rcc(oc)
  
  if (Math.random() > 0.5)
    wrap(oc)
  //if (Math.random() > 0.5)
  //  rotateRandom(oc)
}

function tape () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let D = 70+Math.floor(document.getElementById("featuresize").value/5)
  let DH = D/3
  // vary length, but not width
  D -= Math.random()*(D/2)
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let alt = document.getElementById("grungy").checked
  ctx.fillStyle = randomPick(colors)
  let cx =  LASTCLICK[0]
  let cy =  LASTCLICK[1]
  let rotate = (cx < D*1.5 || canvas.width - cx < D*1.5)
  let angle = Math.PI/19
  ctx.save()
  if (rotate)
    angle += Math.PI/2
  if (Math.random() > 0.5)
    angle *= -1
  ctx.translate(cx,cy)
  ctx.rotate(angle)
  ctx.translate(-cx,-cy)

  let xe = cx-D+pet(D*0.8)
  let ye = cy-DH
  let y0 = ye, x0 = xe
  
  ctx.fillStyle = colors[0]
  ctx.beginPath()
  ctx.moveTo(xe,ye)
  x = xe
  y = ye
  xe = cx+D+pet(D*0.8)
  ctx.lineTo(xe,ye)
  x = xe
  y = ye
  xe += pet(D*0.8)
  ye = cy+DH
  ragged(ctx,xe,ye,x,y)
  x = xe
  y = ye
  xe = cx-D-pet(D*0.8)
  ctx.lineTo(xe, ye)
  ragged(ctx,x0,y0,xe,ye)
  ctx.closePath()
  if (alt) {
    ctx.shadowBlur = 1
    ctx.shadowColor = "#666666"
    ctx.shadowOffsetX = 0
    ctx.shadowOffsetY  = 1
  }
  ctx.fill()
  ctx.restore()
  ctx.shadowBlur = 0
  ctx.shadowOffsetX = 0
  ctx.shadowOffsetY  = 0
}

function multiScraps_og () {
  let i = 0, d = 50, r = true

  for (; i < 11; i++)
    scraps(d, r)
  i = 0, d = 500
  for (; i < 11; i++)
    scraps(d, r)
  d = 200, i = 0
  for (; i < 11; i++)
    scraps(d, r)
  
}

function scraps (d,random) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  //let D = 200 + Math.random() * 300//
  let D = Math.floor(document.getElementById("featuresize").value/1)
  if (d)
    D = d
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  ctx.fillStyle = randomPick(colors)

  let cx = canvas.width/2, cy = canvas.height/2
  let xe = cx-D+pet(D*0.9)
  let ye = cy-D+pet(D*0.9)
  let x0 = xe, y0 = ye

  ctx.fillStyle = randomPick(colors)
  cx =  LASTCLICK[0]
  cy =  LASTCLICK[1]
  if (random) {
    cx = canvas.width*Math.random()
    cy = canvas.height*Math.random()
  }
  xe = cx-D+pet(D*2)
  ye = cy-D+pet(D*2)
  y0 = ye, x0 = xe
  ctx.beginPath()
  ctx.moveTo(xe,ye)
  x = xe
  y = ye
  xe = cx+D+pet(D*2)
  ye += pet(D*2)
  raggedX(ctx,xe,ye,x,y)
  x = xe
  y = ye
  xe += pet(D*2)
  ye = cy+D+pet(D*2)
  raggedX(ctx,xe,ye,x,y)
  x = xe
  y = ye
  xe = cx-D-pet(D*2)
  ye += pet(D*2)
  raggedX(ctx,xe,ye,x,y)
  raggedX(ctx,x0,y0,xe,ye)
  ctx.closePath()
  ctx.fill()
}

function pants () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1 + Math.floor(document.getElementById("featuresize").value/10)
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let div = 1 + Math.random() * 4
  let height = 0
  let savedheight = 0
  // fill
  ctx.lineJoin = "round"
  ctx.strokeStyle = (colors[0])
  height = cy+pet(cy*1.2)
  let r = (canvas.height + height*-0.5) * 0.27 // slightly smaller
  let savedr = r
  // top
  y = cy*0.5 + r/2/div
  savedheight = y
  r = canvas.width/2 * 0.8
  ctx.strokeStyle = (colors[3])
  ctx.beginPath()
  ctx.ellipse(cx, y, r, r/div, 0, 0, 2 * Math.PI)
  ctx.stroke()
  
  y = canvas.height * 5/6
  r *= 0.5
  let leglength = canvas.height * 5/6
  if (Math.random() > 0.5)
    leglength *= 0.7
  let rotation = 0.0 + Math.random()/3
  r += r/8 * Math.random()
  r *= 1.1
  ctx.ellipse(canvas.width - cx/2, leglength, r, r/div, 0-rotation, 2 * Math.PI, 0)
  ctx.ellipse(canvas.width - cx/2, leglength, r, r/div, 0-rotation, 0, Math.PI)
  ctx.lineTo(cx+cx*0.03, cy*1.3)
  ctx.lineTo(cx-cx*0.03, cy*1.3)
  ctx.ellipse(cx/2, leglength, r, r/div, 0+rotation, 0, 2 * Math.PI)
  ctx.ellipse(cx/2, leglength, r, r/div, 0+rotation, 0,  Math.PI)
  r = canvas.width/2 * 0.8
  y = savedheight
  ctx.ellipse(cx, y, r, r/div, 0, Math.PI, Math.PI)
  ctx.stroke()
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function glass_line () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1 + Math.floor(document.getElementById("featuresize").value/10)
  //let R = canvas.width * 0.3
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let div = 1 + Math.random() * 5
  let height = 0
  let savedheight = 0
  // fill
  ctx.strokeStyle = (colors[0])
  height = cy+pet(cy*1.2)
  let r = (canvas.height + height*-0.5) * 0.27 // slightly smaller
  let savedr = r
  height += r/2/div
  savedheight = height
  r = (canvas.height + height*-0.5) * 0.27 // slightly smaller
  savedr = r
  ctx.beginPath()
  ctx.ellipse(cx, height, r, r/div, 0, Math.PI, 2 * Math.PI) // level -> top of filled
  height = canvas.height*0.84
  r = (canvas.height + height*-0.5) * 0.27 // bottom of glass
  ctx.ellipse(cx, height, r, r/div, 0, 0, Math.PI)
  ctx.lineTo(cx-savedr,savedheight) //: \
  ctx.stroke()
  ctx.beginPath()
  height = savedheight
  r = (canvas.height + height*-0.5) * 0.27 // slightly smaller
  ctx.ellipse(cx, height, r, r/div, 0, 0, 2 * Math.PI) // level -> top of filled
  ctx.stroke()
//---------------
  // top
  height = cy*0.4 + r/2/div
  savedheight = height
  r = (canvas.height + height*-0.5) * 0.3
  ctx.strokeStyle = (colors[3])
  ctx.beginPath()
  ctx.ellipse(cx, height, r, r/div, 0, Math.PI, 2 * Math.PI)
  //bottom
  height = canvas.height*0.85
  r = (canvas.height + height*-0.5) * 0.3
  ctx.ellipse(cx, height, r, r/div, 0,  0, Math.PI)
  ctx.stroke()
  
  ctx.strokeStyle = (colors[3])
  height = cy*0.4 + r/div
  height = savedheight

  r = (canvas.height + height*-0.5) * 0.3
  ctx.beginPath()
  ctx.ellipse(cx, height, r, r/div, 0, 0, Math.PI)
  height = canvas.height*0.85
  r = (canvas.height + height*-0.5) * 0.3
    
  ctx.ellipse(cx, height, r, r/div, 0,  Math.PI, 0, true)
  ctx.stroke()
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function eclipse () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/4
  let R = canvas.height * 0.15, r = R*2
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let a = Math.random() * 2 * Math.PI

  let R2 = R*0.8
  ctx.fillStyle = colors[3]
  ctx.beginPath()
  ctx.moveTo(cx-R*3.2,0)
  ctx.lineTo(cx+R*3.2,0)
  ctx.lineTo(cx+R2, canvas.height)
  ctx.lineTo(cx-R2, canvas.height)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = colors[4]
  ctx.beginPath()
  ctx.moveTo(cx-R2*0.3, (cy+cy/3), 0)
  ctx.lineTo(cx+R2*0.3, (cy+cy/3), 0)
  ctx.lineTo(cx+R2*0.05, canvas.height-R2)
  ctx.lineTo(cx-R2*0.05, canvas.height-R2)
  ctx.closePath()
  ctx.fill()
  // top disc
  ctx.fillStyle = colors[0]
  ctx.beginPath()
  ctx.arc(cx, -R/4, R+r, 0, Math.PI * 2)
  ctx.closePath()
  ctx.fill()
  // bottomr disc
  ctx.fillStyle = colors[1]
  ctx.beginPath()
  ctx.arc(cx, canvas.height, R2, 0, Math.PI * 2)
  ctx.closePath()
  ctx.fill()
  //moon
  R2 *= 0.3
  ctx.fillStyle = colors[2]
  ctx.beginPath()
  ctx.arc(cx, cy+cy/3, R2, 0, Math.PI * 2)
  ctx.closePath()
  ctx.fill()
  R += R/2
  R *= 2
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function core () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/4
  let R = canvas.width * 0.4
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  if (document.getElementById("grungy").checked)
    colors = shuffle(['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  // whole world
  //left side surface
  ctx.fillStyle = colors[0]
  ctx.beginPath()
  ctx.arc(cx, cy, R, Math.PI/2, Math.PI * 1.5)
  ctx.ellipse(cx, cy, R*0.67, R, 0, Math.PI * 1.5, Math.PI/2, true)
  ctx.closePath()
  ctx.fill()
  ctx.globalAlpha /= 5
  ctx.fillStyle = "#ffffff"
  ctx.fill()
  ctx.globalAlpha = alpha/100

 //right side surface
  ctx.fillStyle = colors[0]
  ctx.beginPath()
  ctx.arc(cx, cy, R, Math.PI * 1.5, Math.PI/2)
  ctx.ellipse(cx, cy, R*0.67, R, 0, Math.PI/2, Math.PI*1.5, true)
  ctx.closePath()
  ctx.fill()
  ctx.globalAlpha /= 5
  ctx.fillStyle = "#000000"
  ctx.fill()
  ctx.globalAlpha = alpha/100

  // left cutout
  ctx.fillStyle = colors[1] // darken
  ctx.beginPath()
  ctx.ellipse(cx, cy, R*0.67, R, 0, Math.PI/2, Math.PI * 1.5) // bottom to top
  ctx.moveTo(cx, cy-R)
  ctx.lineTo(cx, cy-(R/3)) //down
  ctx.ellipse(cx, cy, R/3, R/3, 0, Math.PI*1.5, Math.PI/2, true) // top to bottom
  ctx.moveTo(cx, cy+R)
  ctx.lineTo(cx, cy+(R/3)) // down
  ctx.closePath()
  ctx.fill()
  ctx.globalAlpha /= 5
  ctx.fillStyle = "#000000"
  ctx.fill()
  ctx.globalAlpha = alpha/100

  // right cutout
  ctx.fillStyle = colors[1] // lighten
  ctx.beginPath()
  ctx.ellipse(cx, cy, R*0.67, R, 0, Math.PI * 1.5, Math.PI/2) // top to bottom
  ctx.moveTo(cx, cy+R)
  ctx.lineTo(cx, cy+(R/3)) //up
  ctx.ellipse(cx, cy, R/3, R/3, 0, Math.PI/2, Math.PI * 1.5, true) // top to bottom
  ctx.moveTo(cx, cy-R)
  ctx.lineTo(cx, cy-(R/3)) // up
  ctx.closePath()
  ctx.fill()
  ctx.globalAlpha /= 5
  ctx.fillStyle = "#ffffff"
  ctx.fill()
  ctx.globalAlpha = alpha/100

  //core
  ctx.fillStyle = colors[2]
  ctx.beginPath()
  ctx.arc(cx, cy, R/3, 0, Math.PI * 2)
  ctx.closePath()
  ctx.fill()
 // core glint
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function fruit () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  let W = canvas.width, H = canvas.height
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/4
  let R = canvas.height * 0.05, R2 = 0
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  if (document.getElementById("grungy").checked)
    colors = shuffle(['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let cx = 12, cy = canvas.height/2, x = 0, y = 0
  let a = Math.random() * Math.PI * 2
  let sixth = Math.PI/6
  let i = 0
  for (; i < 20; i++) {
    R = 100
    //left side surface
    cx = Math.random() *W, cy = Math.random() * H
    let d = 10 + cy * 0.1
    a = Math.random() * Math.PI * 2
    R2 =  R * 0.6
    ctx.fillStyle = colors[0]
    ctx.beginPath()
    ctx.ellipse(cx, cy, R, R, a, 0, Math.PI)
    ctx.ellipse(cx, cy, R, R2, a, Math.PI, 0, true)
    ctx.closePath()
    ctx.fill()

    let j = 0
    for (; j < 6; j++) {
      ctx.fillStyle = colors[3]
      ctx.beginPath()
      ctx.ellipse(cx, cy, R, R2, a, 0, Math.PI/6, true)
      ctx.lineTo(cx,cy)
      ctx.closePath()
      ctx.fill()
      a -= Math.PI/6
    }
  }
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}


function spotlight () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let rg = ctx.createRadialGradient(cx+pet (900), cy-400+pet(100), 6, cx, cy-400, 700)
  let col1 = "#ffffff"
  let col2 = "rgba("+hexToR(col1)+", "+hexToG(col1)+", "+hexToB(col1)+", 0.0)";// transparent
  rg.addColorStop(0.0, col1);
  rg.addColorStop(0.75, col2);
  ctx.fillStyle = rg
  let a = Math.random() * 2 * Math.PI
  ctx.beginPath()
  ctx.ellipse(cx+pet(1100), cy-400+pet(600), 900, 700, a, 0, Math.PI * 2)
  ctx.closePath()
  ctx.fill()
}

function atom () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/4
  let R = canvas.height * 0.40
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let colors = shuffle(getCurrentPalette())
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let a = Math.random() * 2 * Math.PI
  let n = randomPick([1,2,3,4,5,6,7,8])
  let nucs = n*2
  let inc = Math.PI/n
  r = R/n, r2 = r
  if (n == 1)
    r2 *= 0.67
  let i = 0
  for (; i < n; i++) {
    let rg = ctx.createRadialGradient(cx, cy, r2, cx, cy, R)
    let col1 = colors[0]
    if (i % 2 == 0)
      col1 = colors[1]
    let col2 = "rgba("+hexToR(col1)+", "+hexToG(col1)+", "+hexToB(col1)+", 0.0)";// transparent
    rg.addColorStop(1.0, col1);
    rg.addColorStop(0.01, col2);
    ctx.fillStyle = rg
    ctx.beginPath()
    ctx.ellipse(cx, cy, r, R, a, 0, Math.PI * 2)
    ctx.closePath()
    ctx.fill()
    a += inc
  }
  ctx.globalAlpha *= 0.67
  i = 0, r = 18, inc = Math.PI/2
  for (; i < nucs; i++) {
    ctx.fillStyle = colors[1]
    if (i % 2)
      ctx.fillStyle = colors[0]
    ctx.beginPath()
    x = cx + r * Math.cos(a)
    y = cy + r * Math.sin(a)
    ctx.arc(x, y, 30, 0, Math.PI * 2)
    ctx.closePath()
    ctx.fill()
    if (i === 3) {
      r *= 4
      inc = 2*Math.PI/(nucs-4)
      a += inc/2
    }
    a += inc
    
  }
  // inner, inner disc
  ctx.globalAlpha = alpha/100
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function orbits () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/4
  let R = canvas.height * 0.15, r = R*2
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
 if (Math.random() > 0.5)
   colors = shuffle(['#ff00ff', '#ffff00', '#00ffff', '#7fff7f'])
  let cx = canvas.width/2, cy = canvas.height/2, x = 0, y = 0
  let a = Math.random() * 2 * Math.PI
  ctx.fillStyle = colors[0]
  ctx.beginPath()
  ctx.arc(cx, cy, R+r, 0, Math.PI * 2)
  ctx.closePath()
  ctx.fill()
  // inner disc
  x = cx + R * Math.cos(a)
  y = cy + R * Math.sin(a)
  ctx.fillStyle = (colors[1])
  ctx.beginPath()
  ctx.arc(x, y, r, 0, Math.PI * 2)
  ctx.closePath()
  ctx.fill()
  cx = x, cy = y
  // inner, inner disc
  a = Math.random() * 2 * Math.PI
  x = cx + r/3* Math.cos(a)
  y = cy + r/3* Math.sin(a)
  ctx.fillStyle = (colors[2])
  ctx.beginPath()
  ctx.arc(x, y, r*0.667, 0, Math.PI * 2)
  ctx.closePath()
  ctx.fill()
  ctx.globalAlpha = alpha/100
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function necker () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  //ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.lineWidth = 1 + Math.floor(document.getElementById("featuresize").value/50)
  let W = canvas.width
  let margin = W/20
  let w4 = (W-2*margin)/(2+Math.floor(Math.random() * 10))//document.getElementById("rows").value
 // ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let grunge = document.getElementById("grungy").checked
  if (Math.random() > 0.5) {
    //bottom
    ctx.beginPath();
    ctx.moveTo(margin, W-margin)
    ctx.lineTo(w4+margin, W-w4-margin)
    ctx.lineTo(W-margin, W-w4-margin)
    ctx.lineTo(W-w4-margin, W-margin)
    ctx.fillStyle = colors[3]
    ctx.fill()
    //left side
    ctx.moveTo(margin, w4+margin)
    ctx.lineTo(w4+margin, margin)
    ctx.lineTo(w4+margin, W-w4-margin)
    ctx.lineTo(margin, W-margin)
    ctx.fillStyle = colors[4]
    ctx.fill()
    //upper right
    ctx.beginPath();
    ctx.moveTo(w4+margin, 0+margin)
    ctx.lineTo(W-margin, 0+margin)
    ctx.lineTo(W-margin, W-w4-margin)
    ctx.lineTo(w4+margin, W-w4-margin)
    ctx.fillStyle = colors[0]
    ctx.fill()
    
    // lower left
    ctx.moveTo(margin, w4+margin)
    ctx.lineTo(W-w4-margin, w4+margin)
    ctx.lineTo(W-w4-margin, W-margin)
    ctx.lineTo(margin, W-margin)
    ctx.fillStyle = colors[1]
    ctx.fill()
    
    //top
    ctx.beginPath();
    ctx.moveTo(margin, w4+margin)
    ctx.lineTo(w4+margin, margin)
    ctx.lineTo(W-margin, margin)
    ctx.lineTo(W-w4-margin, w4+margin)
    ctx.fillStyle = colors[2]
    ctx.fill()
    
    //right side
    ctx.beginPath();
    ctx.moveTo(W-w4-margin, w4+margin)
    ctx.lineTo(W-margin, margin)
    ctx.lineTo(W-margin, W-w4-margin)
    ctx.lineTo(W-w4-margin, W-margin)
    ctx.fillStyle = colors[5]
    ctx.fill()
  } else {
      //top
    ctx.beginPath();
    ctx.moveTo(margin, w4+margin)
    ctx.lineTo(w4+margin, margin)
    ctx.lineTo(W-margin, margin)
    ctx.lineTo(W-w4-margin, w4+margin)
    ctx.fillStyle = colors[2]
    ctx.fill()
    
    //right side
    ctx.beginPath();
    ctx.moveTo(W-w4-margin, w4+margin)
    ctx.lineTo(W-margin, margin)
    ctx.lineTo(W-margin, W-w4-margin)
    ctx.lineTo(W-w4-margin, W-margin)
    ctx.fillStyle = colors[5]
    ctx.fill()
    
     // lower left square
    ctx.beginPath();
    ctx.moveTo(margin, w4+margin)
    ctx.lineTo(W-w4-margin, w4+margin)
    ctx.lineTo(W-w4-margin, W-margin)
    ctx.lineTo(margin, W-margin)
    ctx.fillStyle = colors[1]
    ctx.fill()
    
    //bottom
    ctx.beginPath();
    ctx.moveTo(margin, W-margin)
    ctx.lineTo(w4+margin, W-w4-margin)
    ctx.lineTo(W-margin, W-w4-margin)
    ctx.lineTo(W-w4-margin, W-margin)
    ctx.fillStyle = colors[3]
    ctx.fill()
    
    //upper right square
    ctx.beginPath();
    ctx.moveTo(w4+margin, 0+margin)
    ctx.lineTo(W-margin, 0+margin)
    ctx.lineTo(W-margin, W-w4-margin)
    ctx.lineTo(w4+margin, W-w4-margin)
    ctx.fillStyle = colors[2]
    ctx.fill()
   
    //left side
    ctx.beginPath();
    ctx.moveTo(margin, w4+margin)
    ctx.lineTo(w4+margin, margin)
    ctx.lineTo(w4+margin, W-w4-margin)
    ctx.lineTo(margin, W-margin)
    ctx.fillStyle = colors[4]
    ctx.fill()
  }
}

function justlines (canvas) { // grid paper
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alt = document.getElementById("grungy").checked
  let space = 6 + Math.floor(document.getElementById("featuresize").value/10)
  let pad = 24 + Math.random()*90
  let mod = randomPick([4,5,6])
  let colors = getCurrentPalette()
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let alpha = ctx.globalAlpha
  ctx.strokeStyle = randomPick(getCurrentPalette())
  ctx.lineWidth = randomPick([1,2,3,4,5])
  ctx.clearRect(0,0,W,H)
  let x = pad, y = pad
  let h = Math.floor(H-pad)
  let w = 1
  let text  = 0
  let cycle = Math.floor(10 + Math.random() * 50), index = 0
  let cols = ((W - pad*2)/w)/50
  let lines = 6
  i = 0
  let j = 0, p = 0.5;
  y = Math.floor(pad)
  for (; j < h+1; j++) {
    i = 0
    x = pad
    cols = 7+pet(1)
    ctx.lineWidth = randomPick([1,2,1])
    lw = ctx.lineWidth
    let limit = W-pad-cols
    ctx.beginPath()

    while (x < limit) {  // horizontal
      ctx.moveTo(x, y+pet(p))
      ctx.lineTo(x + cols, y+pet(p))
      
      x += cols
    }
    ctx.stroke()
    y += lines
    if (y % cycle === 0) {
      ctx.strokeStyle = colors[index]
      index = (index+1) % colors.length
    }
    if (y > H-pad)
     break;
  }
  ctx.strokeRect(pad,pad,W-2*pad, H-2*pad)
  ctx.globalAlpha = alpha
}

function rr () {
  // uv = unrounded value
  let uv = [0.00000,0.10000,0.20000,0.30000,0.40000,0.50000,0.60000,0.70000,0.80000,0.90000,1.00000,1.10000,1.20000,1.30000,1.40000,1.50000,1.60000,1.70000,1.80000,1.90000,2.00000,2.10000,2.20000,2.30000,2.40000,2.50000,2.60000,2.70000,2.80000,2.90000,3.00000,3.10000,3.20000,3.30000,3.40000,3.50000,3.60000,3.70000,3.80000,3.90000,4.00000,4.10000,4.20000,4.30000,4.40000,4.50000,4.60000,4.70000,4.80000,4.90000,5.00000,5.10000,5.20000,5.30000,5.40000,5.50000,5.60000,5.70000,5.80000,5.90000,6.00000,6.10000,6.20000,6.30000,6.40000,6.50000,6.60000,6.70000,6.80000,6.90000,7.00000,7.10000,7.20000,7.30000,7.40000,7.50000,7.60000,7.70000,7.80000,7.90000,8.00000,8.10000,8.20000,8.30000,8.40000,8.50000,8.60000,8.70000,8.80000,8.90000,9.00000,9.10000,9.20000,9.30000,9.40000,9.50000,9.60000,9.70000,9.80000,9.90000,10.00000,10.10000,10.20000,10.30000,10.34200,10.50000]
  let mult = 2
  let i = 0
  for (;i < uv.length;i++) {
    let prev = Math.floor(uv[i]/mult)*(mult) // previous mulitple
    let next = Math.ceil(uv[i]/mult)*(mult) // next multiple
    if (next !== prev && uv[i] - prev === next - uv[i]) {
      if((prev/mult) % 2 === 0) // test even-ness
        console.log("["+uv[i]+ " use "+prev+"]")
      else
        console.log("["+uv[i]+ " use "+next+"]")
    }
  }
}

function gridpaper (canvas) { // grid paper
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alt = document.getElementById("grungy").checked
  let space = 6 + Math.floor(document.getElementById("featuresize").value/10)
  let pad = 32
  let mod = randomPick([4,5,6])
  let colors = ["#ed6060", "#0000ba", "0000ed", "#ed0000", "#000000"]
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let alpha = ctx.globalAlpha
  ctx.strokeStyle = randomPick(getCurrentPalette())
  ctx.lineWidth = randomPick([1,2,3,4,5])
 // ctx.clearRect(0,0,W,H)
  ctx.fillStyle = color
  ctx.shadowColor = "#403030"
  ctx.shadowBlur = 9 + Math.random() * 5
  ctx.shadowOffsetY = 2 + Math.random() * 3
  ctx.shadowOffsetX = -2 + Math.random() * 2
  let x = pad, y = pad
  ctx.beginPath()
  ctx.moveTo(pad,pad)
  ragged(ctx,W-pad,pad,x,y)
  x = W-pad
  y = pad
  ragged(ctx,W-pad,H-pad+pet(3),x,y)
  y = H-pad
  ragged(ctx,pad,H-pad+pet(3),x,y)
  x = pad
  y = W-pad
  ragged(ctx,pad,pad+pet(3),x,y)
  ctx.closePath()
 // ctx.fill()
  ctx.shadowBlur = 0
  ctx.shadowOffsetY = 0
  ctx.shadowOffsetX = 0
  ctx.fillStyle = ctx.strokeStyle
  pad += 60 + Math.random() * 60
  let numbers = []
  let i = 0
  for (; i < 33*33; i++)
    numbers.push(i+1)
  let h = 2+Math.floor(Math.random() * 33), w = 2+Math.floor(Math.random() * 33)
  let text  = 0
  let cols = ((W - pad*2)/w)
  let lines = ((H - pad*2)/h)
  i = 0
  let j = 0, p = 1.3;
  y = pad
  let r = Math.min(cols,lines)/12
  let n = 0
  let face = "Courier"
  ctx.font = "800 "+(r*3)+"pt " + face
  let numb = Math.random() > 0.17
  let width = r*2
  for (; j < h+1; j++) {
    i = 0
    x = pad
    for (; i < w; i++) {  // horizontal
      ctx.beginPath()
      ctx.moveTo(x+pet(p), y+pet(p))
      ctx.lineTo(x + cols, y+pet(p))
      ctx.closePath()
      ctx.stroke()
      if (alt && j > 0) {
        if (numb) {
          ctx.globalAlpha = 0.8
          if (Math.random() > 0.75)
          ctx.globalAlpha = 0.4
          text = numbers[n++]
          width = ctx.measureText(text).width
          ctx.save()
          ctx.translate(x+cols/2-width/2+pet(2),y-lines/2+pet(2)+r/2)
          ctx.rotate(Math.random() * 2 * Math.PI) // need to adjust x & y offsets per line
          ctx.fillText(text, 0, 0)
          ctx.restore()
          ctx.globalAlpha = alpha
        } else {
          ctx.globalAlpha /= 10
          dotsNear2(ctx,x+cols/2,y-lines/2,r)
          ctx.globalAlpha = alpha
        }
      }
      x += cols
    }
    y += lines
  }
  ctx.lineWidth = randomPick([1,2,3,4,5])
  j = 0
  x = pad
  for (; j < w+1; j++) {
    i = 0
    y = pad
    for (; i < h; i++) {  // vertical
      ctx.beginPath()
      ctx.moveTo(x+pet(p), y+pet(p))
      ctx.lineTo(x+pet(p), y + lines)
      ctx.closePath()
      ctx.stroke()
      y += lines
    }
    x += cols
  }
  ctx.shadowBlur = 0
  ctx.shadowOffsetY = 0
  ctx.shadowOffsetX = 0
}

function calcY (x, slope, offset) {
  y = slope*x + offset
  return (y)
}

function halfToneMono () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let OC = document.getElementById("OC")
  let ctxOC = OC.getContext("2d")
  let W = canvas.width
  let H = canvas.height
  ctxOC.globalAlpha = document.getElementById("opacity").value/100
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctxOC.lineWidth = randomPick([4,5])
  let pad = 1080/10 + pet(40)
  let x =  - Math.random() *100, y = pad - Math.random() *100
  let w = 1080/20, h = 1080/20
  let i = 0
  let alt = document.getElementById("grungy").checked
  let offset = 10 + document.getElementById("featuresize").value/10
  let offset2 = Math.floor(Math.random() * offset)// for drawing
  let r = offset * 0.5, yd = 0
  let r0 = r
  let FH = true
  let off = Math.random() > 0.5
  let loopmax = W/offset*2
  let color = randomPick(getCurrentPalette()) // was paintcolor
  ctxOC.fillStyle  = color
  
  let j = 0, B = 0, C = 0
  for (; j < loopmax; j++) {
    x = 0, y = j * offset
    if (off)
      x += offset/2
    off = !off
    i = 0
    for (; i < loopmax; i++) {  // horizontal
      C = colorOf10(ctx,x,y,1,color) // should be closenedd
      r = offset/20 * C
      ctxOC.beginPath()
      yd = offset2
      ctxOC.moveTo(x+yd, y+yd)
      r = Math.max(r,0)
      if (alt)
        r *= 2
      ctxOC.arc(x+yd,y+yd,r,0,Math.PI*2)
      ctxOC.closePath()
      ctxOC.fill()
      x += offset
    }
  }
  swapWithOff()
}

function halfTone () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.lineWidth = randomPick([4,5])
  let colors = shuffle(getCurrentPalette())
  let pad = 1080/10 + pet(40)
  let x =  - Math.random() *100, y = pad - Math.random() *100
  let w = 1080/20, h = 1080/20
  let i = 0
  //let Os = [100, 300, 400, 100, 300]
  let alt = document.getElementById("grungy").checked
  let offset = 50 + document.getElementById("featuresize").value/4
  let xoffset = offset //+ pet(offset)
  let yoffset = offset //+ pet(offset)
  let r = offset * (0.15 + Math.random()/3), yd = 0
  let r0 = r
  let FH = true
  let c = 0, off = Math.random() > 0.5
  let loopmax = W/xoffset*2
  for (;c < colors.length; c++) { // colors loop
    ctx.fillStyle = colors[c]
    let slope = Math.random()/7
    if (Math.random() > 0.5)
      slope *= -1
    if (FH)
      flipH()
    else
      flipV()
    FH = !FH
    let j = 0
    for (; j < loopmax; j++) {
      x = -xoffset, y = j * yoffset
      if (off)
        x -= xoffset/2
      off = !off
      i = 0
      for (; i < loopmax; i++) {  // horizontal
        ctx.beginPath()
        yd = calcY(x, slope, 0)
        ctx.moveTo(x, y+yd)
        if (alt)
          r = r0 + pet(r0/2)
        ctx.arc(x,y+yd,r,0,Math.PI*2)
        ctx.closePath()
        ctx.fill()
        x += xoffset
      }
    }
  }
  
  /* colors.    L FH FV
                1 1 0
                2 1 1
                3 2 1
                4 2 2
                5 3 2
                6 3 3
                */
  if ([1,2,5,6].includes (colors.length))
    flipH()
  if ([2,4,6].includes (colors.length))
    flipV()
}

function cuttingboard () { // white grid on teal
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let space = 6 + Math.floor(document.getElementById("featuresize").value/10)
  let mod = randomPick([4,5,6])
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.lineWidth = randomPick([4,5])
  ctx.fillStyle = "#008080"
  ctx.strokeStyle = "#ffffff"
  ctx.fillRect(0,0,W,H)
  let pad = 1080/10 + pet(40)
  let x =  - Math.random() *100, y = pad - Math.random() *100
  let w = 1080/20, h = 1080/20
  let i = 0
  let offset = (Math.random() - 0.5) *27
  for (; i < w; i++) {  // horizontal
    ctx.beginPath()
    ctx.moveTo(x, y+offset)
    ctx.lineTo(x + W+200, y-offset)
    ctx.closePath()
    ctx.stroke()
    y += pad
  }
  x = -100
  i = 0
  y = -100
  for (; i < w; i++) {  // vertical
    ctx.beginPath()
    ctx.moveTo(x-offset, y)
    ctx.lineTo(x+offset, y + H+200)
    ctx.closePath()
    ctx.stroke()
    x += pad
  }
  //diag from bottom left
  x = pet(240)
  ctx.beginPath()
  ctx.moveTo(x, H+100)
  ctx.lineTo(W/2+pet(W/3), -10)
  ctx.closePath()
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x, H+100)
  ctx.lineTo(W+ Math.random() * W/2, 100 + Math.random()+ H/3)
  ctx.closePath()
  ctx.stroke()
  let alpha = document.getElementById("opacity").value
  let fs = document.getElementById("featuresize").value
  randomPick(getCurrentPalette()) // was paintcolor = "#ddffff"
  document.getElementById("opacity").value = 17
  haze()
  randomPick(getCurrentPalette()) // was paintcolor = "#ddffff"
  document.getElementById("featuresize").value = 170
  document.getElementById("opacity").value = 70
  rays()
  randomPick(getCurrentPalette()) // was paintcolor = "#006060"
  rays()
  randomPick(getCurrentPalette()) // was paintcolor = color
  document.getElementById("opacity").value = alpha
  document.getElementById("featuresize").value = fs
}

function gridpaper_og () { // grid paper
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alt = document.getElementById("grungy").checked
  let space = 6 + Math.floor(document.getElementById("featuresize").value/10)
  let pad = 8
  let mod = randomPick([4,5,6])
  let colors = ["#ed6060", "#6060ba", "#6060ed", "#ed6060", "#000000"]
  ctx.globalAlpha = document.getElementById("opacity").value/200
  ctx.strokeStyle = randomPick(colors)
  ctx.lineWidth = 1
  if (alt)
    pad = 42
    
  let AW = (W - (pad*2)) // available width
  let maxcount = (Math.floor(AW/space) - Math.floor(AW/space) % mod) + 1
  let count = 0
  let maxW = pad + space*(maxcount-1)
  let startX = pad+(AW - maxW)
  if (startX < pad)
    startX = pad
  
  let i = 0, x = startX, y = 4
  while (y < H-space) {  // horizontal
    ctx.lineWidth = (i % mod === 0)? 3 : 1;
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(maxW+startX-pad, y)
    ctx.closePath()
    ctx.stroke()
    y += space
    i++
    count++
  }
  i = 0, x = startX, y = 4, count = 0
  while (x < W-pad && count < maxcount) {  // vertical
    ctx.lineWidth = (i % mod === 0)? 3 : 1;
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(x, H - 3)
    ctx.closePath()
    ctx.stroke()
    x += space
    i++
    count++
  }
  space = 8
  if (alt) { // continuous feed
    ctx.globalAlpha = document.getElementById("opacity").value/100
    ctx.fillStyle = "#ffffff"
    ctx.shadowBlur = 1
    ctx.shadowColor = "#cccccc"
    ctx.shadowOffsetX = -1
    ctx.shadowOffsetY = -1
    i = 0, y = 30, x = W-space*2.5
    while (y < H) {
      ctx.beginPath()
      ctx.arc(x, y, 8, 0, 2*Math.PI)
      ctx.closePath()
      ctx.fill()
      y += 40
    }
    i = 0, y = 30, x = space*2.5
    while (y < H) {
      ctx.beginPath()
      ctx.arc(x, y, 8, 0, 2*Math.PI)
      ctx.closePath()
      ctx.fill()
      y += 40
    }
    ctx.shadowBlur = 0
    ctx.shadowOffsetX = 0
    ctx.shadowOffsetY = 0
  }
}

function dividedPad () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alt = document.getElementById("grungy").checked
  let pad = 2
  let H = canvas.height, W = canvas.width
  let x = pad+pet(9), y = pad+pet(9)

  let cx1 = W - pad*4+pet(91), cy1 = pad+pet(21),
    cx2 = W -pad+pet(21), cy2 = 3*pad+pet(21),
    px = cx1+8, py = cy2-3
    
  let colors = ["#ed6060", "#6060ba", "#6060ed", "#ed6060", "#000000"]
  ctx.lineWidth = 1.5
  ctx.fillStyle = color
 /* ctx.shadowBlur = 10
  ctx.shadowColor = "#303020"
  ctx.shadowOffsetX = 2
  ctx.shadowOffsetY = 2
  ctx.beginPath()
  ctx.moveTo(pad,pad)
  ragged(ctx,W-pad,pad,x,y)
  x = W-pad
  y = pad
  ragged(ctx,W-pad,H-pad+pet(3),x,y)
  y = H-pad
  ragged(ctx,pad,H-pad+pet(3),x,y)
  x = pad
  y = W-pad
  ragged(ctx,pad,pad+pet(3),x,y)
  ctx.closePath()
  ctx.fill()
  
 // ctx.fillStyle = "#ffaaaa"
  // dogear
  
  ctx.shadowBlur = 20
  ctx.shadowOffsetX = -4
  ctx.shadowOffsetY = -4
  ctx.beginPath()
  ctx.moveTo(cx1,cy1)
  ragged(ctx, px,py,cx1,cy1)
  ragged(ctx, cx2,cy2,px,py)
  ctx.lineTo(cx1, cy1)
  ctx.closePath()
  //ctx.fill()

  ctx.shadowBlur = 0
  ctx.shadowOffsetX = 0
  ctx.shadowOffsetY = 0
  ctx.strokeStyle = "#ff0000"
  ctx.beginPath()
  ctx.moveTo(canvas.width/2, 8+pad)
  ctx.lineTo(canvas.width/2, canvas.height-pad-4)
  ctx.closePath()
  ctx.stroke()*/
  ctx.lineWidth = 1
  ctx.strokeStyle = randomPick(colors)//"#6060ed"
  let i = 0
  x = 2+pad, y = 100+pad
  while (y < canvas.height-pad) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(canvas.width-pad-4, y)
    ctx.closePath()
    ctx.stroke()
    y += 28
  }
  ctx.strokeStyle = "#ee6060"
  i = 0, y = pad, x = 32+pad
  for (; i < 2; i++) {
    ctx.beginPath()
    ctx.moveTo(x, y+100)
    ctx.lineTo(x, canvas.height-pad-4)
    ctx.closePath()
    ctx.stroke()
    x = canvas.width/2 + 32
  }
}


function thisSpace () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alt = document.getElementById("grungy").checked
  ctx.globalAlpha = document.getElementById("opacity").value/100

  let pad = 24 +Math.floor(Math.random() * 12)
  let H = canvas.height, W = canvas.width
  let x = pad+pet(9), y = pad+pet(9)
  
  let cx1 = W - pad*4+pet(91), cy1 = pad+pet(21),
    cx2 = W -pad+pet(21), cy2 = 3*pad+pet(21),
    px = cx1+8, py = cy2-3
    
  ctx.fillStyle = color
  let colors = [ "#6060ba", "#6060ed", "#000000"]
  ctx.lineWidth = 3
  ctx.shadowBlur = 10
  ctx.shadowColor = "#303020"
  ctx.shadowOffsetX = -3
  ctx.shadowOffsetY = 3
  
  ctx.beginPath()
  ctx.moveTo(pad,pad)
  ragged(ctx,W-pad,pad,x,y)
  x = W-pad
  y = pad
  ragged(ctx,W-pad,H-pad+pet(3),x,y)
  y = H-pad
  ragged(ctx,pad,H-pad+pet(3),x,y)
  x = pad
  y = W-pad
  ragged(ctx,pad,pad+pet(3),x,y)
  ctx.closePath()
  ctx.fill()
  ctx.globalAlpha = 0.7
  ctx.shadowBlur = 0
  ctx.shadowOffsetX = 0
  ctx.shadowOffsetY = 0
  ctx.strokeStyle = randomPick(colors)
  ctx.lineWidth = 3 + Math.floor(Math.random() * 6)
  
  ctx.beginPath()
  ctx.moveTo(pad*3, pad*3)
  ctx.lineTo(W-pad*3, pad*3)
  ctx.lineTo(W-pad*3, H-pad*3)
  ctx.lineTo(pad*3, H-pad*3)
  ctx.lineTo(pad*3, pad*3)
  ctx.stroke()

  let text = "This space intentionally left blank."
  ctx.fillStyle = ctx.strokeStyle//randomPick(colors)
  let face = "Arial"
  ctx.font = "100 "+(14)+"pt " + face
  let width = ctx.measureText(text).width
  ctx.fillText(text, W/2-width/2, H-pad*3.6)
  
  text = 10+Math.floor(Math.random() * 89)
  face = "AmericanTypewriter"
  ctx.font = "800 "+(54)+"pt " + face
  ctx.fillText(text, pad*3.6, pad*3.6+54)
  
  ctx.beginPath()
  ctx.moveTo(W-pad*4-50, pad*3+20)
  ctx.lineTo(W-pad*4+10, pad*3+20)
  ctx.lineTo(W-pad*4+10, pad*3+80)
  ctx.lineTo(W-pad*4-50, pad*3+80)
  ctx.lineTo(W-pad*4-50, pad*3+20)
  ctx.stroke()
  
  ctx.lineWidth /= 2
  ctx.beginPath()
  ctx.moveTo(pad*3, H-pad*3)
  ctx.lineTo(W-pad*3, pad*3)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(pad*3, pad*3)
  ctx.lineTo(W-pad*3, H-pad*3)
  ctx.stroke()
  ctx.globalAlpha = document.getElementById("opacity").value/100
}

function survey () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alt = document.getElementById("grungy").checked
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let H = canvas.height, W = canvas.width
  ctx.fillStyle = color
  let colors = getCurrentPalette()
  ctx.lineWidth = 3
  ctx.strokeStyle = randomPick(colors)
  ctx.fillStyle = ctx.strokeStyle
  let agree = ["1 [  ] strongly disagree", "2 [  ] somewhat disagree", "3 [  ] neutral", "4 [  ] somewhat agree", "5 [  ] strongly agree"]
  let text =""
  let face = "helvetica"
  ctx.fillStyle = ctx.strokeStyle
  let width = ctx.measureText("[  ] ").width
  let w = Math.floor(W/8.5)
  let h = Math.floor(H/20)
  let i = 0, qn = 1+Math.floor(Math.random() * 100)
  let hoff = 0
  let MAX = 16//randomPick([141,139,138,142])
  for (; i < 15; i+=1) {
    if (i % 5 === 0) {
      h += Math.floor(H/24)
      if (alt) {
        ctx.font = "100 "+(18)+"pt " + face
        ctx.fillText(randomWord() +randomPick([" > "," is "," before "," over "," becomes "," follows "," makes "," before "," takes "," means "," causes "])+ randomWord(), w+15, h+13)
      }
      ctx.font = "800 "+(24)+"pt " + face
      ctx.fillText(qn++, w -37, h+18)
      ctx.beginPath()
      ctx.moveTo(w+pet(3), h+24+pet(9))
      ctx.lineTo(W-W/10, h+24+pet(9))
      ctx.stroke()
    }
    h += Math.floor(H/20) + pet(6)
    ctx.font = "500 "+(randomPick([21,20]))+"pt " + face
    ctx.fillText(agree[i%agree.length], w+pet(7), h+pet(5))
  }
  ctx.globalAlpha = document.getElementById("opacity").value/100
}

function checklist () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alt = document.getElementById("grungy").checked
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let H = canvas.height, W = canvas.width
  ctx.fillStyle = color
  let colors = getCurrentPalette()
  ctx.lineWidth = 3
  ctx.strokeStyle = randomPick(colors)
  ctx.fillStyle = ctx.strokeStyle
  let w = Math.floor(W/8.5)
  let h = Math.floor(H/20)
  let i = 1, ct = 1, im = i
  let hoff = 0
  let MAX = randomPick([141,139,138,142])
  let box = randomPick([20,22,24])
  for (; i < MAX; i+=2) {
    im = i % 10
    ct++
    ctx.beginPath()
    hoff = pet(5)
    ctx.moveTo(w*im+pet(3), h+24+pet(3))
    ctx.lineTo(w*im+w+pet(3), h+24+hoff)
    ctx.lineWidth = randomPick([3,4,5,5,4,4])
    ctx.stroke()
    // draw a box instead
    ctx.strokeRect(w*im+pet(9)-24, h-6+pet(7),box,box)
    if (ct % 6 == 0) {
      h += Math.floor(H/13)
      im = 1
    }
  }
  ctx.globalAlpha = document.getElementById("opacity").value/100
}


function requirements () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alt = document.getElementById("grungy").checked
  ctx.globalAlpha = document.getElementById("opacity").value/100

  let pad = 24
  let H = canvas.height, W = canvas.width
  let x = pad+pet(9), y = pad+pet(9)
  
  let cx1 = W - pad*4+pet(91), cy1 = pad+pet(21),
    cx2 = W -pad+pet(21), cy2 = 3*pad+pet(21),
    px = cx1+8, py = cy2-3
    
  ctx.fillStyle = color
  let colors = [ "#6060ba", "#6060ed", "#000000"]
  ctx.lineWidth = 3
  ctx.shadowBlur = 10
  ctx.shadowColor = "#303020"
  ctx.shadowOffsetX = -3
  ctx.shadowOffsetY = 3
  
  ctx.beginPath()
  ctx.moveTo(pad,pad)
  ragged(ctx,W-pad,pad,x,y)
  x = W-pad
  y = pad
  ragged(ctx,W-pad,H-pad+pet(3),x,y)
  y = H-pad
  ragged(ctx,pad,H-pad+pet(3),x,y)
  x = pad
  y = W-pad
  ragged(ctx,pad,pad+pet(3),x,y)
  ctx.closePath()
  ctx.fill()

  ctx.shadowBlur = 0
  ctx.shadowOffsetX = 0
  ctx.shadowOffsetY = 0
  ctx.lineWidth = 7
  ctx.strokeStyle = randomPick(colors)
  let text = "R E Q U I R E M E N T S"
  let face = "Arial"
  ctx.font = "800 "+(20)+"pt " + face
  ctx.fillStyle = ctx.strokeStyle
  
  ctx.font = "800 "+(32)+"pt " + face
  let width = ctx.measureText(text).width
  ctx.globalAlpha = 0.7

  ctx.fillText(text, W/2-width/2,80)
  ctx.font = "800 "+(20)+"pt " + face
  face = "AmericanTypewriter"
  let w = Math.floor(W/11)
  let h = Math.floor(H/7)
  
  let i = 1, ct = 1, im = i
  let hoff = 0
  x = 0, y = 0
  let MAX = randomPick([101,97,87,94])
  for (; i < MAX; i+=2) {
    im = i % 10
    text = ct++
    if (ct < 10)
      text = "0"+text
    ctx.beginPath()
    hoff = pet(5)
    ctx.moveTo(w*im+pet(3), h+hoff+pet(3))
    ctx.lineTo(w*im+w+pet(3), h+hoff)
    ctx.lineWidth = randomPick([3,4,5,5,4,4])
    ctx.stroke()
    ctx.font = "800 "+(randomPick([18,19,16]))+"pt " + face
    ctx.fillText(text, w*im+w*0.8+pet(19), h+30+pet(7))
    if (Math.random() > 0.95)
      dotsNear(ctx,w*im+w*0.8+pet(19), h+30+pet(19),7+pet(3))
    if (ct % 6 == 0) {
      h += Math.floor(H/11)
     // w = W/7
      im = 1
    }
  }
  text = "This space intentionally                  ."
  ctx.font = "100 "+(9)+"pt " + face
  ctx.face = "Arial"
  ctx.fillText(text, pad*2, H-pad*2)
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.shadowBlur = 0
  ctx.shadowOffsetY = 0
  ctx.shadowOffsetX = 0
}

function numberShow () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let alt = document.getElementById("grungy").checked
  let mode = document.getElementById("mode").checked
  let W = canvas.width, H = canvas.height
  let pad = 30 + Math.floor(Math.random() * 12)
  let linespace = 34 + Math.floor(pet(16))

  let color = randomPick(getCurrentPalette())
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.lineWidth = 1
  let i = 0, x = pad+2, y = pad+94
  let text = 2+Math.floor(Math.random() * 101)

  let face = "helvetica"
  let size = H*0.8
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  ctx.fillStyle = color
  ctx.strokeStyle = "#505050"
  ctx.font = size+"pt " + face
  w = ctx.measureText(text).width

  ctx.fillText(text, W/2-w/2, pad*2+size)
  ctx.scale(-1, 1)

  ctx.globalAlpha /= 2
  ctx.fillText(text-1, -w*1.1+pet(50), pad*2+size+pet(50))

  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.globalAlpha = document.getElementById("opacity").value/100
}

function crosswordPad (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alt = document.getElementById("grungy").checked
  let W = canvas.width, H = canvas.height
  let pad = 24 + Math.floor(Math.random() * 44)
  let MULT = randomPick([8,9,10,11,13])
  let divisions = 1
  let avail = (W-2*pad)/divisions
  let linespace = avail/MULT
  ctx.fillStyle = "#ffffff"//color
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = color
  ctx.fillStyle = ctx.strokeStyle
  ctx.lineWidth = 3
  let i = 0, x = pad, y = pad, num = 1
  while (i < divisions*MULT+1) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(canvas.width-pad, y)
    ctx.closePath()
    ctx.stroke()
    y += linespace
    i++
  }
  ctx.lineWidth = 3
  i = 0, y = pad, x = pad
  while (i < divisions*MULT+1) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(x, canvas.height-pad)
    ctx.closePath()
    ctx.stroke()
    x += linespace
    i++
  }
  let filled = {}
  i = 0, y = pad, x = pad
  let face = "Courier"
  ctx.font = "800 "+(18)+"pt " + face
  for (;i < MULT; i++) {
    j = 0
    for (; j < MULT; j++) {
      filled[i+"-"+j] = "0"
      if (Math.random() > 0.75) {
        ctx.fillRect(x,y,linespace, linespace)
        filled[i+"-"+j] = "B"
      }
      x += linespace
      if (x > linespace*MULT)
        x = pad
    }
    y += linespace
    if (y > linespace*MULT)
      y = pad
  }
  
  i = 0, y = pad, x = pad
  for (;i < MULT; i++) {
    j = 0
    for (; j < MULT; j++) {
      if (filled[i+"-"+j] !== "B") {
        if (blanksHorV(i,j,filled)) {
          ctx.fillText(num,x+4,y+20)
          filled[i+"-"+j] = "N"
          num++
        }
        if (isolatedBlank(i,j,filled)) {
          ctx.fillRect(x,y,linespace, linespace)
          filled[i+"-"+j] = "B"
        }
      }
      x += linespace
      if (x > linespace*MULT)
        x = pad
    }
    y += linespace
      if (y > linespace*MULT)
        y = pad
  }
  randomPick(getCurrentPalette()) // was paintcolor = color
}

function isolatedBlank (i,j,filled) {
  let sum = 0
  if (filled[(i-1)+"-"+j] === undefined || filled[(i-1)+"-"+j] === "B")
    sum++
  if (filled[(i+1)+"-"+j] === undefined || filled[(i+1)+"-"+j] === "B")
    sum++
  if (filled[i+"-"+(j-1)] === undefined || filled[i+"-"+(j-1)] === "B")
    sum++
  if (filled[i+"-"+(j+1)] === undefined || filled[i+"-"+(j+1)] === "B")
    sum++
  if (sum === 4)
    return true
  else
    return false
}

function blanksHorV (i,j,filled) {
  let okH = false, okV = false
  if (filled[(i-1)+"-"+j] === undefined || filled[(i-1)+"-"+j] === "B")
      okH = true
  if (filled[(i+1)+"-"+j] === undefined || filled[(i+1)+"-"+j] === "B")
      okH = false
  if (filled[i+"-"+(j-1)] === undefined || filled[i+"-"+(j-1)] === "B")
      okV = true
  if (filled[i+"-"+(j+1)] === undefined || filled[i+"-"+(j+1)] === "B")
      okV = false
  return (okV || okH)
}


function griddots () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let colors = shuffle(getCurrentPalette(true,13))
  let W = canvas.width
  let H = W
  let mod = randomPick([2,3,4])
  ctx.lineWidth = 2
  let divs = 12 + Math.floor(document.getElementById("featuresize").value/8)
  let pad = 0
  if (document.getElementById("grungy").checked)
    pad = divs * 2
  ctx.fillStyle = randomPick(colors)
  r = 1.5
  let i = 0, x = pad, y = pad
  let avail = (W-2*pad)
  let N = Math.floor(avail/divs)+2
  let linespace = Math.floor(avail/N)
  if (pad === 0)
    N += 6
  let maxx = pad+(N+1)*linespace
  // center drawing if padded
  let diff = Math.abs((W-maxx))
  if (pad > 0) {
    pad = (pad+diff)/2
    maxx = W - pad
  }
  for (; i < (N+20)*(N+10); i++) {
    if (y > H - pad)
      break
    ctx.beginPath()
    if (Math.random() > .5) //(i % mod === 0)
      r = 3
    else
      r = 1
    r = randomPick([1,3,5,7])
    ctx.arc(x,y,r,0,Math.PI*2)
    ctx.fill()
    x += linespace
    if (x > W-pad) {
      x = pad
      y += linespace
    }
    if (y > H - pad)
      break
  }
}

function griddiagd (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let colors = shuffle(getCurrentPalette(true,13))
  let W = canvas.width
  let H = W
  ctx.lineWidth = 2
  let divs = 12 + Math.floor(document.getElementById("featuresize").value/8)
  let pad = 0
  if (document.getElementById("grungy").checked)
    pad = divs * 2
  ctx.strokeStyle = randomPick(colors)
  ctx.lineCap = "square"
  //ctx.lineJoin = "meter"
  let i = 0, x = 0, y = 0
  let avail = (W-2*pad)
  let N = Math.floor(avail/divs)+2
  let linespace = Math.floor(avail/N)
  if (pad === 0)
    N += 6
  let maxx = pad+(N+1)*linespace
  // center drawing if padded
  let diff = Math.abs((W-maxx))
  if (pad > 0) {
    pad = (pad+diff)/2
    maxx = W - pad
  }
  // diags
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(pad,pad)
  ctx.lineTo(maxx,pad)
  ctx.lineTo(maxx,maxx)
  ctx.lineTo(pad,maxx)
  ctx.lineTo(pad,pad)
  ctx.stroke()
  ctx.closePath()
  ctx.clip()
  ctx.lineWidth = 1
  i = 0, y = 0, x = 0
  for (; i < N*2+4; i++) {
    ctx.beginPath()
    ctx.moveTo(x+pad,y+pad)
    ctx.lineTo(x+pad+(i*linespace), pad)
    ctx.stroke()
    y += linespace
  }
  ctx.restore()
}

function griddiag (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let colors = shuffle(getCurrentPalette(true,13))
  let W = canvas.width
  let H = W
  ctx.lineWidth = 2
  let divs = 12 + Math.floor(document.getElementById("featuresize").value/8)
  let pad = 0
  if (document.getElementById("grungy").checked)
    pad = divs * 2
  ctx.strokeStyle = randomPick(colors)
  ctx.lineCap = "square"
  //ctx.lineJoin = "meter"
  let i = 0, x = 0, y = 0
  let avail = (W-2*pad)
  let N = Math.floor(avail/divs)+2
  let linespace = Math.floor(avail/N)
  if (pad === 0)
    N += 6
  let maxx = pad+(N+1)*linespace
  let diff = Math.abs((W-maxx))
  if (pad > 0) {
    pad = (pad+diff)/2
    maxx = W - pad
  }
  for (; i < N+2; i++) {
    ctx.beginPath()
    ctx.moveTo(x+pad,y+pad)
    ctx.lineTo(maxx, y+pad)
    if (i % 2 === 0)
      ctx.lineWidth = 3
    else
      ctx.lineWidth = 1
    ctx.stroke()
    y += linespace
  }
  i = 0, y = 0, x = 0
  for (; i < N+2; i++) {
    ctx.beginPath()
    ctx.moveTo(x+pad,y+pad)
    ctx.lineTo(x+pad, maxx)
    if (i % 2 === 0)
      ctx.lineWidth = 3
    else
      ctx.lineWidth = 1
    ctx.stroke()
    x += linespace
  }
  // diags
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(pad,pad)
  ctx.lineTo(maxx,pad)
  ctx.lineTo(maxx,maxx)
  ctx.lineTo(pad,maxx)
  ctx.lineTo(pad,pad)
  ctx.closePath()
  ctx.clip()
  ctx.lineWidth = 1
  i = 0, y = 0, x = 0
  for (; i < N*2+4; i++) {
    ctx.beginPath()
    ctx.moveTo(x+pad,y+pad)
    ctx.lineTo(x+pad+(i*linespace), pad)
    ctx.stroke()
    y += linespace
  }
  ctx.restore()
}

function gridLinear (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/10
  let color = randomPick(getCurrentPalette(true, 13))
  let alt = document.getElementById("grungy").checked
  let W = canvas.width, H = canvas.height
  let pad = 24 + Math.floor(Math.random() * 44)
  let divisions = randomPick([1,2,3,4,5,6,7])
  let avail = (W-2*pad)/divisions
  let linespace = avail/10
  ctx.fillStyle = "#ffffff"//color
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = color
  ctx.lineWidth = 3
  let i = 0, x = pad, y = pad
  while (i < divisions*10+1) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(canvas.width-pad, y)
    ctx.closePath()
    ctx.stroke()
    y += linespace
    i++
    if (i % 10 === 0)
      ctx.lineWidth = 3
      else
      ctx.lineWidth = 1
  }
  
  ctx.lineWidth = 3
  i = 0, y = pad, x = pad
  while (i < divisions*10+1) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(x, canvas.height-pad)
    ctx.closePath()
    ctx.stroke()
    x += linespace
    i++
    if (i % 10 === 0)
      ctx.lineWidth = 3
      else
      ctx.lineWidth = 1
  }
  randomPick(getCurrentPalette()) // was paintcolor = color
}

function gridLog (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1 //+ document.getElementById("featuresize").value/10
  let color = randomPick(getCurrentPalette(true, 13))
  let alt = document.getElementById("grungy").checked
  let W = canvas.width, H = canvas.height
  let pad = 24 + Math.floor(Math.random() * 36)
  let divisions = randomPick([1,2,3,4])
  let avail = (W-2*pad)/divisions
  let spacerx = avail/55 * 10
  let linespace = spacerx//24 + Math.random() * 20,
  let LS = linespace
  let spacer = avail/55 * 1//linespace
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = color
  let i = 0, x = pad, y = pad
  while (i < divisions*10+1) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(canvas.width-pad, y)
    ctx.closePath()
    ctx.stroke()
    y += linespace
    linespace -= spacer
    i++
    if (i % 10 === 0)
      linespace = LS
  }
  linespace = LS
  i = 0, y = pad, x = pad
  while (i < divisions*10+1) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(x, canvas.height-pad)
    ctx.closePath()
    ctx.stroke()
    x += linespace
    linespace -= spacer
    i++
    if (i % 10 === 0)
      linespace = LS
  }
  randomPick(getCurrentPalette()) // was paintcolor = color
}


function scratchout () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let fs = 7 + document.getElementById("featuresize").value/10
  let D = 1 + document.getElementById("number").value/5000
  let bump = fs/2
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alt = document.getElementById("grungy").checked
  let W = canvas.width, H = canvas.height
  let pad = 4 + Math.floor(Math.random() * 2)
  let linespace = 18 + Math.floor(pet(8))
  ctx.fillStyle = "#ffffff"//color
  //let colors = ["#ed6060", "#6060ba", "#6060ed", "#ed6060", "#000000"]
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = randomPick(getCurrentPalette())
  ctx.lineJoin = "round"
  ctx.lineWidth = Math.floor(1 + fs/20)
  ctx.imageSmoothingQuality = "high"
  let i = 0, x = LASTCLICK[0], y = LASTCLICK[1], rot = 1
  let maxX = fs*4 + Math.random() * 4 * fs, maxY = fs*0.8
  
  if (alt)
    maxY = maxX
    
  let cx1, cy1, cx2, cy2
  ctx.beginPath()
  ctx.moveTo(x, y)
  let d = 20, N = 3*Math.random()*8
  for (; i < 5; i++) {
    d = fs
    cx1 = x+maxX+pet(d*3), cy1 = y+maxY+pet(d/8)
    cx2 = x-maxX+pet(d*3), cy2 = y-maxY+pet(d/8)
    x = x + pet(d)
    y = y + pet(d)
    ctx.bezierCurveTo(cx1,cy1,cx2,cy2, x+pet(d/2), y)
    maxY *= -1
  }
  LASTCLICK[0] = x + maxX*0.67
  ctx.stroke()
  ctx.closePath()
}

function aletter () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let fs = 48//7 + document.getElementById("featuresize").value/10
  let D = 1 + document.getElementById("number").value/4000
  let bump = fs/2
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alt = document.getElementById("grungy").checked
  let W = canvas.width, H = canvas.height
  let pad = 4 + Math.floor(Math.random() * 2)
  let linespace = 18 + Math.floor(pet(8))
  ctx.fillStyle = "#ffffff"//color
  ctx.fillRect(0,0,W,H)
  //let colors = ["#ed6060", "#6060ba", "#6060ed", "#ed6060", "#000000"]
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = "#000000"
  ctx.lineJoin = "round"
  ctx.lineWidth = Math.floor(1 + fs/20)
  ctx.imageSmoothingQuality = "high"
  let i = 0, x = 200, y = 200, rot = 1
  let cx1, cy1, cx2, cy2
  let maxX = x+1*fs + Math.random() * 8 * fs
  ctx.beginPath()
  while (i < 2) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    cx1 = x+fs*2, cy1 = y -3*fs
    cx2 = x-fs*2, cy2 = y +3*fs
    bump = 2*fs/3 + pet(fs*D/4)
    if (Math.random() < 0.15) {
      cy2 += 4*fs
    } else
    if (Math.random() < 0.23) {
      cy1 -= 4*fs
    }
    cx1+=pet(D*fs)
    cy1+=pet(D*fs)
    
    cx2+=pet(D*fs)
    cy2+=pet(D*fs)
    //ctx.bezierCurveTo(cx1+pet(fs*4),cy1+pet(fs*4),cx2+pet(fs*4),cy2+pet(fs*4), x+bump, y)
    ctx.bezierCurveTo(cx1,cy1,cx2,cy2, x+bump, y)
    ctx.stroke()
    ctx.closePath()
    x += bump
    i++
    
    if (alt && Math.random() > 0.9)
      x += bump
  }
  LASTCLICK[0] = x + bump
}

function beztest () {
  let ax = 50, ay = 50
  let bx = 450, by = 100
  let cx = 200, cy = 200
  let dx = 400, dy = 300
  bez_pts (ax,ay, bx,by, cx,cy, dx,dy)
}

/*
B0_t = (1-t)^3
B1_t = 3 * t * (1-t)^2
B2_t = 3 * t^2 * (1-t)
B3_t = t^3
Notice how B0_t is 1 when t is 0 (and everything else is zero). Also, B3_t is 1 when t is 1 (and everything else is zero). So the curve starts at (ax, ay), and ends at (dx, dy).

Any intermediate point (px_t, py_t) will be given by the following (vary t from 0 to 1, in small increments inside a loop):

px_t = (B0_t * ax) + (B1_t * bx) + (B2_t * cx) + (B3_t * dx)
py_t = (B0_t * ay) + (B1_t * by) + (B2_t * cy) + (B3_t * dy)
*/
function bez_pts (ax,ay, bx,by, cx,cy, dx, dy, ctx) { // b and c are control points, a = start, d = end
  let canvas = document.getElementById("myCanvas");
  if (!ctx)
    ctx = canvas.getContext("2d");
  let fs = 7 + document.getElementById("featuresize").value/10
  let lw = fs/45
  let t = 0, a = 1.1*Math.PI + pet(1)/4
  for (; t < 1; t += 0.0005) {
    let B0_t = (1-t) * (1-t) * (1-t)
    let B1_t = 3 * t * (1-t) * (1-t)
    let B2_t = 3 * t*t * (1-t)
    let B3_t = t*t*t
    let px_t = (B0_t * ax) + (B1_t * bx) + (B2_t * cx) + (B3_t * dx)
    let py_t = (B0_t * ay) + (B1_t * by) + (B2_t * cy) + (B3_t * dy)
    ctx.beginPath()
    ctx.ellipse(px_t, py_t, 3.0*lw+pet(lw), lw, a, 0, 2* Math.PI)
    if (Math.random() > 0.995)
      a += pet (1)/2
    ctx.closePath()
    ctx.fill()
  }
}

function script (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let fs = 7 + document.getElementById("featuresize").value/2
  let D = 1 + document.getElementById("number").value/4000
  D/= 4
  let bump = fs/2.4
  let color = randomPick(getCurrentPalette())
  let alt = document.getElementById("grungy").checked
  let W = canvas.width, H = canvas.height
  let pad = 4 + Math.floor(Math.random() * 2)
  let linespace = 18 + Math.floor(pet(8))
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = color
  ctx.fillStyle = color

  ctx.lineJoin = "round"
  ctx.lineWidth = Math.floor(1 + fs/12)
  ctx.imageSmoothingQuality = "high"
  let i = 0, x = LASTCLICK[0], y = LASTCLICK[1]
  let cx1, cy1, cx2, cy2
  let maxX = x+1*fs + Math.random() * 8 * fs
  let x2 = 0, y2 = 0
  ctx.beginPath()
  while (x < maxX) {
    cx1 = x+fs*2, cy1 = y -2*fs
    cx2 = x-fs*2, cy2 = y +2*fs
    bump = 3*fs/4 + pet(fs*D/4)
    if (Math.random() < 0.07) {
      cy2 += 2*fs
    } else
    if (Math.random() < 0.23 && alt) {
      cy1 -= 2*fs
    }
    bez_pts (x,y,cx1+pet(D*fs),cy1+pet(D*fs),cx2+pet(D*fs),cy2+pet(D*fs), x+bump, y,ctx)
    // occasional dot or cross
    if (Math.random() < 0.08) {
      x2 = x + pet(fs/3)
      y2 = y - fs*1.3+pet(fs)
      cx1 = x2 + fs/4
      cy1 = y2 - fs/5 +pet(fs/4)
      cx2 = x2 + fs/4 + pet(fs)
      cy2 = y2 - fs/5 + pet(fs/4)
      bez_pts (x2,y2,cx1,cy1,cx2,cy2, x2+pet(fs/2), y2 += pet(fs/2),ctx)
    }
    if (alt)
      ctx.lineWidth = Math.floor(1 + fs/20) + pet(1)
    x += bump
    if (x > W) {
      LASTCLICK[1] += fs*2.2
      LASTCLICK[0] = 0
      return
    }
  }
  LASTCLICK[0] = x + bump
}

function musicpaper () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let alt = document.getElementById("grungy").checked
  let W = canvas.width, H = canvas.height
  let pad = 4 + Math.floor(Math.random() * 2)
  let linespace = 18 + Math.floor(pet(8))
  ctx.fillStyle = "#ffffff"//color
  let colors = ["#ed6060", "#6060ba", "#6060ed", "#ed6060", "#000000"]
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = randomPick(colors)
  ctx.lineWidth = 1
  let i = 0, x = pad+2, y = pad+94
  
  while (y < canvas.height-pad) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(canvas.width-pad-2, y)
    ctx.closePath()
    ctx.stroke()
    y += linespace
    i++
    if (i % 5 === 0) {
      if (alt)
        lyrics(y - linespace*3, linespace)
      y += linespace*4
     // ctx.fillStyle = color
    }
  }
  //randomPick(getCurrentPalette()) // was paintcolor = color
}

function lyrics (y, d) {
  d /= 2
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  //let d = 3 + document.getElementById("featuresize").value/10
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alt = document.getElementById("grungy").checked
  let W = canvas.width, H = canvas.height
  let pad = 4 + Math.floor(Math.random() * 2)
  let linespace = 18 + Math.floor(pet(8))
  ctx.fillStyle = color
  ctx.imageSmoothingQuality = "high"
  let functionwords = ["in", "on", "so", "which", "to", "and", "or", "not", "is", "for","some", "any", "most", "over", "under", "into", "she", "he", "his", "her", "it", "they","this", "the", "a", "if", "of", "by", "you","i", "they", "that", "no", "but", "there", "and", "cound", "should", "may", "how", "where", "what", "when", "why", "who"]
  let i = 0, x = pad+2+d*4
  let max = y + d*7, min = y - d*6
  y += d*2 * randomPick([0,1,-1,-2,2])
  let letters = []
  let glom = []
  let FW = true
  for (;i < 5; i++) {
    letters = randomWord().split("")
    letters.push(" ")
    letters.push(" ")
    let j = 0
    for (; j < letters.length; j++)
      glom.push(letters[j])
      
    letters = []
    if (i < 4 && Math.random() > 0.1) {
      letters = randomPick(functionwords).split("")
      letters.push(" ")
      letters.push(" ")
    }
    j = 0
    for (; j < letters.length; j++)
      glom.push(letters[j])
  }
  i = 0
  let face = "AmericanTypewriter-Bold"
  ctx.font = "800 "+(d*1.5)+"pt " + face
  ctx.beginPath()
  y += d/2
  while (x < W-d*2 && i < glom.length) {
    ctx.fillText(glom[i], x,y)
    if (Math.random() > 0.95) {
      let a = ctx.globalAlpha
      ctx.globalAlpha = 0.3
      ctx.fillText(glom[i], x+pet(9), y+pet(7))
      ctx.fillText(glom[i], x+pet(7), y+pet(9))
      ctx.globalAlpha = a
    }
    x += d*1.4
    y += (Math.random() > 0.5)? d: -d;
    if (y > max)
      y -= d*2
    if (y < min)
      y += d*2
    i++
  }
}

function music (y, d) {
  d /= 2
  
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  //let d = 3 + document.getElementById("featuresize").value/10
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alt = document.getElementById("grungy").checked
  let W = canvas.width, H = canvas.height
  let pad = 4 + Math.floor(Math.random() * 2)
  let linespace = 18 + Math.floor(pet(8))
  ctx.fillStyle = color
  ctx.imageSmoothingQuality = "high"
  let i = 1, x = pad+2+d*2//, y = LASTCLICK[1], rot = 1
  let y0 = y, max = y + d*7, min = y - d*6
  y += d*2 * randomPick([0,1,-1,-2,2])
  ctx.beginPath()
  while (x < W-d*2) {
    ctx.beginPath()
    ctx.arc(x, y, d*0.7, 0, Math.PI*2)
    ctx.closePath()
    ctx.fill()
    x += d*2
    //if (Math.random() > 0.1)
    y += (Math.random() > 0.5)? d*2: -d*2;
    if (y > max)
      y -= d*4
    if (y < min)
      y += d*4
    if (i % 5 === 0)
      x += d*3
    i++
  }
  //randomPick(getCurrentPalette()) // was paintcolor = color
}



function linedPad () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alt = document.getElementById("grungy").checked
  let W = canvas.width, H = canvas.height
  let pad = 4 + Math.floor(Math.random() * 2)
  let linespace = 34 + Math.floor(pet(16))
  ctx.fillStyle = "#ffffff"//color
  let colors = ["#ed6060", "#6060ba", "#6060ed", "#ed6060", "#000000"]
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = "#6060ed"
  ctx.lineWidth = 1
  let i = 0, x = pad+2, y = pad+94
  if (alt)
   while (y < canvas.height-pad) {
    if (i % 5 !== 4)
      ctx.strokeStyle = colors[i%5]
    else
      ctx.strokeStyle = "#edaaaa"
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(canvas.width-pad-2, y)
    ctx.closePath()
    if (i % 5 !== 4)
     ctx.stroke()
    y += linespace
    i++
  }
  else
    while (y < canvas.height-pad) {
      ctx.beginPath()
      ctx.moveTo(x, y)
      ctx.lineTo(canvas.width-pad-2, y)
      ctx.closePath()
      ctx.stroke()
      y += linespace
    }
  ctx.strokeStyle = "#ee6060"
  i = 0, y = pad+2, x = 96
  for (; i < 2; i++) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(x, canvas.height-pad)
    ctx.closePath()
    ctx.stroke()
    x += 5
  }
  randomPick(getCurrentPalette()) // was paintcolor = color
}

function postcard () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alt = document.getElementById("grungy").checked
  let W = canvas.width, H = canvas.height
  let pad = 24, hpad = 7 * pad
  let linespace = 34 + Math.floor(pet(16))
  let colors = ["#6060ba", "#6060ed", "#000000", "#2020cc"]
  ctx.strokeStyle = randomPick(colors)

  ctx.globalAlpha = document.getElementById("opacity")/100
  ctx.shadowColor = "#403030"
  ctx.shadowBlur = 9 + Math.random() * 5
  ctx.shadowOffsetY = 2 + Math.random() * 3
  ctx.shadowOffsetX = -2 + Math.random() * 2
  ctx.lineWidth = 4 + Math.floor(Math.random()*4)

  ctx.fillStyle = color
  let x = pad, y = hpad
  ctx.moveTo(x,y)
  
  ragged(ctx,W-pad,hpad,x,y)
  x = W-pad
  y = hpad
  ragged(ctx,W-pad,H-hpad,x,y)
  y = H-hpad
  ragged(ctx,pad,H-hpad,x,y)
  x = pad
  y = W-hpad
  ragged(ctx,pad,hpad,x,y)
  ctx.closePath()
  ctx.fill()
  ctx.shadowBlur = 0
  ctx.shadowOffsetY = 0
  ctx.shadowOffsetX = 0
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.lineWidth = 1
  let i = 0
  x = pad+2, y = pad+94
  ctx.lineWidth = 4 + Math.floor(Math.random()*4)
  y = hpad*1.8, x = W/2
  ctx.beginPath()
  ctx.moveTo(x, y)
  ctx.lineTo(x, canvas.height-hpad*1.3)
  ctx.closePath()
  ctx.stroke()
  
  ctx.strokeRect(W-pad-130, hpad+20,110,140) // stamp
  x = W/2 + pad*4, y = H/2 - pad*1.3
  i = 0
  for (; i < 4; i++) {
    ctx.beginPath()
    ctx.moveTo(x,y)
    ctx.lineTo(x + 340, y)
    ctx.stroke()
    y += 60
  }
  let text = "P O S T C A R D"
  let face = "Courier"
  ctx.font = "800 "+(36)+"pt " + face
  let width = ctx.measureText(text).width
  ctx.fillStyle = ctx.strokeStyle
  ctx.fillText(text,W/2-width/2,hpad+92)
  
  let CENT = W-pad-130 + 55
  y = hpad+50
  text = "Place"
  ctx.font = "100 "+(18)+"pt " + face
  width = ctx.measureText(text).width
  ctx.fillText(text,CENT-width/2,y)
  
  text = "Stamp"
  ctx.font = "100 "+(18)+"pt " + face
  width = ctx.measureText(text).width
  ctx.fillText(text,CENT-width/2,y+140/3)
  
  text = "Here"
  ctx.font = "100 "+(18)+"pt " + face
  width = ctx.measureText(text).width
  ctx.fillText(text,CENT-width/2,y+2*140/3)
  ctx.shadowBlur = 0
  ctx.shadowOffsetY = 0
  ctx.shadowOffsetX = 0
  randomPick(getCurrentPalette()) // was paintcolor = color
}

function sold () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  let x = W/2 + pet(W/4), y = H/2 + pet(H/4)
  ctx.shadowColor = "#aa9090"
  ctx.shadowBlur = 1 + Math.random() * 2
  ctx.shadowOffsetY = 1 + Math.random() * 2
  ctx.shadowOffsetX = 1 + Math.random() * 2

  ctx.fillStyle = randomPick(["#ee2000","#ff0000", "#ee0020"])
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.arc(x,y, W/13 + pet(11), 0, Math.PI*2)
  ctx.closePath()
  ctx.fill()
}

function oiloncanvas () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alt = document.getElementById("grungy").checked
  let W = canvas.width, H = canvas.height
  let hpad = 20 + Math.random()*6, pad = 7 * hpad + pet(33)
  let linespace = 34 + Math.floor(pet(16))
  ctx.globalAlpha = document.getElementById("opacity")/100
  watercolorPaperD(pad, hpad, W-2*pad, H-2*hpad)
  copyToOff()
  ctx.fillStyle = randomColorVLight()
  ctx.fillRect(0,0,W,H)
  spotlight()
  ctx.fillColor = "#ffffff"
  ctx.shadowColor = "#707070"
  ctx.shadowBlur = 4 + Math.random() * 5
  ctx.shadowOffsetY = 2 + Math.random() * 3
  ctx.shadowOffsetX = 4 + Math.random() * 3
  ctx.fillStyle = "#ffffff"
  let x = pad, y = hpad+100
  pasteFromOff()
  //ctx.fillRect(pad, hpad, W-2*pad, H-2*hpad)
  ctx.shadowBlur = 0
  ctx.shadowOffsetY = 0
  ctx.shadowOffsetX = 0
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let i = 0
  let fs = W/40 + pet(7)
  ctx.fillStyle = "#000000"
  let text = "Unknown artist"
  let face = randomPick(["Helvetica", "Arial", "Courier", "Georgia", "Futura"])
  ctx.font = "800 "+(fs)+"pt " + face
  let w = ctx.measureText(text+" ").width
  x = 1.4*pad +pet(13), y = hpad * 6 + pet(13)

  ctx.fillText(text, x, y)
  fs = W/50 + pet(7)
  ctx.font = "100 "+(fs)+"pt " + face
 // ctx.fillText("(b 19"+Math.floor(50+Math.random()*49)+")", x+w, y)
  text = randomWord(Math.random() > 0.5)
  if (Math.random() > 0.67)
      text += " "+randomWord(Math.random() > 0.5)
  text = text.charAt(0).toUpperCase() + text.slice(1);

  ctx.font = "800 italic "+(fs)+"pt " + face
  w = ctx.measureText(text+" ").width
  y += fs * 2
  ctx.fillText(text, x, y) // itallic
  fs *= 0.9
  ctx.font = "100 "+(fs)+"pt " + face
  ctx.fillText("(20"+(10 +Math.floor(Math.random() * 13))+")", x+w, y)
  y += fs * 2
  let media = ["Oil on canvas", "Mixed media", "Watercolor", "Gouache", "Acrylic on canvas", "Ink", "Collage", "Encaustic", "Digital"]
  text = randomPick(media)
  
  if (Math.random() > 0.8)
    text += ", " + randomPick(media.filter(x => x !== text))
  ctx.fillText(text, x, y)

  y += fs * 2
  ctx.fillText(Math.floor(20+Math.random() * 100) + " X " + Math.floor(20+Math.random() * 100) + " " +randomPick(["cm", "inches"]), x, y)
  
  x = canvas.width - pad*2 + pet(90), y = H/2+pet(90)
  if (Math.random() > 0.5) {
    
    ctx.shadowColor = "#aa9090"
    ctx.shadowBlur = 1 + Math.random() * 2
    ctx.shadowOffsetY = 1 + Math.random() * 2
    ctx.shadowOffsetX = 1 + Math.random() * 2
  
    ctx.fillStyle = randomPick(["#ee2000","#ff0000", "#ee0020"])
    ctx.beginPath()
    ctx.moveTo(x,y)
    ctx.arc(x,y, W/19 + pet(11), 0, Math.PI*2)
    ctx.closePath()
    ctx.fill()
  }
  ctx.shadowBlur = 0
  ctx.shadowOffsetY = 0
  ctx.shadowOffsetX = 0
}

function randomName () {
  let name = ""
  let v = ["a", "e", "i", "o", "u"]
  
  //"t", "n", "s", "h",
  
  let c = ["r", "r", "r", "r", "t", "n", "s", "h","t", "n", "s", "h","t", "n", "s", "h","t", "n", "s", "h", "s", "l", "m", "b", "d", "c", "f", "g", "h", "j", "k", "l", "m", "n", "p", "q", "r", "t", "s", "v", "w", "x", "y", "z"]
  let len = 1 + Math.floor(Math.random() * 5)
  let i = 0
  if (Math.random()> 0.7)
    name += randomPick(v)
    
  for (; i < len; i++)
    name += randomPick(c) + randomPick(v)
    
  if (Math.random()> 0.5)
    name += randomPick(c)
  return name.charAt(0).toUpperCase() + name.slice(1)
}

function indexcard () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alt = document.getElementById("grungy").checked
  let W = canvas.width, H = canvas.height
  let pad = 24, hpad = 7 * pad
  let linespace = 34 + Math.floor(pet(16))
  ctx.globalAlpha = document.getElementById("opacity")/100
  ctx.shadowColor = "#403030"
  ctx.shadowBlur = 9 + Math.random() * 5
  ctx.shadowOffsetY = 2 + Math.random() * 3
  ctx.shadowOffsetX = -2 + Math.random() * 2
  ctx.fillStyle = color
  let x = pad, y = hpad+100
 
  ctx.fillRect(pad, hpad, W-2*pad, H-2*hpad)
  ctx.shadowBlur = 0
  ctx.shadowOffsetY = 0
  ctx.shadowOffsetX = 0
  let colors = ["#6060ba", "#6060ed", "#000000", "#2020cc"]
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle =  "#ff2020"
  ctx.lineWidth = 2
  let i = 0
  while (y < H-hpad) {
    ctx.beginPath()
    ctx.moveTo(pad+2, y)
    ctx.lineTo(W-pad-2, y)
    ctx.stroke()
    y += 36
    ctx.strokeStyle =  "#2020cc"
  }
  randomPick(getCurrentPalette()) // was paintcolor = color
}

function photoBook () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  const H = canvas.height, W = canvas.width
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alpha = document.getElementById("opacity").value
  let mode = ctx.globalCompositeOperation
  let small = true, half = true
  let pad = 10//Math.floor(H * 0.01)
  ctx.globalAlpha = alpha
  ctx.fillStyle = color
  ctx.fillRect(0, 0, W, H)
  ctx.globalAlpha = 0.2
  ctx.fillStyle = randomGradientRect(canvas, "#ffffff", W/5-(pad*8), H, pad*6, H)
  ctx.fillRect(0, 0, W/5-(pad*6), H)

  ctx.fillStyle = randomGradientRect(canvas, "#000000", W/5, H, W/3, H)
  ctx.fillRect(W/5-(pad*6), 0, W, H)

  ctx.globalAlpha = 1.0
  ctx.fillStyle = "#fefeed"
  ctx.globalCompositeOperation = "destination-out"
  ctx.fillRect(W/5, pad*6, 3*W/4-pad, H-(pad*12))

  ctx.fillRect(0, pad*6, (pad*9), H-(pad*12))
  ctx.globalCompositeOperation = mode
  document.getElementById("opacity").value = alpha
}

function perforations () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  const H = canvas.height, W = canvas.width
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alpha = document.getElementById("opacity").value
  let mode = ctx.globalCompositeOperation
  let small = true, half = true
  let pad = 0//40
  ctx.fillStyle = color//"#101010"
  ctx.globalCompositeOperation = "source-over"
 // ctx.clearRect(0, 0, H, H)
 // ctx.fillRect(pad, pad, W-pad*2, H-pad*2)
  ctx.fillStyle = "#101010"
  ctx.strokeStyle = "#867033"
  ctx.lineWidth = 5
  ctx.lineCap = "round"
  ctx.lineJoin = "round"
  ctx.globalCompositeOperation = "source-over"
  let x = -8, y = pad + 20, i = 0
  let r = 56
  let sa = Math.PI * 1.35, ea = Math.PI * 1.78
  let sa2 = Math.PI * 0.56, ea2 = Math.PI * 0.81
  let sa3 = Math.PI * 0.36, ea3 = sa2
  let SQUARE = document.getElementById("grungy").checked
  let RIPPED = Math.random() > 0.3
  let yoff = 0
  let a = 1//randomPick([0,1,2,3,4])
  if (SQUARE)
    y -= 12
  let ct = 0
  while (y < H - 30) {
    ct++
    ctx.lineWidth = 5
    
    ctx.strokeStyle = "#555555"
    ctx.globalCompositeOperation = "darken"
    ctx.globalAlpha = 0.5
    
    ctx.globalCompositeOperation = "source-over"
    ctx.strokeStyle = "#867033"
    ctx.globalAlpha = 1.0
    ctx.globalCompositeOperation = "destination-out"

    if (SQUARE) {
      ctx.fillRect(x+38,y+27, 24, 24) // hole
    } else {
      ctx.beginPath()
      ctx.arc(x+50, y+27, 14, 0, Math.PI * 2)
      ctx.closePath()
      ctx.fill()
    }/*
    if (RIPPED) {
      ctx.globalAlpha = 1.0
      let big = 0
     // if (Math.random() > 0.97)
      //  big += 58
      //y += a
      ctx.beginPath()
      ctx.moveTo(0, y+4+pet(19)+yoff)
      ctx.lineTo(x+50, y+24+pet(9)+yoff)
      ctx.lineTo(x+50, y+30+pet(7)+yoff+big)
      ctx.lineTo(0, y+30 +pet(7)+yoff+big)
      ctx.closePath()
      ctx.fill();
    }*/
    y += 62
  }
  ctx.globalCompositeOperation = mode
  document.getElementById("opacity").value = alpha
}

function sketchpad () {
  if (document.getElementById("grungy").checked) {
    sketchpage ()
    return
  }
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  const H = canvas.height, W = canvas.width
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alpha = document.getElementById("opacity").value/100//
  let mode = ctx.globalCompositeOperation
  let small = true, half = true
  let pad = 40//Math.floor(H * 0.01)
 
  ctx.globalCompositeOperation = "source-over"
  ctx.globalAlpha = 1.0

  ctx.fillStyle = "#909090"
  ctx.fillRect(pad-10+pet(8), pad+10+pet(8), W/2-pad-14, H-pad*3)
  ctx.fillStyle = "#cccccc"
  ctx.fillRect(pad-8, pad+8, W/2-pad-14, H-pad*3)
  ctx.fillStyle = "#dddddd"
  ctx.fillRect(pad-6, pad+6, W/2-pad-14, H-pad*3)
  ctx.fillStyle = "#ffffff"
  ctx.fillRect(pad-4+pet, pad+4, W/2-pad-14, H-pad*3)

  ctx.fillStyle = "#909090"
  ctx.fillRect(W/2-6, pad*1.5+6, W/2-pad, H-pad*3)
  ctx.fillStyle = "#ffffff"
  ctx.fillRect(W/2-4, pad*1.5+4, W/2-pad, H-pad*3)

  ctx.fillStyle = color
  ctx.globalAlpha = 0.5
  ctx.shadowColor = "#403030"
  ctx.shadowBlur = 15 + Math.random() * 5
  ctx.shadowOffsetY = 12 + Math.random() * 3
  ctx.shadowOffsetX = -12 + Math.random() * 2
  
  ctx.fillRect(pad, pad, W/2-pad-14, H-pad*3)
  ctx.fillRect(W/2, pad*1.5, W/2-pad, H-pad*3)
  
  ctx.clearRect(pad, pad, W/2-pad-14, H-pad*3)
  ctx.clearRect(W/2, pad*1.5, W/2-pad, H-pad*3)
  ctx.globalAlpha = alpha

  ctx.shadowBlur = 0
  ctx.shadowOffsetY = 0
  ctx.shadowOffsetX = 0
  ctx.fillStyle = "#101010"
  ctx.strokeStyle = "#867033"
  ctx.lineWidth = 5
  ctx.lineCap = "round"
  ctx.lineJoin = "round"
  ctx.globalCompositeOperation = "source-over"
  let x = W/2 -60, y = pad*2, i = 0
  let r = 56

  let sa = Math.PI * 1.35, ea = Math.PI * 1.78
  let sa2 = Math.PI * 0.56, ea2 = Math.PI * 0.81
  let sa3 = Math.PI * 0.36, ea3 = sa2
  let SQUARE = Math.random() > 0.5
  while (y < H - 80) {
    ctx.lineWidth = 5

    ctx.strokeStyle = "#555555"
    ctx.globalCompositeOperation = "darken"
    ctx.globalAlpha = 0.5
    //shadow strokes
    // upper strokes
    ctx.beginPath()
    ctx.arc(x+60, y-20, r-2, sa2, ea2)
    ctx.stroke()
      
    ctx.beginPath()
    ctx.arc(x+60, y-28, r-2, sa3, ea3)
    ctx.stroke()
    // lower strokes
    ctx.beginPath()
    ctx.arc(x+60, y-6, r-2, sa2, ea2)
    ctx.stroke()
      
    ctx.beginPath()
    ctx.arc(x+60, y-12, r-2, sa3, ea3)
    ctx.stroke()
    
    ctx.globalCompositeOperation = "source-over"
    
    ctx.strokeStyle = "#867033"
    ctx.globalAlpha = 1.0
    if (SQUARE) {
      ctx.fillRect(x,y,24,24)
      ctx.fillRect(x+80,y+pad-24,24,24)
    } else {
      ctx.beginPath()
      ctx.arc(x+14, y+12, 14, 0, Math.PI * 2)
      ctx.closePath()
      ctx.fill()
      
      ctx.beginPath()
      ctx.arc(x+90, y+27, 14, 0, Math.PI * 2)
      ctx.closePath()
      ctx.fill()
    }
   
    //rings
    ctx.beginPath()
    ctx.arc(x+46, y+54, r, sa, ea)
    ctx.stroke()
    ctx.beginPath()
    ctx.arc(x+43, y+68-2, r-2, sa, ea)
    ctx.stroke()
    
    // upper glint
    ctx.strokeStyle = "#ffffff"
    ctx.lineWidth = 3

    ctx.beginPath()
    ctx.arc(x+46, y+53, r,  sa+0.7, sa+0.75)
    ctx.stroke()
    //lower glint
    ctx.beginPath()
    ctx.arc(x+43, y+68-3, r-2, sa+0.75, sa+0.8)
    ctx.stroke()

    y += 58
  }
  ctx.globalCompositeOperation = mode
 // document.getElementById("opacity").value = alpha
}

function sketchpage () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  const H = canvas.height, W = canvas.width
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alpha = document.getElementById("opacity").value
  let mode = ctx.globalCompositeOperation
  let small = true, half = true
  let pad = 40//Math.floor(H * 0.01)
  ctx.fillStyle = color//"#101010"
  ctx.globalCompositeOperation = "source-over"
  ctx.clearRect(0, 0, H, H)

  ctx.shadowColor = "#403030"
  ctx.shadowBlur = 10 + Math.random() * 10
  ctx.shadowOffsetY = 4 + Math.random() * 5
  ctx.shadowOffsetX = 4 + Math.random() * 5
  
  ctx.fillRect(pad, pad, W-pad*2, H-pad*2)
  ctx.shadowBlur = 0
  ctx.shadowOffsetY = 0
  ctx.shadowOffsetX = 0
  
  ctx.fillStyle = "#101010"
  ctx.strokeStyle = "#867033"
  ctx.lineWidth = 5
  ctx.lineCap = "round"
  ctx.lineJoin = "round"
  ctx.globalCompositeOperation = "source-over"
  let x = -8, y = pad + 20, i = 0
  let r = 56

  let sa = Math.PI * 1.35, ea = Math.PI * 1.78
  let sa2 = Math.PI * 0.56, ea2 = Math.PI * 0.81
  let sa3 = Math.PI * 0.36, ea3 = sa2
  let SQUARE = Math.random() > 0.5
  let RIPPED = Math.random() > 0.3
  let yoff = 0
  let a = 1//randomPick([0,1,2,3,4])
  if (SQUARE)
    y -= 12
  let ct = 0
  while (y < H - 76) {
    ct++
    ctx.lineWidth = 5
    
    ctx.strokeStyle = "#555555"
    ctx.globalCompositeOperation = "darken"
    ctx.globalAlpha = 0.5
    
    ctx.globalCompositeOperation = "source-over"
    ctx.strokeStyle = "#867033"
    ctx.globalAlpha = 1.0
    ctx.globalCompositeOperation = "destination-out"

    if (SQUARE) {
      ctx.fillRect(x+78,y+27, 24, 24) // hole
    } else {
      ctx.beginPath()
      ctx.arc(x+90, y+27, 14, 0, Math.PI * 2)
      ctx.closePath()
      ctx.fill()
    }
    if (RIPPED) {
      ctx.globalAlpha = 1.0
      let big = 0
      if (Math.random() > 0.97)
        big += 58
      //y += a
      ctx.beginPath()
      ctx.moveTo(0, y+4+pet(19)+yoff)
      ctx.lineTo(x+80, y+24+pet(9)+yoff)
      ctx.lineTo(x+80, y+30+pet(7)+yoff+big)
      ctx.lineTo(0, y+30 +pet(7)+yoff+big)
      ctx.closePath()
      ctx.fill();
    }
    y += 60
  }
  ctx.globalCompositeOperation = mode
  document.getElementById("opacity").value = alpha
}


function singlePage () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  const H = canvas.height, W = canvas.width
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alpha = document.getElementById("opacity").value
  ctx.globalAlpha = alpha/100
  let mode = ctx.globalCompositeOperation
  let small = true, half = true
  let pad = 40
  ctx.fillStyle = color//"#101010"
  ctx.strokeStyle = 'black'//"#101010"
  ctx.globalCompositeOperation = "source-over"
  let htop = [W-pad*1.1, pad*1.1]
  let hbot = [W-pad*1.1, H-pad*1.1]
  let shadows = ["#101010", "#202020", "#000000"]
  ctx.shadowBlur = 5 + Math.random() * 4
  ctx.shadowOffsetY = 1 + Math.random() * 1
  ctx.shadowOffsetX = -1 + Math.random()
  let i = 0, x = pad, y = pad
  let x0 = x, y0 = y
  let pH = H - pad*2
  ctx.lineWidth = 5
  ctx.beginPath()
  ctx.moveTo(x,y)
  x = pad, y = pad
  x0 = W - pad, y0 = pad
  
  ragged(ctx,x0,y0,x,y)
  x = x0
  y = y0

  x0 = W-pad
  y0 = H-pad
  ragged(ctx,x0,y0,x,y)
  x = x0
  y = y0

  x0 = pad
  y0 = H-pad
  ragged(ctx,x0,y0,x,y)
  x = x0
  y = y0

  x0 = pad
  y0 = pad
  ragged(ctx,x0,y0,x,y)
  ctx.lineTo(x0,y0)
  ctx.closePath()
  ctx.fill()
}

function ragged (ctx,endX,endY,x,y, d) {
  if (!d)
    d = 50
  let inc = 3 + Math.floor(document.getElementById("featuresize").value/d)
  let p = 1 + document.getElementById("number").value/4000
  let xdiff = x - endX, ydiff = y - endY
  let D = distance(x,y,endX,endY)
  let Dy = (endY-y)
  let Dx = (endX-x)
  let xinc = Dx/(D+0.000001)*inc
  let yinc = Dy/(D+0.000001)*inc
  let xsteps = (x - endX)/(xinc + 0.000001)
  let ysteps = (y - endY)/(yinc + 0.000001)
  let xf = xdiff/(xsteps + 0.000001)
  let yf = ydiff/(ysteps + 0.000001)

  while (distance(endX,endY,x,y) > inc) {
    // add to x and y to get closer to endX,endY
    x += xinc
    y += yinc
    x += xf
    y += yf
    ctx.lineTo(x+pet(p), y+pet(p))
  }
}

function raggedX (ctx,endX,endY,x,y) {
  let inc = 3 + Math.floor(document.getElementById("featuresize").value/10)
  let p = 1 + document.getElementById("number").value/1000
  let xdiff = x - endX, ydiff = y - endY
  let D = distance(x,y,endX,endY)
  let Dy = (endY-y)
  let Dx = (endX-x)
  let xinc = Dx/(D+0.000001)*inc
  let yinc = Dy/(D+0.000001)*inc
  let xsteps = (x - endX)/(xinc + 0.000001)
  let ysteps = (y - endY)/(yinc + 0.000001)
  let xf = xdiff/(xsteps + 0.000001)
  let yf = ydiff/(ysteps + 0.000001)

  while (distance(endX,endY,x,y) > inc*2) {
    // add to x and y to get closer to endX,endY
    x += xinc
    y += yinc
    x += xf
    y += yf
    ctx.lineTo(x+pet(p), y+pet(p))
  }
}

function floppyPage () { // half
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  const H = canvas.height, W = canvas.width
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alpha = document.getElementById("opacity").value
  ctx.globalAlpha = alpha/100
  let mode = ctx.globalCompositeOperation
  let small = true, half = true
  let pad = 40
  ctx.fillStyle = color//"#101010"
  ctx.globalCompositeOperation = "source-over"
  let htop = [W-pad*1.1, pad*1.1]
  let hbot = [W-pad*1.1, H-pad*1.1]
  let shadows = ["#101010", "#202020", "#000000"]
  ctx.shadowBlur = 5 + Math.random() * 4
  ctx.shadowOffsetY = 1 + Math.random() * 1
  ctx.shadowOffsetX = -1 + Math.random()
  let i = 0, x = pad+pet(20), y = pad+pet(30)
  let x0 = x, y0 = y
  let pH = H - pad*2
  let cpx = W*0.5, cpy = pad+pet(42)
  let numpages = 3 +Math.floor(Math.random()*5)
  let x_inc = 7 + Math.floor(Math.random()*8)
  for (; i < numpages; i++) {
    ctx.shadowColor = randomPick(shadows)
    ctx.beginPath()
    y = y+pet(20)
    ctx.moveTo(x,y)
    ctx.quadraticCurveTo(cpx, cpy, htop[0], htop[1])
    ctx.lineTo(hbot[0],hbot[1])
    x += pet(30)
    ctx.quadraticCurveTo(cpx, H-cpy, x, y+pH)
    
    // draw fagged line between botton and top
    ragged(ctx,x0,y0,x,y+pH)
    ctx.closePath()
    ctx.fill()
    x += x_inc + pet(6)
    x0 = x
    cpy = pad+pet(32)
    ctx.shadowBlur = 4
  }
  // top page: fill to get drop shadow
  ctx.fillStyle = "#ddddcc"
  ctx.beginPath()
  y = y+pet(20)
  y0 = y
  let ox = x
  ctx.moveTo(x,y)
  ctx.quadraticCurveTo(cpx, cpy, W-pad,pad)
  ctx.lineTo(W-pad,H-pad)
  x += pet(20)
  ctx.quadraticCurveTo(cpx, H-cpy, x, y+pH)
  
  ragged(ctx,ox,y0,x,y+pH)

  ctx.closePath()
  ctx.fill()

  ctx.save()
  ctx.beginPath()
  ctx.moveTo(ox,y)
  ctx.quadraticCurveTo(cpx, cpy, W-pad,pad)
  ctx.lineTo(W-pad,H-pad)
  ctx.quadraticCurveTo(cpx, H-cpy, x, y+pH)
  ragged(ctx,ox,y0,x,y+pH)

  ctx.closePath()
  ctx.clip()
  ctx.clearRect(0,0,W,H)
  ctx.restore()
  ctx.shadowBlur = 0
  ctx.shadowOffsetY = 0
  ctx.shadowOffsetX = 0

  // tint sliver of right page
  let delta = Math.floor((Math.random()) * 13)
  ctx.fillStyle = color
  ctx.beginPath()
  ctx.moveTo(W-pad,pad)
  ctx.lineTo(W,pad-delta)
  ctx.lineTo(W,H-pad+delta)
  ctx.lineTo(W-pad, pad+pH)
  ctx.closePath()
  ctx.fill()
  ctx.fillStyle = randomGradientRect2(canvas, color, "#000000", W-pad*3, H/2, W, H/2)
  ctx.fill()
  ctx.globalCompositeOperation = mode
  document.getElementById("opacity").value = alpha
}

function spiralbound () { //
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  const H = canvas.height, W = canvas.width
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alpha = document.getElementById("opacity").value
  let mode = ctx.globalCompositeOperation
  let small = true, half = true
  let pad = 10//Math.floor(H * 0.01)
  ctx.lineCap = "round"
  ctx.lineJoin = "round"
  ctx.globalCompositeOperation = "source-over"
  
  let x = 46, y = 78, i = 0
  let r = 56
  ctx.fillStyle = color
  ctx.fillRect(0,0,W, 48)
  
  let sa = Math.PI * 1.1, ea = Math.PI * 1.3
  ctx.lineWidth = 11

  while (x < W - 30) {
    ctx.strokeStyle = "#555555"
    ctx.beginPath()
    ctx.arc(x+12, y-18, r-2, sa, ea+0.02)
    ctx.stroke()
    
    ctx.strokeStyle = "#404040"
    ctx.beginPath()
    ctx.arc(x+12, y-18, r-2, sa, sa+0.04)
    ctx.stroke()
    
    ctx.strokeStyle = "#707070"
    ctx.beginPath()
    ctx.arc(x+12, y-18, r-2, ea - 0.03, ea)
    ctx.stroke()
    x += 62
  }
  ctx.globalCompositeOperation = "destination-out"

  ctx.fillStyle = "#fefeee"
  ctx.fillRect(0,46,W,H)
  ctx.globalCompositeOperation = "source-over"

  x = 46
  while (x < W - 30) {
    ctx.globalAlpha = 1.0
    ctx.globalCompositeOperation = "source-over"
    ctx.fillStyle = "#202020"
    ctx.globalAlpha = 1.0
    ctx.beginPath()

    ctx.arc(x,y,20,0, 2* Math.PI)
    ctx.closePath()
    ctx.fill()
    //rings
    ctx.lineWidth =11
    ctx.strokeStyle = "#999999"
    ctx.beginPath()
    ctx.arc(x-50, y-18, r+2, Math.PI * 1.71, Math.PI/10+0.1)
    ctx.stroke()
    
    // gliny
    ctx.lineWidth = 10
    ctx.strokeStyle = "#fefefe"
    ctx.beginPath()
    ctx.arc(x-50, y-19, r+3, Math.PI * 1.8, Math.PI * 1.82)
    ctx.stroke()
    
    // glint
    ctx.strokeStyle = "#dcdcdc"
    ctx.beginPath()
    ctx.arc(x-50, y-19, r+3, Math.PI * 1.89, Math.PI * 1.895)
    ctx.stroke()
    
    // shadow
    ctx.strokeStyle = "#404040"
    ctx.beginPath()
    ctx.arc(x-50, y-19, r+2, Math.PI * 2.1, Math.PI * 2.15)
    ctx.stroke()
    
    // shadow of wire on paper
    ctx.globalAlpha = 0.2
    ctx.globalCompositeOperation = "destination-over"
    //ctx.strokeStyle = "#999999"
    ctx.beginPath()
    ctx.arc(x-68, y-13, r, Math.PI * 1.6, Math.PI/10-0.1)
    ctx.stroke()
    x += 62
  }
  ctx.globalCompositeOperation = "destination-over"
  ctx.globalAlpha = 1.0
  ctx.fillStyle = "#eefefe"
 // ctx.fillRect(0,0,W,H)
  
  ctx.strokeStyle = "#8888ff"
  ctx.lineWidth = 1
  ctx.globalCompositeOperation = "source-over"

  x = 2, y = 120
  while (y < H) {
    ctx.beginPath()
    ctx.moveTo(x,y)
    ctx.lineTo(W-2,y)
    ctx.closePath()
    ctx.stroke()
    y += 50
  }
  ctx.globalCompositeOperation = mode
  document.getElementById("opacity").value = alpha
}

function letterE () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  let colors = shuffle(getCurrentPalette())
  let x = 50, y = 50, len = 70
  ctx.strokeStyle = randomPick(colors)
  ctx.lineWidth = 7
  ctx.beginPath()
  ctx.moveTo(x+pet(5),y)
  ctx.lineTo(x+len/2, y+pet(5))
  ctx.closePath()
  ctx.stroke()
  y += len/2
  ctx.beginPath()
  ctx.moveTo(x+pet(5),y)
  ctx.lineTo(x+len/2.2, y+pet(5))
  ctx.closePath()
  ctx.stroke()
  y += len/2
  ctx.beginPath()
  ctx.moveTo(x+pet(5),y)
  ctx.lineTo(x+len/2, y+pet(5))
  ctx.closePath()
  ctx.stroke()
  y -= len
  ctx.beginPath()
  ctx.moveTo(x+pet(5),y)
  ctx.lineTo(x, y+pet(5)+len)
  ctx.closePath()
  ctx.stroke()
}

function piechart () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  let colors = shuffle(getCurrentPalette())
  let x = 50, y = 50, r = 12, i = 0
  ctx.fillStyle = randomPick(colors)
  ctx.globalAlpha = document.getElementById("opacity").value/100

  for (; i < 25; i++)
    dotsNear(ctx, Math.random() * W, Math.random() * H, 1 + Math.random() * 12)
}

function dotsNear(ctx,x,y,r) {
  let i = 0
  x += 12
  for (; i < 26; i++) {
    ctx.beginPath()
    ctx.arc(x,y,r,0,2*Math.PI)
    ctx.closePath()
    ctx.fill()
    x += pet(11)
    y += pet(9)
    r = 5 + pet(3)
  }
}


function dotsNear2(ctx,x,y,r) {
  let i = 0
  x += 4
  for (; i < 17; i++) {
    ctx.beginPath()
    ctx.arc(x,y,r,0,2*Math.PI)
    ctx.closePath()
    ctx.fill()
    x += pet(9)
    y += pet(9)
   // r = 2 + pet(1)
  }
}
function labyrinth () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  let colors = shuffle(getCurrentPalette())
  ctx.clearRect(0,0,W,H)
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.lineWidth = 2 + Math.floor(Math.random() * 40)
  ctx.lineCap = "round"
  ctx.lineJoin = "round"
  ctx.strokeStyle = randomPick(colors)
  let bump = randomPick([1.25, 1.5, 2, 1, 0.5])
  let pad = 40, r = W/2.5, offset = ctx.lineWidth * 1.7
  let x = W/2, y = H/2
  let a = Math.random() * 2 * Math.PI
  let start = a, end = a+bump*Math.PI
  let xl = 0, yl = 0, i = 0, ccw = false
  ctx.beginPath()
  while (r > 4) {
    r -= offset
    ccw = (Math.random() > 0.8)? true: false;
    if (r < 2*ctx.lineWidth)
      break;
    ctx.arc(x, y ,r, start, end, ccw)
    xl = r * Math.cos(end)+x;
    yl = r * Math.sin(end)+y;
    ctx.moveTo(xl, yl)
    xl = (r - offset) * Math.cos(end)+x;
    yl = (r - offset) * Math.sin(end)+y;
    ctx.lineTo(xl, yl)
    start = end
    end += bump*Math.PI
    i++
  }
  ctx.stroke()
}

function messagepad () { // while you were ouy
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  let cx = W/2, cy = W/2
  let colors = shuffle(getCurrentPalette())
  ctx.clearRect(0,0,W,H)
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.lineWidth = 5
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor//"#ffc0cb"
  //ctx.fillRect(0,0,W,H)
  ctx.strokeStyle = "#000000"
  let pad = 40
  ctx.strokeRect(pad-3,pad-3,W-pad*2,H-pad*2) // frame
  ctx.lineWidth = 2
  ctx.strokeRect(pad+6,pad+6,W-pad*2-16,H-pad*2-16) // frame
  ctx.lineWidth = 3
  let x = 0, y = 0
  //ctx.strokeRect(W-pad-290, pad, 279, 60) // urgent
  
  
  ctx.globalAlpha /= 2
  ctx.fillStyle = "#505050"
  ctx.fillRect(W-pad-218, pad*1.4-8, 204, 53)
  ctx.globalAlpha *= 2
  //ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
 // ctx.fillRect(W-pad-60, pad+16, 40, 40) // check box
  ctx.strokeRect(W-pad-60, pad+16, 40, 40) // check box
  let text = "Urgent"
  let face = "serif"
  ctx.font = "800 "+(34)+"pt " + face
  let w = ctx.measureText(text).width
  x = W-pad-270, y = pad * 2
  ctx.fillStyle = "#000000"
  ctx.fillText(text, x+60, y+8)
  y += 24
  ctx.beginPath()
  ctx.moveTo(pad+84, y)
  ctx.lineTo(W-pad*1.4, y)
  ctx.stroke()
  y+= 60
  ctx.beginPath()
  ctx.moveTo(pad+104, y)
  ctx.lineTo(cx+80, y)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(cx+160, y)
  ctx.lineTo(W-pad*1.4, y)
  ctx.stroke()
  y += 66
  ctx.globalAlpha /= 2
  ctx.fillStyle = "#505050"
  ctx.fillRect(pad + 12, y-48, W-pad*2.6-2, 80)
  ctx.globalAlpha *= 2
  y += 130
  ctx.strokeRect(cx + cx/4-5, y, W/3, H/5+24)
  let i = 0 // checkboxes
  for (; i < 5; i++) {
    ctx.strokeRect(cx + cx/4+8,y+(i * 46)+12, 30,30)
  }
  y = 100
  
  i = 0 // short lines
  y = cy - 3*60
  for (; i < 4; i++) {
    ctx.beginPath()
    ctx.moveTo(pad+14, y)
    ctx.lineTo(cx + cx/4-8-2, y)
    ctx.stroke()
    y+= 60
  }
  
  i = 0
  y = cy+60
  for (; i < 7; i++) {
    ctx.beginPath()
    ctx.moveTo(pad+14, y)
    ctx.lineTo(W-pad*1.4, y)
    ctx.stroke()
    y+= 60
  }
    ctx.fillStyle = "#000000"

  text = "A-9711"
  face = "sans-serif"
  ctx.font = (12)+"pt " + face
  x = pad+20, y = H-pad * 2 -10
  ctx.fillText(text, x, y)
  text = "T-3002"
  ctx.fillText(text, x, y+20)

}


function calendar () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  let colors = shuffle(getCurrentPalette())
  ctx.clearRect(0,0,W,H)
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.lineWidth = 3
  let firstofmonth = new Date()
  firstofmonth.setDate(1)
  let thedays = ["S", "M", "T", "W", "T", "F", "S"]
  let today = new Date()
  let day = firstofmonth.getDay()
  lastDayOfMonth = (new Date(today.getFullYear(), today.getMonth()+1, 0)).getDay()
  let pad = 40
  let len = Math.floor((W - 2 * pad)/9)
  let top = (H - 6*len)/2 - len/4
  let left = ((W - (7*len))-pad)/2
  let x = left, y = top
  let i = 0, row = 1, col = 1
  for (; i < 7; i++) {
    ctx.beginPath()
    ctx.moveTo(x+pet(5),y)
    ctx.lineTo(x+len, y+pet(5))
    ctx.lineTo(x+len+pet(5), y+len/2)
    ctx.lineTo(x, y+len/2+pet(5))
    ctx.closePath()
    ctx.strokeStyle = randomPick(colors)
    ctx.fillStyle = randomPick(colors)
    if (Math.random() > 0.2) {
      let face = "AmericanTypewriter-Bold"
      ctx.font = "800 "+(Math.floor(len/3.3))+"pt " + face
      let w = ctx.measureText(thedays[i]).width
      ctx.fillText(thedays[i], pet(5)+(x+len/2) - w/2, pet(5)+y +len/2.7)
      ctx.stroke()
    } else
      ctx.fill()
    x += len
  }
  x = left, y = top+ len/2
  i = 0, row = 1, col = 1
  for (; i < 42; i++) {
    ctx.beginPath()
    ctx.moveTo(x+pet(5),y)
    ctx.lineTo(x+len, y+pet(5))
    ctx.lineTo(x+len+pet(5), y+len)
    ctx.lineTo(x, y+len+pet(5))
    ctx.closePath()
    ctx.strokeStyle = randomPick(colors)
    ctx.fillStyle = randomPick(colors)
    if ((row === 1 && i < day) || (row === 6 && col > lastDayOfMonth+1))
      ;
    else {
      if (Math.random() > 0.3)
        ctx.fill()
      else
        ctx.stroke()
    }
    col++
    x += len
    if (col === 8) {
      x = left
      y += len
      row++
      col = 1
    }
  }
}


function periodictable () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  let colors = shuffle(getCurrentPalette())
  ctx.clearRect(0,0,W,H)
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.lineWidth = 3
  let pad = 40
  let len = (W - 2* pad)/18
  let top = (H - 10*len)/2
  let x = pad, y = top
  let i = 0, row = 1, col = 1
  for (; i < 180; i++) {
    ctx.beginPath()
    ctx.moveTo(x+pet(5),y)
    ctx.lineTo(x+len, y+pet(5))
    ctx.lineTo(x+len+pet(5), y+len)
    ctx.lineTo(x, y+len+pet(5))
    ctx.closePath()
    ctx.strokeStyle = randomPick(colors)
    ctx.fillStyle = randomPick(colors)
    if ((row === 8) || (row > 7 && (col < 4 || col > 16)) || ((row === 2 || row ===3) && (col > 2 && col < 13))|| (row === 1 && (col>1 && col<18)))
      ;
    else {
      if (Math.random() > 0.3)
        ctx.fill()
      else
        ctx.stroke()
    }
    col++
    x += len
    if (col === 19) {
      x = pad
      y += len
      row++
      col = 1
    }
  }
}

function datedue (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 2
  let monthIdx = Math.floor(Math.random() * 12)
  let months = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"]
  let colors = ["red", "blue", "darkblue", "green", "black", "indigo"], pre = " 0"
  let dates = [], i = 1
  let header1 = "DATE   DUE"
  let header2 = "Return book on or before the last date stamped."
  let header3 = "Failure to comply will result in a fine."
  for (; i < 29; i++) {
    if (i > 9)
      pre = " "
      dates.push(pre+i)
  }
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  let face = "arial"
  let text = randomPick(months)
  let color = randomPick(colors)
  let year = randomPick([1994, 1967, 2003, 1974, 1981, 1995])
  ctx.fillStyle = "#fefdcc"
  ctx.fillRect(0,0,canvas.width, canvas.height)
  ctx.fillStyle = "#707070"

  face = "arial"
  ctx.font = "100 "+(50)+"pt " + face
  let w = ctx.measureText(header1).width
  ctx.fillText(header1, canvas.width/2 - w/2, 60)

  face = "AmericanTypewriter-Bold"
  ctx.font = "800 "+(22)+"pt " + face
  w = ctx.measureText(header2).width
  ctx.fillText(header2, canvas.width/2 - w/2, 180)

  face = "AmericanTypewriter-Bold"
  ctx.font = "100 "+(18)+"pt " + face
  w = ctx.measureText(header3).width
  ctx.fillText(header3, canvas.width/2 - w/2, 210)
  ctx.fillStyle = randomPick(colors)

  let size = 28
  let x = 48, y = 261
  let maxdates = 11 + Math.random() * 50
  i = 0
  for (; i < maxdates; i++) {
    ctx.save()
    ctx.rotate((Math.random() - 0.5)/12)
    text = months[monthIdx]
    face = "arial"
    if (Math.random() > 0.8)
      monthIdx = (monthIdx + 1) % 12
    if (Math.random() > 0.7)
      ctx.fillStyle = randomPick(colors)
    ctx.globalAlpha = 0.6
    ctx.strokeStyle = "#505050"
    ctx.font = "500 "+size+"pt " + face
    w = ctx.measureText(text).width
    ctx.fillText(text, x, y)
    ctx.globalAlpha = 0.3
    ctx.fillText(text, x+pet(9), y+pet(7))
    ctx.fillText(text, x+pet(7), y+pet(9))
    ctx.globalAlpha = 0.2
    if (Math.random() > 0.95)
      dotsNear(ctx,x+w/2+pet(20),y-12+pet(11),7+pet(4))
    ctx.globalAlpha = 0.3

    text = randomPick(dates)
    face = "AmericanTypewriter"
    ctx.font = "500 "+(size+4)+"pt " + face
    ctx.globalAlpha = 0.6
    ctx.fillText(text, x+w+pet(9), y)
    ctx.globalAlpha = 0.4
    ctx.fillText(text, x+w, y+pet(9))
    ctx.fillText(text, x+w, y+pet(9))
    
    ctx.globalAlpha = 0.1
    if (Math.random() > 0.95)
      dotsNear(ctx,x+w+pet(20),y-12+pet(11),7+pet(4))
    ctx.globalAlpha = 0.3
    ctx.restore()
    y += 55
    if (Math.random() > 0.99) {
      year += 1
      monthIdx = 0
    }
    if (Math.random() > 0.9)
      y += 54
    if (y > canvas.height - 40) {
      y = 260
      x += 160
    }
  }
  ctx.globalAlpha = 0.6
  let eend = Math.floor((canvas.height-220)/64)
  eend = eend * 64 + 220
  i = 0, x = 50 , y = 220
  ctx.strokeStyle = "#707070"
  for (; i < 7; i++) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(x, eend)//canvas.height-20)
    ctx.closePath()
    ctx.stroke()
    x += canvas.width/7
  }
  
  i = 0, x = 50 , y = 220
  let end = 50 + 6*canvas.width/7
  ctx.strokeStyle = "#707070"
  ctx.lineWidth = 6
  while(y < canvas.height-10) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(end, y)
    ctx.closePath()
    ctx.stroke()
    y += 64
    ctx.lineWidth = 1
  }
}

function interdepartmental (canvas) { // ideal 8 X 10
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 2 //+ document.getElementById("featuresize").value/4
  let alpha = document.getElementById("opacity").value
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let BACK = document.getElementById("grungy").checked
  let small = true, half = true
  randomPick(getCurrentPalette()) // was paintcolor = "#eaae3a"
  ctx.fillStyle = "#eaae3a"
  ctx.fillRect(0,0,canvas.width, canvas.height)
  let face = "helvetica"
  let text = "INTER-DEPARTMENTAL MAIL"
  let size = 40
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  ctx.fillStyle = "#505050"
  ctx.strokeStyle = "#505050"
  ctx.font = size+"pt " + face
  let x = canvas.width/2, y = 78
  w = ctx.measureText(text).width
  if (!BACK) {
    ctx.strokeText(text, x-w/2, y)
  }
  if (BACK)
    y += 120
  
  y += 38
  size = 14
  text = "CROSS OUT ENTIRE LINE WHEN RECEIVED AND RE-USE UNTIL ALL LINES ARE FULL."
  ctx.font = "italic 900 "+size+"pt " + "serif"
  w = ctx.measureText(text).width
  ctx.fillText(text, x-w/2, y)
  
  y += 42
  size = 18
  face = "helvetica"
  text = "DATE            DELIVER TO            DEPARTMENT            SENT BY            DEPARTMENT"
  ctx.font = "900 "+size+"pt " + "serif"
  w = ctx.measureText(text).width
  ctx.fillText(text, x-w/2, y)
  
  ctx.lineWidth = 1
  let i = 0
  x = 30, y = 132
  if (BACK)
    y += 120
  ctx.shadowOffsetX = 0
  ctx.shadowOffsetY = 0
  while (y < canvas.height) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(canvas.width-30, y)
    ctx.closePath()
    ctx.stroke()
    y += 34
  }
  let lines = [172, 396, 636, 808]
  i = 0, x = 0, y = 132
  if (BACK)
    y += 120
  for (; i < lines.length; i++) {
    ctx.beginPath()
    ctx.moveTo(lines[i], y)
    ctx.lineTo(lines[i], canvas.height-20)
    ctx.closePath()
    ctx.stroke()
  }
  
  // six holes
  i = 0
  x = 280 // 800
  y = canvas.height / 3 + 53
  ctx.fillStyle = "#ffffff"
  ctx.shadowOffsetX = 0
  ctx.shadowOffsetY = 0
  for (; i < 3; i++) {
    ctx.beginPath()
    ctx.arc(x,y,16, 0, 2 * Math.PI)
    ctx.closePath()
    ctx.fill()
    
    ctx.beginPath()
    ctx.arc(x+500,y,16, 0, 2 * Math.PI)
    ctx.closePath()
    ctx.fill()
    y += canvas.height/4
  }
  
  if (BACK) {
    // top flap of envelope
    x = 0, y = 0
    ctx.fillStyle = "#eaae3a"
    ctx.shadowColor = '#505050';
    ctx.shadowBlur = 9
    
    ctx.beginPath()
    ctx.moveTo(x,y)
    ctx.lineTo(x + 50, y + 130)
    ctx.lineTo(canvas.width - 50, y + 130)
    ctx.lineTo(canvas.width, y)
    ctx.closePath()
    ctx.fill()
    // center line
    ctx.shadowColor = '#505050';
    ctx.shadowBlur = 4
    ctx.shadowOffsetX = 3;
    ctx.beginPath()
    ctx.moveTo(canvas.width/2,132)
    ctx.lineTo(canvas.width/2, canvas.height - 60)
    ctx.closePath()
    ctx.stroke()
    ctx.shadowColor = '#505050';
        ctx.shadowBlur = 9

    // red strings
    x = canvas.width/2 - 18
    y = 54
    ctx.lineCap = "round"
    ctx.lineWidth = 7
    ctx.strokeStyle = "red"
    ctx.beginPath()
    ctx.moveTo(x,y)
    ctx.lineTo(x + 1, y + 140)
    ctx.stroke()
    
    x = canvas.width/2 + 18
    y = 54
    ctx.lineWidth = 7
    ctx.strokeStyle = "red"
    ctx.beginPath()
    ctx.moveTo(x,y)
    ctx.lineTo(x + 1, y + 140)
    ctx.stroke()
    
    x = canvas.width/2 + 18
    y = 54
    ctx.lineWidth = 7
    ctx.strokeStyle = "red"
    ctx.beginPath()
    ctx.moveTo(x,y)
    ctx.lineTo(x - 25, y + 140)
    ctx.stroke()
    
    y += 180
    ctx.beginPath()
    ctx.arc(x+20, y, 50+pet(20), 1.4*Math.PI, Math.PI/2+pet(1), true)
    ctx.stroke()
    
    // seals
    ctx.shadowOffsetX = 3;
    ctx.shadowOffsetY = 3;
    
    x = canvas.width/2 + pet(7)
    y = 54
    ctx.fillStyle = "red"
    ctx.shadowColor = '#704000';
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    
    ctx.beginPath()
    ctx.arc(x,y,40,0,2*Math.PI)
    ctx.closePath()
    ctx.fill()
    
    ctx.fillStyle = "#b5a642"
    ctx.beginPath()
    ctx.arc(x,y,16,0,2*Math.PI)
    ctx.closePath()
    ctx.fill()
    
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.fillStyle = "#504020"
    ctx.beginPath()
    ctx.arc(x,y,12,0,2*Math.PI)
    ctx.closePath
    ctx.fill()
    x+= pet(7)
    y += 140
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    ctx.fillStyle = "red"
    ctx.beginPath()
    ctx.arc(x,y,40,0,2*Math.PI)
    ctx.closePath()
    ctx.fill()
    
    ctx.fillStyle = "#b5a642"
    ctx.beginPath()
    ctx.arc(x,y,16,0,2*Math.PI)
    ctx.closePath()
    ctx.fill()
    
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.fillStyle = "#504020"
    ctx.beginPath()
    ctx.arc(x,y,12,0,2*Math.PI)
    ctx.closePath()
    ctx.fill()
    
    // bottom back flap
    // top flap of envelope
    x = 0, y = 0
    ctx.fillStyle = "#e9a93a"
    ctx.shadowColor = '#505050';
    ctx.shadowBlur = 9
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    ctx.beginPath()
    ctx.moveTo(x,canvas.height)
    ctx.lineTo(x + 50, canvas.height - 110)
    ctx.lineTo(canvas.width - 50, canvas.height - 110)
    ctx.lineTo(canvas.width, canvas.height)
    ctx.closePath()
    ctx.fill()
    
  }
  ctx.shadowBlur = 0
  ctx.shadowOffsetX = 0
  ctx.shadowOffsetY = 0
  document.getElementById("opacity").value = alpha
  randomPick(getCurrentPalette()) // was paintcolor = color
}

function roundedRectFrame (x, y, w, h, r, ctx) {
  if (w < 2 * r) r = w / 2;
  if (h < 2 * r) r = h / 2;
  y += pet(6)
  ctx.save()
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y,   x+w, y+h, r); // across to right
  ctx.arcTo(x+w, y+h, x,   y+h, r);
  ctx.arcTo(x,   y+h, x,   y,   r);
  ctx.arcTo(x,   y,   x+w, y,   r);
  ctx.stroke()
}

function wavyPaperRounded (x, y, w, h, r) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let oc = document.createElement('CANVAS')
  let ob = document.getElementById("OC")
  let ctxoc = oc.getContext("2d")
  oc.width = canvas.width
  oc.height = canvas.height
  ob.width = canvas.width
  ob.height = canvas.height
  roundedRect(x, y, w, h, r, ctxoc, false) // draw to off
  swapWithOff() // switch to OC
  paperSelect()
  ctxoc.shadowColor = 'rgba(10, 10, 10, .3)'
  ctxoc.shadowBlur = 5 + Math.random() * 3
  ctxoc.shadowOffsetX = -2 - Math.random() * 2;
  ctxoc.shadowOffsetY = 1 + Math.random() * 1
  ctxoc.globalCompositeOperation = "source-atop"
  ctxoc.drawImage(canvas,0,0,oc.width,oc.height)
  swapWithOff()
  document.getElementById("mode").value = "source-over"
  ctx.globalCompositeOperation = "source-over"
  ctx.drawImage(oc,0,0,canvas.width,canvas.height)
}


function roundedRectP () {//(x, y, w, h, r, ctx, BF) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  
  let x = 20, y = 20, w = 1000, h = 1000, r = 20
  if (w < 2 * r) r = w / 2;
  if (h < 2 * r) r = h / 2;
  y += pet(5)
  x += pet(5)
  ctx.save()
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y,   x+w, y+h, r); // across to right
  ctx.arcTo(x+w, y+h, x,   y+h, r);
  ctx.arcTo(x,   y+h, x,   y,   r);
  ctx.arcTo(x,   y,   x+w, y,   r);
  ctx.closePath();
  //wavyPaper()
  ctx.clip()
    //
  ctx.fill()
  ctx.globalCompositeOperation = "source-atop"
  wavyPaper()

 // if (BF) {
//    blobFill(ctx.fillStyle)
 //   ctx.fillStyle = "#ececdb"
 //   ctx.fillRect(w/2, y, w/2, h)
//  }
  ctx.restore()
}

function roundedRect (x, y, w, h, r, ctx, BF) {
  if (w < 2 * r) r = w / 2;
  if (h < 2 * r) r = h / 2;
 // y += pet(5)
 // x += pet(5)
  ctx.save()
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y,   x+w, y+h, r); // across to right
  ctx.arcTo(x+w, y+h, x,   y+h, r);
  ctx.arcTo(x,   y+h, x,   y,   r);
  ctx.arcTo(x,   y,   x+w, y,   r);
  ctx.closePath();
  ctx.fill()
  ctx.clip()
  if (BF) {
    blobFill(ctx.fillStyle)
    ctx.fillStyle = "#ececdb"
    ctx.fillRect(w/2, y, w/2, h)
  }
  ctx.restore()
}

function moleskine2 (options) { // 3D
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let alpha = document.getElementById("opacity").value
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let small = true, half = true, scale = canvas.height/1080
  let W = canvas.width, H = canvas.height
  randomPick(getCurrentPalette()) // was paintcolor = "#fdffee"
  ctx.clearRect(0,0,W,H)
  ctx.shadowColor = '#404040';
  let j = 0, x = 20, y = 20, d = 0, BF = true, PAPER = false
  let ld = 0
  for(;j < 5; j++) {
    BF = true
    if (j % 2 ===0)
      ctx.fillStyle = randomColorLight()
    else
      ctx.fillStyle = "#ececdb"//randomColorLight()
    if (j === 0) {
      ctx.fillStyle = "#000000"
      ctx.shadowBlur = 8 + Math.random() * 12
      ctx.shadowOffsetX = 5 + Math.random() * 3;
      ctx.shadowOffsetY = 5 + Math.random() * 6;
      BF = false
    } else {
      ctx.shadowColor = 'rgba(10, 10, 10, .5)'//'#808080';
      ctx.shadowBlur = 5 + Math.random() * 3
      ctx.shadowOffsetX = 4 + Math.random() * 2;
      ctx.shadowOffsetY = 1 + Math.random() * 1
    }
    if (j === 4) {
      BF = false
      roundedRect(x+d, y, W-40-d*2, H-40, 14, ctx, BF) // same size. to get drop-shadow
      wavyPaperRounded(x+d, y, W-40-d*2, H-40, 14)
    } else
      roundedRect(x+d, y, W-40-d*2, H-40, 14, ctx, BF)
    d += 9*scale + pet(3*scale)
    ctx.shadowBlur = 0
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
  }
  
  // grid
  if (options && options === 1) {
    ctx.strokeStyle = "#bbbbd0"
    ctx.lineWidth = 1
    let i = 0
    x = 60*scale, y = 28
    while (y < canvas.height-47) {
      ctx.beginPath()
      ctx.moveTo(x, y)
      ctx.lineTo(canvas.width-26-d, y)
      ctx.closePath()
      ctx.stroke()
      y += 20*scale
    }
    i = 0,
    y = 22, x = 62*scale
    while (x < W-34-d) {
      ctx.beginPath()
      ctx.moveTo(x, y)
      ctx.lineTo(x, canvas.height-34)
      ctx.closePath()
      ctx.stroke()
      x += 20*scale
      if (x > canvas.width/2 && half) {
        half = false
        x -= 6
      }
    }
  }
  
  if (options && options === 2) {
    moleDates(d)
  }
  if (options && options === 3) {
    moleText()
  }

  //rcc()
  let mode = document.getElementById("mode").value
  ctx.globalCompositeOperation = "source-atop"
  afold(20)
  ctx.globalCompositeOperation = mode
  //rc()
  stiches(20)
  document.getElementById("opacity").value = alpha
  randomPick(getCurrentPalette()) // was paintcolor = color
}

function randomClue (PT) {
  let res = randomWord(PT)
  if (Math.random() > 0.9)
    res = "\"" + res +"\""
  else {
    if (Math.random() > 0.9) {
      if (Math.random() > 0.5)
        res = " ____ " + res
      else
        res += " ____ "
    }
  }
  if (Math.random() > 0.93)
    res += ", " + randomWord(PT);
  if (Math.random() > 0.95) {
    if (Math.random() > 0.5) {
      if (PT)
        res += " (2 palavras)"
      else
        res += " (2 words)"
    }
    else
      res += ", e.g."
  }
  return res
}

function clues (PT) {
  let result = "HORIZONTAL\n"
  let num = 1, cnt = 0
  while (cnt < 24) {
    result += "\n"
    if (num < 10)
      result += " "
    result += num + " " + randomClue(PT)
    num += 1 // bump by one more occasionally
    if (Math.random() > 0.8)
      num ++
    cnt++
  }
  num = 1, cnt = 0
  result += "\nVERTICAL\n"
  while (cnt < 24) {
    result += "\n"
    if (num < 10)
      result += " "
    result += num+" "+randomClue(PT)
    num += 1 // bump by one more occasionally
    if (Math.random() > 0.8)
      num ++
    cnt++
  }
  return result
}


function index (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  let words = [], i = 0
  for (; i < 200; i++) {
    words.push(randomWord())
  }
  let start = Math.floor(Math.random()*(words.length-100))
  let end = start + 100
  let chunk = words.sort().slice(start,end)
  if (!index)
      canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let alpha = document.getElementById("opacity").value
  ctx.font = 20+"px monospace"
  ctx.fillStyle = randomPick(["#302020", "#505080", "#404060", "#506060", "#202020"])
  let scale = 1
  let linespace = 2*14
  let avspace = Math.floor((canvas.height - 20 - 100*scale)/linespace - 1)
  let nums = []
  ctx.fillText("Index", 80*scale, 70)
  ctx.font = 14+"px monospace"
  i = 0, x = 80*scale, y = 120*scale
  while (y < canvas.height-80  && chunk[i] !== undefined) {
    nums = pagenumbers()
    ctx.fillText(chunk[i]+" "+dotpad(chunk[i].length+nums.length)+nums, x, y)
    y += linespace
    let nl = nextLetter(chunk,i)
    if (nl) {
      ctx.fillText(nl, x-11, y)
      y += linespace
    }
    i++
  }
  puff = 0
  x += canvas.width/3-24*scale,  y = 120*scale
  while (y < canvas.height-80 && chunk[i] !== undefined) {
    nums = pagenumbers()
    ctx.fillText(chunk[i]+" "+dotpad(chunk[i].length+nums.length)+nums, x, y)
    y += linespace
    let nl = nextLetter(chunk,i)
    if (nl) {
      ctx.fillText(nl, x-11, y)
      y += linespace
    }
    i++
  }
  
  puff = 0
  x += canvas.width/3-24*scale,  y = 120*scale
  while (y < canvas.height-80 && chunk[i] !== undefined) {
    nums = pagenumbers()
    ctx.fillText(chunk[i]+" "+dotpad(chunk[i].length+nums.length)+nums, x, y)
    y += linespace
    let nl = nextLetter(chunk,i)
    if (nl) {
      ctx.fillText(nl, x-11, y)
      y += linespace
    }
    i++
  }
}

function nextLetter (chunk, i) {
  result = false
  if (i < chunk.length - 2) {
    let d = (chunk[i][0] != chunk[i+1][0])
    if (d)
      result = chunk[i+1][0].toUpperCase()
  }
  return result
}

function dotpad(n) {
  result = "", g = 0
  if (n < 24) {
    g = 24-n
    while (result.length < g)
      result += "."
  }
  return result
}

function pagenumbers () {
  let pages = "", i = 0, max = 1+ Math.floor(Math.random() * 4)
  let nums = []
  for (; i < max; i++)
    nums.push(3+Math.floor(Math.random()* 389))
  nums - nums.sort(function(a, b) {return a - b;});
  i = 0
  for (; i < nums.length; i++)
    pages += nums[i] + ", "
  return pages.slice(0, -2)
}

function filmFrame () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let alpha = document.getElementById("opacity").value
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let W = canvas.width, H = canvas.height
  let scale = W/1080
  ctx.strokeStyle = "#201010"
  ctx.fillStyle = "#eece60"
  let lw = (28 + Math.random() *12) * scale
  ctx.lineWidth = lw
  ctx.lineJoin = "square"
  ctx.beginPath()
  ctx.moveTo(lw,lw/2)
  ctx.lineTo(W-lw/2,lw/2)
  ctx.lineTo(W-lw/2,H-lw/2)
  ctx.lineTo(lw/2,H-lw/2)
  ctx.lineTo(lw/2,0)
  ctx.closePath()
  ctx.stroke()
  let num = 2 + Math.floor(Math.random() * 33)
  let text = "         "+ num + "                         KODAK PORTRA "+randomPick([160,400,800])+"                                              " + (num+1)
  if (Math.random() > 0.5)
    text = "    AGFA HDC 400                                  AGFA HDC 400                                  AGFA HDC 400"
  text = randomPick([" ", "         ", "                "]) + text
  ctx.font = lw*0.7+"px Helvetica"

  ctx.save()
  ctx.translate(lw*0.8 + pet(4), H - 40*scale + pet(24))
  ctx.rotate(-Math.PI/2) // need to adjust x & y offsets per line
  ctx.fillText(text, 0,0)
  ctx.restore()

  let y = 25+H - Math.random() * H/4, x = W-lw/4 + pet(2)
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x-lw/2,y)
  ctx.lineTo(x-lw/4, y-lw)
  ctx.closePath()
  ctx.fill()
  num = 2 + Math.floor(Math.random() * 33)
  
  text = " "+num
  ctx.save()
  ctx.translate(x, y - lw)
  ctx.rotate(-Math.PI/2) // need to adjust x & y offsets per line
  ctx.fillText(text, 0,0)
  ctx.restore()
  
  y -= H/2
  num +=1
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x-lw/2,y)
  ctx.lineTo(x-lw/4, y-lw)
  ctx.closePath()
  ctx.fill()

  text = " "+(num)+"A"
  ctx.save()
  ctx.translate(x, y - lw)
  ctx.rotate(-Math.PI/2) // need to adjust x & y offsets per line
  ctx.fillText(text, 0,0)
  ctx.restore()
}

function moleText (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let alpha = document.getElementById("opacity").value
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let small = true, half = true
  let scale = canvas.height/1080
  ctx.strokeStyle = "#ccccdc"
  let thebook//= crossword
  let PT = Math.random() > 0.5
  let fs = 18 //+ Math.floor(document.getElementById("featuresize").value/2)
  //if (thebook === crossword)
    thebook = clues(PT)
  let text = document.getElementById("points").value
  if (text.length > 0)
    thebook = text
  let lines = thebook.split(/\n/gm) // moby.js = book
  ctx.font = fs*scale+"px Georgia"
  ctx.fillStyle = color
  let linespace = 2*fs*scale
  let avspace = Math.floor((canvas.height - 20 - 60*scale)/linespace - 1)
  let i = 0, x = 90*scale, y = 60*scale
  while (i < avspace && lines[i] !== undefined) {
    ctx.fillText(lines[i], x, y)
    y += linespace
    i++
  }
  x += canvas.width/2-60*scale,  y = 60*scale
  while (i < avspace*2 && lines[i] !== undefined) {
    ctx.fillText(lines[i], x, y)
    y += linespace
    i++
  }
}

function moleBook () {
  moleskine2(3)
}

function moleskine () {
  moleskine2(1)
}

function moleskineDay () {
  moleskine2(2)
}

function moleDates (d) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let alpha = document.getElementById("opacity").value
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let small = true, half = true
  let scale = canvas.height/1080
  ctx.strokeStyle = "#ccccdc"
  ctx.lineWidth = 1
  let hour = 8
  let monthsFR = [ "janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre"]
  let months = ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"]
  let daysFR = ["DIMANCHE", "LUNDI", "MARDI","MERCREDI","JEUDI","VENDREDI","SAMEDI"]
  let days = ["DOMINGO", "SEGUNDA-FEIRA", "TERÇA-FEIRA", "QUARTA-FEIRA", "QUINTA-FEIRA", "SEXTA-FEIRA", "SÁBADO"]
  let week = "semana "
  ctx.font = 12*scale+"px serif"
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor = "#666666"
  let voff = randomPick([1,2,-1,-2])
  let lasty = 0
  let linespace = Math.floor((canvas.height - 220*scale)/22)
  let i = 0, x = 60*scale, y = 144*scale, last = 0
  while (i < 22) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(canvas.width/2, y)
    ctx.closePath()
    ctx.stroke()
    if (hour < 23) {
      ctx.fillText(hour, 76*scale, y+linespace-5)
      ctx.fillText(hour, canvas.width/2+44, y+linespace-5+voff)
      last = y
    }
    y += linespace
    hour += 1
    i++
  }
  lasty = y - linespace
  i = 0, x = canvas.width/2, y = 144*scale + voff
  while (i < 22) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(canvas.width-28-d, y)
    ctx.closePath()
    ctx.stroke()
    y += linespace
    i++
  }
  
  ctx.font = 12*scale+"px serif monospace"
  ctx.globalCompositeOperation ="luminosity"
  
  ctx.fillText("\u{26C5}", 76*scale, lasty-linespace-5)
  greyScaleSpot(76*scale, lasty-linespace-5-12*scale, 18*scale, 18*scale)
 
  ctx.fillText("\u{1F321}", 76*scale, lasty-5)
  greyScaleSpot (76*scale, lasty-5-12*scale, 18*scale, 18*scale)
  
  ctx.fillText("\u{26C5}", canvas.width/2+44, lasty-linespace-5+voff)
  greyScaleSpot(canvas.width/2+44, lasty-linespace-5+voff-12*scale, 18*scale, 18*scale)

  ctx.fillText("\u{1F321}", canvas.width/2+44, lasty-5+voff)
  greyScaleSpot (canvas.width/2+44, lasty-5+voff-12*scale, 18*scale, 18*scale)

  ctx.globalCompositeOperation = "source-over"
  const today = new Date()
  const tomorrow = new Date(today)
  tomorrow.setDate(tomorrow.getDate() + 1)
  
  let size = 20*scale//document.getElementById("featuresize").value/6.25
  if (Math.random() > 0.5) {
    months = monthsFR
    days = daysFR
    week = "la semaine "
  }
  ctx.fillText(week+today.getWeek(), canvas.width - 108-d*scale, lasty-5+voff)// FR: "la semaine"
  
  ctx.font = size+"px serif"
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor = "#666666"
  x = 78*scale, y = 70*scale
  ctx.fillText(days[today.getDay()], x, y)
  ctx.font = 14*scale+"px serif"
  ctx.fillText(months[today.getMonth()], x, y+26*scale)
  ctx.font = 22*scale+"px serif"
  ctx.fillText(today.getDate(), x, y+56*scale)
  
  ctx.textAlign = 'right';
  x = canvas.width-52-d*scale, y = 70*scale
  ctx.font = size+"px serif"
  ctx.fillText(days[tomorrow.getDay()], x, y)
  ctx.font = 14*scale+"px serif"
  ctx.fillText(months[tomorrow.getMonth()], x, y+26*scale)
  ctx.font = 22*scale+"px serif"
  ctx.fillText(tomorrow.getDate(), x, y+56*scale)
}

Date.prototype.getWeek = function() {
  let date = new Date(this.getTime());
  date.setHours(0, 0, 0, 0);
  // Thursday in current week decides the year.
  date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
  // January 4 is always in week 1.
  let week1 = new Date(date.getFullYear(), 0, 4);
  // Adjust to Thursday in week 1 and count number of weeks from date to week1.
  return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000
                        - 3 + (week1.getDay() + 6) % 7) / 7);
}

function nested (color, lw) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  if (lw)
    ctx.lineWidth = lw
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  if (color)
    ctx.strokeStyle = color
  ctx.lineCap = 'square'
  ctx.lineJoin = 'meter'
  let ratio = 1/1.61803
  let pad = 0
  let W = canvas.width
  if (W > canvas.height)
    W = canvas.height
  W -= pad * 2
  let adjust = ctx.lineWidth/2
  let x = pad, y = pad, line = true
  let xd = pad, yd = pad
  //let pad = 0//10 + Math.random() * 40
  drawRectAt(ctx, x+adjust, y+adjust, W-(adjust*2), line) // first square
  let depth = randomPick([3,4,5])//Math.floor((-1/12 * ctx.lineWidth) +(49/6)) // tbd: 3 to 6
  let i = 0, x2, y2, W0
  for (;i < depth; i++) {
    W0 = W
    W *= ratio
    
    let r  = Math.random()
    if (r > 0.667)
      xd = pad
    else
    if (r > 0.333)
      xd = W
    else
      xd = W0 - W
    x += Math.floor(xd)
    r = Math.random()
    if (r > 0.667)
      yd = pad
    else
    if (r > 0.333)
      yd = W
    else
      yd = W0 - W
    y += Math.floor(yd)
    drawRectAt(ctx, x, y, Math.floor(W), line)
  }
}

function neckerline () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/50
  let W = canvas.width
  if (W > canvas.height)
    W = canvas.height
  let margin = W/20
  let w4 = (W-2*margin)/3//(2+Math.floor(Math.random() * 3))//document.getElementById("rows").value
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineCap = 'round'
  ctx.lineJoin = 'round'

  let grunge = document.getElementById("grungy").checked
  //bottom
  ctx.beginPath();
  ctx.moveTo(margin, W-margin)
  ctx.lineTo(w4+margin, W-w4-margin)
  ctx.lineTo(W-margin, W-w4-margin)
  ctx.lineTo(W-w4-margin, W-margin)
  ctx.lineTo(margin, W-margin)
  ctx.stroke()
  //left side
  ctx.beginPath();
  ctx.moveTo(margin, w4+margin)
  ctx.lineTo(w4+margin, margin)
  ctx.lineTo(w4+margin, W-w4-margin)
  ctx.lineTo(margin, W-margin)
  ctx.lineTo(margin, w4+margin)
  ctx.stroke()
    //upper right
  ctx.beginPath();
  ctx.moveTo(w4+margin, 0+margin)
  ctx.lineTo(W-margin, 0+margin)
  ctx.lineTo(W-margin, W-w4-margin)
  ctx.lineTo(w4+margin, W-w4-margin)
  ctx.stroke()
  
  // lower left
  ctx.beginPath();
  ctx.moveTo(margin, w4+margin)
  ctx.lineTo(W-w4-margin, w4+margin)
  ctx.lineTo(W-w4-margin, W-margin)
  ctx.lineTo(margin, W-margin)
  ctx.stroke()
  
  //top
  ctx.beginPath();
  ctx.moveTo(margin, w4+margin)
  ctx.lineTo(w4+margin, margin)
  ctx.lineTo(W-margin, margin)
  ctx.lineTo(W-w4-margin, w4+margin)
  ctx.stroke()
  
  //right side
  ctx.beginPath();
  ctx.moveTo(W-w4-margin, w4+margin)
  ctx.lineTo(W-margin, margin)
  ctx.lineTo(W-margin, W-w4-margin)
  ctx.lineTo(W-w4-margin, W-margin)
  ctx.stroke()
}


function pyrm () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1+ document.getElementById("featuresize").value/50
  let W = canvas.width, H = canvas.height
  
  let margin = W/20
  let w4 = (W-2*margin)/3//(2+Math.floor(Math.random() * 3))//document.getElementById("rows").value
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineCap = 'round'
  ctx.lineJoin = 'round'
  let points = []
  points.push(Math.random() * W/2, Math.random() * H/2)
  points.push(W/2+Math.random() * W/2, Math.random() * H/2)
  points.push(W/2+Math.random() * W/2, H/2+Math.random() * H/2)
  points.push(Math.random() * W/2, H/2+Math.random() * H/2)

  let grunge = document.getElementById("grungy").checked
  //bottom
  ctx.beginPath();
  ctx.moveTo(points[0], points[1])
  ctx.lineTo(points[2], points[3])
  ctx.lineTo(points[4], points[5])
  ctx.lineTo(points[6], points[7])
  ctx.lineTo(points[0], points[1])
  ctx.stroke()

  points.push(Math.random() * W, Math.random() * H)
  ctx.beginPath();
  ctx.moveTo(points[0], points[1])
  ctx.lineTo(points[8], points[9])
  ctx.stroke()

  ctx.beginPath();
  ctx.moveTo(points[2], points[3])
  ctx.lineTo(points[8], points[9])
  ctx.stroke()

  ctx.beginPath();
  ctx.moveTo(points[4], points[5])
  ctx.lineTo(points[8], points[9])
  ctx.stroke()

  ctx.beginPath();
  ctx.moveTo(points[6], points[7])
  ctx.lineTo(points[8], points[9])
  ctx.stroke()

}
/*
function elle () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  //ctx.save()
  clip()
  let margin = canvas.width/50 * (2+Math.floor(Math.random() * 10))//
  let W = canvas.width
  let w4 = (canvas.width -(2*margin))/4
  let w2 = (canvas.width -(2*margin))/2

  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(['#ff0000', '#00ff00', '#FFFF00', '#FFA500', '#800080', "#0000ff"])
  let grunge = false//document.getElementById("grungy").checked
  
  ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)

  ctx.beginPath();
  ctx.moveTo(0+margin, W-w4-margin) // square in lower left
  ctx.lineTo(w4+margin, W-w4-margin)
  ctx.lineTo(w4+margin, W-margin)
  ctx.lineTo(0+margin, W-margin)
 // ctx.lineTo(w4, W-w4)
  ctx.closePath()
  //if (grunge)
    ctx.fillStyle = colors[0]//randomGradient(canvas, colors[0])
  ctx.fill()
  
  ctx.beginPath();
  ctx.moveTo(0+margin, w2+margin)
  ctx.lineTo(w2+margin, w2+margin)
  ctx.lineTo(w2+margin, W-margin)
  ctx.lineTo(w4+margin, W-margin)
  ctx.lineTo(w4+margin, W-w4-margin)
  ctx.lineTo(0+margin, W-w4-margin)
  ctx.closePath()
  //if (grunge)
    ctx.fillStyle = colors[1]//randomGradient(canvas, colors[0])
  ctx.fill()

  ctx.beginPath();
  ctx.moveTo(0+margin, w4+margin)
  ctx.lineTo(w2+w4+margin, w2-w4+margin)
  ctx.lineTo(w2+w4+margin, W-margin)
  ctx.lineTo(w2+margin, W-margin)
  ctx.lineTo(w2+margin, W-w2-margin)
  ctx.lineTo(0+margin, W-w2-margin)
  ctx.closePath()
  //if (grunge)
    ctx.fillStyle = colors[2]//randomGradient(canvas, colors[0])
  ctx.fill()
  
  ctx.beginPath();
  ctx.moveTo(0+margin, 0+margin)
  ctx.lineTo(W-margin, 0+margin)
  ctx.lineTo(W-margin, W-margin)
  ctx.lineTo(W-w4-margin, W-margin)
  ctx.lineTo(W-w4-margin, w4+margin)
  ctx.lineTo(0+margin, w4+margin)
  ctx.closePath()
  //if (grunge)
    ctx.fillStyle = colors[3]//randomGradient(canvas, colors[0])
  ctx.fill()
}

function flower () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  clip()
  let W = canvas.width
  let margin = W/20
  let w4 = (W-2*margin)/(4 + (document.getElementById("rows").value/2))
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(['#ff0000', '#00ff00', '#FFFF00', '#FFA500', '#800080', "#0000ff"])
  let grunge = document.getElementById("grungy").checked
  w4 *= 0.5
  let xf = w4 //* 1.0
  let r = W
  let inc = W/2
  ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
  let i = 0, x = 0, y = 0

  if (Math.random() > 0.5) {
    x = 0, y = 0
    ctx.beginPath();
    ctx.moveTo(x, y) // \
    ctx.arc(x,y,r,0,2*Math.PI)
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = randomGradient(canvas, colors[0])
    ctx.fill()
    x = W, y = 0
    
    ctx.beginPath();
    ctx.moveTo(x, y) // \
    ctx.arc(x,y,r,0,2*Math.PI)
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = randomGradient(canvas, colors[1])
    ctx.fill()
    x = 0, y = W
    
    ctx.beginPath();
    ctx.moveTo(x, y) // \
    ctx.arc(x,y,r,0,2*Math.PI)
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = randomGradient(canvas, colors[2])
    ctx.fill()
    x = W, y = W
    
    ctx.beginPath();
    ctx.moveTo(x, y) // \
    ctx.arc(x,y,r,0,2*Math.PI)
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = randomGradient(canvas, colors[3])
    ctx.fill()
  } else {
    x = 0, y = W
    
    ctx.beginPath();
    ctx.moveTo(x, y) // \
    ctx.arc(x,y,r,0,2*Math.PI)
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = randomGradient(canvas, colors[2])
    ctx.fill()
    x = W, y = W
    
    ctx.beginPath();
    ctx.moveTo(x, y) // \
    ctx.arc(x,y,r,0,2*Math.PI)
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = randomGradient(canvas, colors[3])
    ctx.fill()
    
    x = 0, y = 0
    ctx.beginPath();
    ctx.moveTo(x, y) // \
    ctx.arc(x,y,r,0,2*Math.PI)
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = randomGradient(canvas, colors[0])
    ctx.fill()
    x = W, y = 0
    
    ctx.beginPath();
    ctx.moveTo(x, y) // \
    ctx.arc(x,y,r,0,2*Math.PI)
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = randomGradient(canvas, colors[1])
    ctx.fill()
  }
}

function folded () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  clip()
  let W = canvas.width
  let margin = W/20
  let w4 = (W-2*margin)/(2+Math.floor(Math.random() * 10))//
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let grunge = document.getElementById("grungy").checked
  w4 *= 0.5
  let xf = w4 //* 1.0

  let p1 = [margin, margin] //top left
  let p2 = [w4+margin, margin]  // top
  let p3 = [margin, W-margin]
  let p4 = [w4+ margin, W-margin]
  
  
  ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
  ctx.beginPath();
  ctx.moveTo(p1[0], p1[1]) // \
  ctx.lineTo(p2[0], p2[1])
  ctx.lineTo(p4[0], p4[1])
  ctx.lineTo(p3[0], p3[1])
  ctx.closePath()
  if (grunge)
    ctx.fillStyle = colors[4]
  ctx.fill()
  
  let maxloop = 7 + +(2+Math.floor(Math.random() * 10))//
  let i = 0
  for (;i < maxloop; i++) {
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(p4[0], p4[1]) // /
    ctx.lineTo(p3[0], p3[1])
    ctx.lineTo(p1[0] + xf, p1[1])
    ctx.lineTo(p2[0] + xf, p2[1])
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[i%6]
    ctx.fill()
    
    p1[0] += xf
    p2[0] += xf
    p3[0] += xf
    p4[0] += xf
    
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(p1[0], p1[1])
    ctx.lineTo(p2[0], p2[1])
    ctx.lineTo(p4[0], p4[1])
    ctx.lineTo(p3[0], p3[1])
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[(i+1)%6]
    ctx.fill()
  }
}

function pyramid () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  clip()
  let W = canvas.width
  let margin = W/20
  let w4 = (W-2*margin)/(4 + (2+Math.floor(Math.random() * 10)))
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(['red', 'blue', 'yellow', 'orange', 'purple', "green"])
  let grunge = document.getElementById("grungy").checked
  w8 = w4*3

  let p1 = [margin, W/2 + W/4] //left
  let p2 = [W/2, margin]  // top
  let p3 = [W-margin, W/2 + W/4]
  let p4 = [W/2 + W/8-margin, W-margin]
  let p5 = [W/2-W/8+margin, W-W/4-W/8-margin]
  
  if (Math.random() > 0.5) {
   // left
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(p1[0], p1[1]) // bottom left
    ctx.lineTo(p2[0], p2[1]) // up
    ctx.lineTo(p4[0], p4[1]) //peak
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[0]
    ctx.fill()
    // right
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(p2[0], p2[1])
    ctx.lineTo(p3[0], p3[1]) // up
    ctx.lineTo(p4[0], p4[1]) //peak
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[1]
    ctx.fill()
    
    
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(p2[0], p2[1]) // bottom left
    ctx.lineTo(p3[0], p3[1]) // up
    ctx.lineTo(p5[0], p5[1]) //peak
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[2]
    ctx.fill()
    
    // top
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(p1[0], p1[1]) // bottom left
    ctx.lineTo(p2[0], p2[1]) //peak
    ctx.lineTo(p5[0], p5[1]) // up
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[3]
    ctx.fill()
   
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(p1[0], p1[1]) // bottom left
    ctx.lineTo(p4[0], p4[1]) // up
    ctx.lineTo(p3[0], p3[1]) // up
    ctx.lineTo(p5[0], p5[1]) //peak
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[5]
    ctx.fill()
    
 } else {
   
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(p1[0], p1[1]) // bottom left
    ctx.lineTo(p4[0], p4[1]) // up
    ctx.lineTo(p3[0], p3[1]) // up
    ctx.lineTo(p5[0], p5[1]) //peak
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[5]
    ctx.fill()
    
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(p2[0], p2[1]) // bottom left
    ctx.lineTo(p3[0], p3[1]) // up
    ctx.lineTo(p5[0], p5[1]) //peak
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[2]
    ctx.fill()
    
    // top
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(p1[0], p1[1]) // bottom left
    ctx.lineTo(p2[0], p2[1]) //peak
    ctx.lineTo(p5[0], p5[1]) // up
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[3]
    ctx.fill()
   
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(p1[0], p1[1]) // bottom left
    ctx.lineTo(p2[0], p2[1]) // up
    ctx.lineTo(p4[0], p4[1]) //peak
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[0]
    ctx.fill()
    // right
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(p2[0], p2[1])
    ctx.lineTo(p3[0], p3[1]) // up
    ctx.lineTo(p4[0], p4[1]) //peak
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[1]
    ctx.fill()
  }
}
*/
function house () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width
  let margin = W/16
  let w4 = (W-2*margin)/(4 +(2+Math.floor(Math.random() * 4)))
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let grunge = !document.getElementById("grungy").checked
  let w8 = w4*3
  let xf = W-w8
  let yf = W -(2*margin) - w8 - w8/2
 //ctx.clearRect(0,0,W,W)
  if (Math.random() > 0.6) {
    // upper right face
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(xf-margin,     W-margin-yf) // bottom left
    ctx.lineTo(xf-margin,     W-w8-margin-yf) // up
    ctx.lineTo(xf-margin+w8/2,W-margin-w8 - w8/2-yf) //peak
    ctx.lineTo(xf+w8-margin,  W-w8-margin- yf)
    ctx.lineTo(xf-margin+w8,  W-margin-yf)
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[0]
    ctx.fill()
    
    // floor
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor
    ctx.beginPath();
    ctx.moveTo(margin, W-margin) // bottom left
    ctx.lineTo(margin+w8, W-margin)
    ctx.lineTo(xf-margin+w8,  W-margin-yf)
    ctx.lineTo(xf-margin,     W-margin-yf) // bottom left
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[1]
    ctx.fill()
    
    // left wall
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(margin, W-margin) // bottom left
    ctx.lineTo(margin, W-w8-margin) // uroof left
    ctx.lineTo(xf-margin,     W-w8-margin-yf) // up
    ctx.lineTo(xf-margin,     W-margin - yf) // bottom left
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[3]
    ctx.fill()
    
   // left roof
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor
    ctx.beginPath();
    ctx.moveTo(margin, W-w8-margin) // uroof left
    ctx.lineTo(margin+w8/2, W-margin-w8 - w8/2) //peak
    ctx.lineTo(xf-margin+w8/2,W-margin-w8 - w8/2 -yf) //peak
    ctx.lineTo(xf-margin,     W-w8-margin-yf) // up
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[4]
    ctx.fill()

    // right roof
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor
    ctx.beginPath();
    ctx.moveTo(margin+w8/2, W-margin-w8 - w8/2) //peak
    ctx.lineTo(w8+margin, W-w8-margin) // roof right
    ctx.lineTo(xf+w8-margin,  W-w8-margin-yf)
    ctx.lineTo(xf-margin+w8/2,W-margin-w8 - w8/2 -yf) //peak
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[5]
    ctx.fill()
    
    // right wall
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(w8+margin, W-w8-margin) // roof right
    ctx.lineTo(margin+w8, W-margin) // bottom right
    ctx.lineTo(xf-margin+w8,  W-margin-yf)
    ctx.lineTo(xf+w8-margin,  W-w8-margin-yf)
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[2]
    ctx.fill()
    
    // lower left face
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(margin, W-margin) // bottom left
    ctx.lineTo(margin, W-w8-margin) // uroof left
    ctx.lineTo(margin+w8/2, W-margin-w8 - w8/2) //peak
    ctx.lineTo(w8+margin, W-w8-margin) // roof right
    ctx.lineTo(margin+w8, W-margin) // bottom right
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[1]
    ctx.fill()
  } else {
    // right roof
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(margin+w8/2, W-margin-w8 - w8/2) //peak
    ctx.lineTo(w8+margin, W-w8-margin) // roof right
    ctx.lineTo(xf+w8-margin,  W-w8-margin-yf)
    ctx.lineTo(xf-margin+w8/2,W-margin-w8 - w8/2 -yf) //peak
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[5]
    ctx.fill()
    
    // right wall
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(w8+margin, W-w8-margin) // roof right
    ctx.lineTo(margin+w8, W-margin) // bottom right
    ctx.lineTo(xf-margin+w8,  W-margin-yf)
    ctx.lineTo(xf+w8-margin,  W-w8-margin-yf)
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[2]
    ctx.fill()
    
    // lower left face
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(margin, W-margin) // bottom left
    ctx.lineTo(margin, W-w8-margin) // uroof left
    ctx.lineTo(margin+w8/2, W-margin-w8 - w8/2) //peak
    ctx.lineTo(w8+margin, W-w8-margin) // roof right
    ctx.lineTo(margin+w8, W-margin) // bottom right
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[1]
    ctx.fill()
    
    // upper right face
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(xf-margin,     W-margin-yf) // bottom left
    ctx.lineTo(xf-margin,     W-w8-margin-yf) // up
    ctx.lineTo(xf-margin+w8/2,W-margin-w8 - w8/2-yf) //peak
    ctx.lineTo(xf+w8-margin,  W-w8-margin- yf)
    ctx.lineTo(xf-margin+w8,  W-margin-yf)
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[0]
    ctx.fill()
    
    // floor
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(margin, W-margin) // bottom left
    ctx.lineTo(margin+w8, W-margin)
    ctx.lineTo(xf-margin+w8,  W-margin-yf)
    ctx.lineTo(xf-margin,     W-margin-yf) // bottom left
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[1]
    ctx.fill()
    
    // left wall
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(margin, W-margin) // bottom left
    ctx.lineTo(margin, W-w8-margin) // uroof left
    ctx.lineTo(xf-margin,     W-w8-margin-yf) // up
    ctx.lineTo(xf-margin,     W-margin - yf) // bottom left
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[3]
    ctx.fill()
    
   // left roof
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
    ctx.beginPath();
    ctx.moveTo(margin, W-w8-margin) // uroof left
    ctx.lineTo(margin+w8/2, W-margin-w8 - w8/2) //peak
    ctx.lineTo(xf-margin+w8/2,W-margin-w8 - w8/2 -yf) //peak
    ctx.lineTo(xf-margin,     W-w8-margin-yf) // up
    ctx.closePath()
    if (grunge)
      ctx.fillStyle = colors[4]
    ctx.fill()
  }
}
/**/


function origami () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width
  let len = W/2, maxy = W/2
  let colors = getCurrentPalette()
  // four triangles
  ctx.fillStyle = randomGradient(canvas, randomPick(colors))
  ctx.beginPath();
  ctx.moveTo(len, len)
  ctx.lineTo(W, W)
  ctx.lineTo(0, W)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = randomGradient(canvas, randomPick(colors))
  ctx.beginPath();
  ctx.moveTo(len, len)
  ctx.lineTo(0, 0)
  ctx.lineTo(W, 0)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = randomGradient(canvas, randomPick(colors))
  ctx.beginPath();
  ctx.moveTo(len, len)
  ctx.lineTo(0, 0)
  ctx.lineTo(0, W)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = randomGradient(canvas, randomPick(colors))
  ctx.beginPath();
  ctx.moveTo(len, len)
  ctx.lineTo(W, 0)
  ctx.lineTo(W, W)
  ctx.closePath()
  ctx.fill()

  // 4 rects
  ctx.fillStyle = randomGradient(canvas, randomPick(colors))  // top Horizontal
  ctx.beginPath();
  ctx.moveTo(0, 0)
  ctx.lineTo(W, 0)
  ctx.lineTo(W, len)
  ctx.lineTo(0, len)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = randomGradient(canvas, randomPick(colors))
  ctx.beginPath();
  ctx.moveTo(0, len)
  ctx.lineTo(W, len)
  ctx.lineTo(W, W)
  ctx.lineTo(0, W)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = randomGradient(canvas, randomPick(colors))
  ctx.beginPath();
  ctx.moveTo(0, 0)
  ctx.lineTo(len, 0)
  ctx.lineTo(len, W)
  ctx.lineTo(0, W)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = randomGradient(canvas, randomPick(colors))
  ctx.beginPath();
  ctx.moveTo(len, 0)
  ctx.lineTo(W, 0)
  ctx.lineTo(W, W)
  ctx.lineTo(len, W)
  ctx.closePath()
  ctx.fill()

  // diamond
  ctx.fillStyle = randomGradient(canvas, randomPick(colors))
  ctx.beginPath();
  ctx.moveTo(len, 0)
  ctx.lineTo(W, len)
  ctx.lineTo(len, W)
  ctx.lineTo(0, len)
  ctx.closePath()
  ctx.fill()
}


function origami4by4 () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width
  let len = W/2, maxy = W/2
  let quat = len/2
    let colors = getCurrentPalette()

  // 4 rects
  // top Horizontal
  ctx.fillStyle = randomGradient(canvas, randomPick(colors))
  ctx.beginPath();
  ctx.moveTo(0, 0)
  ctx.lineTo(W, 0)
  ctx.lineTo(W, quat)
  ctx.lineTo(0, quat)
  ctx.fill()
    
  ctx.fillStyle = randomGradient(canvas, randomPick(colors))
  ctx.beginPath();
  ctx.moveTo(0, 0)
  ctx.lineTo(quat, 0)
  ctx.lineTo(quat, W)
  ctx.lineTo(0, W)
  ctx.closePath()
  ctx.fill()
    
  ctx.fillStyle = randomGradient(canvas, randomPick(colors))
  ctx.beginPath();
  ctx.moveTo(0, quat)
  ctx.lineTo(W, quat)
  ctx.lineTo(W, len)
  ctx.lineTo(0, len)
  ctx.closePath()
  ctx.fill()
    
  ctx.fillStyle = randomGradient(canvas, randomPick(colors))
  ctx.beginPath();
  ctx.moveTo(quat, 0)
  ctx.lineTo(len, 0)
  ctx.lineTo(len, W)
  ctx.lineTo(quat, W)
  ctx.closePath()
  ctx.fill()
    
  ctx.fillStyle = randomGradient(canvas, randomPick(colors))
  ctx.beginPath();
  ctx.moveTo(0, len)
  ctx.lineTo(W, len)
  ctx.lineTo(W, len + quat)
  ctx.lineTo(0, len + quat)
  ctx.closePath()
  ctx.fill()
    
  ctx.fillStyle = randomGradient(canvas, randomPick(colors))
  ctx.beginPath();
  ctx.moveTo(len, 0)
  ctx.lineTo(len+quat, 0)
  ctx.lineTo(len+quat, W)
  ctx.lineTo(len, W)
  ctx.closePath()
  ctx.fill()
    
  ctx.fillStyle = randomGradient(canvas, randomPick(colors))
  ctx.beginPath();
  ctx.moveTo(0, len + quat)
  ctx.lineTo(W, len + quat)
  ctx.lineTo(W, W)
  ctx.lineTo(0, W)
  ctx.closePath()
  ctx.fill()
    
  ctx.fillStyle = randomGradient(canvas, randomPick(colors))
  ctx.beginPath();
  ctx.moveTo(len+quat, 0)
  ctx.lineTo(W, 0)
  ctx.lineTo(W, W)
  ctx.lineTo(len+quat, W)
  ctx.closePath()
  ctx.fill()
}
/**/
function strokes () {
  let increase = Math.PI * 2 / 40;
  let x = 0, y = 0, angle = 4.7;
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.save()
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let maxalpha = ctx.globalAlpha
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  let stroke_ct = +document.getElementById("number").value/400 + 1
  let stroke_width = 3
  for (let t = 0; t < stroke_ct; t++) {
    let paths = [];
    let radius = Math.floor(Math.random() * 180) + 20;
    x = 0;
    y = 0;
    let x0 = x;
    let y0 = y;
    angle = Math.floor(Math.random() * 6.42);
    let centx = Math.random()*ctx.canvas.width;
    let centy = Math.random()*ctx.canvas.height;
    let edges = (3 * (Math.floor(Math.random()*6))+6);
    let maxradius = Math.random() * 200 + canvas.width/3;
    increase = Math.PI * 2/edges*0.98;
    let points = [];
    let bez = [];
    let xmut = -1;
    let ymut = -1;
    if (Math.random() < 0.5)
      xmut *= -1;
    if (Math.random() < 0.5)
      ymut *= -1;
    for (let i = 0; i < edges; i++) {
      radius = (Math.random() * maxradius) + maxradius * 0.8;
      x = radius * Math.cos(angle)+centx;
      y = radius * Math.sin(angle)+centy;
      points.push([x, y]);
      angle += increase;
    }
    paths.push(points);
    let pop = 60
    if (document.getElementById("grungy").checked)
      pop *= 2
    let offset = 20 + stroke_width * 26;
    let numpaths = 20 + Math.random()*30;
    for (let s = 0; s < numpaths; s++) {
      let path = [];
      for (let c = 0; c < points.length; c++) {
        path.push([points[c][0] + xmut*(offset + (pop * (Math.random()-0.5))), points[c][1] + ymut*(offset + (pop * (Math.random()-0.5)))]);
      }
      offset += (Math.random()-0.5) * stroke_width;
      paths.push(path);
    }
    radius = (canvas.width > canvas.height)? canvas.width/2: canvas.height/2;
    angle = Math.random()*6.27;
    let x1 = radius * Math.cos(angle)+centx;
    let y1 = radius * Math.sin(angle)+centy;
    let x2 = radius * Math.cos(angle+3.14)+centx;
    let y2 = radius * Math.sin(angle+3.14)+centy;
    for (let f = 1; f < paths.length; f++) {
      let pts = paths[f];
      ctx.beginPath();
      ctx.lineWidth = 1 + Math.random() * stroke_width;
      let i = 0;
      for (; i < pts.length; i++) {
        x = pts[i][0]
        y = pts[i][1]
        if (i == 0) {
          x0 = x;
          y0 = y;
          ctx.moveTo(x, y);
        } else
        if (i % 3 == 0)
          ctx.bezierCurveTo(pts[i-2][0], pts[i-2][1], pts[i-1][0], pts[i-1][1], pts[i][0], pts[i][1]);
      }
      ctx.globalAlpha = (maxalpha * 0.1 + Math.random() * maxalpha * 0.75)
      ctx.stroke();
    }
  }
  ctx.restore()
  ctx.globalAlpha = document.getElementById("opacity").value/100
}

function strokes2 () {
  let increase = Math.PI * 2 / 40;
  let x = 0, y = 0, angle = 4.7;
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  let color = randomPick(getCurrentPalette()) // was paintcolor
  ctx.save()
  ctx.globalAlpha = document.getElementById("opacity").value/200
  let maxalpha = ctx.globalAlpha
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  let grunge = document.getElementById("grungy").checked
  let stroke_width = 11+ document.getElementById("featuresize").value/20
  let stroke_ct = +document.getElementById("number").value/400 + 1
  for (let t = 0; t < stroke_ct; t++) {
    let paths = [];
    let radius = Math.floor(Math.random() * 50) + 20;
    x = 0;
    y = 0;
    angle = Math.floor(Math.random() * 6.42);
    let centx = Math.random()*canvas.width/2;
    let centy = Math.random()*canvas.height/2;
    let edges = (9 * (Math.floor(Math.random()*6))+2);
    let maxradius = Math.random() * 5 + canvas.width/10;
    increase = Math.PI * 2/edges*0.52;
    points = [];
    bez = [];
    let xmut = -1;
    let ymut = -1;
    if (Math.random() < 0.5)
      xmut *= -1;
    if (Math.random() < 0.5)
      ymut *= -1;
    for (let i = 0; i < edges; i++) {
      centx += pet(canvas.width)//Math.random()*ctx.canvas.width;
      centy += pet(canvas.height)//Math.random()*ctx.canvas.height;
      radius = (Math.random() * maxradius) + maxradius * 0.5;
      x = radius * Math.cos(angle)+centx;
      y = radius * Math.sin(angle)+centy;
      points.push([x, y]);
      angle += increase;
    }
    paths.push(points);
    let pop = 60
    if (grunge)
      pop *= 2
    let offset = 50 + stroke_width * 50;
    let numpaths = 10 + Math.random()*30;
    for (let s = 0; s < numpaths; s++) {
      let path = [];
      for (let c = 0; c < points.length; c++) {
        path.push([points[c][0] + xmut*(offset + (pop * (Math.random()-0.5))), points[c][1] + ymut*(offset + (pop * (Math.random()-0.5)))]);
      }
      offset += (Math.random()-0.5) * stroke_width;
      paths.push(path);
    }
    radius = (canvas.width > canvas.height)? canvas.width/4: canvas.height/4;
    angle = Math.random()*6.27;
    let x1 = radius * Math.cos(angle)+centx;
    let y1 = radius * Math.sin(angle)+centy;
    let x2 = radius * Math.cos(angle+3.14)+centx;
    let y2 = radius * Math.sin(angle+3.14)+centy;
    for (let f = 1; f < paths.length; f++) {
      let pts = paths[f];
      ctx.beginPath();
      ctx.lineWidth = 1 + Math.random() * stroke_width;
      let i = 0;
      for (; i < pts.length; i++) {
        x = pts[i][0] + pet(13)
        y = pts[i][1] + pet(13)
        if (i == 0) {
          ctx.moveTo(x, y);
        } else
        if (i % 3 == 0)
          ctx.bezierCurveTo(pts[i-2][0], pts[i-2][1], pts[i-1][0], pts[i-1][1], pts[i][0], pts[i][1]);
      }
      if (grunge)
        ctx.strokeStyle = petColor(color, 81)
      else
        ctx.strokeStyle = petColor(color, 51)
      ctx.globalAlpha = (maxalpha * 0.1 + Math.random() * maxalpha * 0.2)
      ctx.stroke();
    }
  }
  ctx.restore()
  ctx.globalAlpha = document.getElementById("opacity").value/100
}

function strokesH () {
  let increase = Math.PI * 2 / 40;
  let x = 0, y = 0, angle = 4.7;
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  let color = randomPick(getCurrentPalette()) // was paintcolor
  ctx.save()
  ctx.globalAlpha = document.getElementById("opacity").value/200
  let maxalpha = ctx.globalAlpha
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  let grunge = document.getElementById("grungy").checked
  let stroke_width = 11 + document.getElementById("featuresize").value/10
  let stroke_ct = +document.getElementById("number").value/400 + 1
  let P = 121
  if (grunge)
    P *= 2
  for (let t = 0; t < stroke_ct; t++) {
    let paths = [];
    x = 0;
    y = 0;
    let centx = Math.random()*canvas.width/2;
    let centy = Math.random()*canvas.height/2;
    let edges =  (9 * (Math.floor(Math.random()*6))+2);
    points = [];
    let xmut = -1;
    let ymut = -1;
    if (Math.random() < 0.5)
      xmut *= -1;
    if (Math.random() < 0.5)
      ymut *= -1;
    for (let i = 0; i < edges; i++) {
      x = -10 + pet(P)
      y = Math.random()*ctx.canvas.height;
      points.push([x, y]);
      points.push([canvas.width/3+pet(P), y+pet(P*2)]);
      points.push([canvas.width*2/3+pet(P), y-pet(P*2)]);
      points.push([canvas.width+10+pet(10), y+pet(P)]);
    }
    paths.push(points);
    let pop = 10
    if (grunge)
      pop *= 2
    let offset = 10 + stroke_width * 4;
    let numpaths = 10 + Math.random() * 30;
    for (let s = 0; s < numpaths; s++) {
      let path = [];
      for (let c = 0; c < points.length; c++) {
        path.push([points[c][0] +pet(offset), points[c][1] + ymut*(pet(offset) + (pop * (Math.random()-0.5)))]);
      }
      //offset += (Math.random()-0.5) * 1;
      paths.push(path);
    }
    for (let f = 0; f < paths.length; f++) {
      let pts = paths[f];
      ctx.beginPath();
      ctx.lineWidth = 4 + Math.random() * stroke_width;
      x = pts[0][0] + pet(13)
      y = pts[0][1] + pet(13)
      ctx.moveTo(x, y);
      ctx.bezierCurveTo(pts[1][0], pts[1][1], pts[2][0], pts[2][1], pts[3][0], pts[3][1]);
      if (grunge)
        ctx.strokeStyle = petColor(color, 81)
      else
        ctx.strokeStyle = petColor(color, 51)
      ctx.globalAlpha = (maxalpha * 0.7 + Math.random() * maxalpha * 0.2)
      ctx.stroke();
    }
  }
  ctx.restore()
  ctx.globalAlpha = document.getElementById("opacity").value/100
}

function birds () {
  var increase = Math.PI * 2 / 40;
  let x = 0, y = 0
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let centerx = ctx.canvas.width / 2;
  let centery = ctx.canvas.height / 2;
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let birdradius = 3 + document.getElementById("featuresize").value/20
  let br = birdradius
  let bpet = birdradius/15
  let numshapes = 1 + Math.floor(document.getElementById("number").value/2500)
  let angle = Math.random() * 6.42;
  let m_mod = 2, t = 0;
  for (; t < numshapes; t++) {
    var petalpoints = [];
    var prepoints = [];
    var radius = 100;
    x = 0;
    y = 0;
    var x0 = x;
    var y0 = y;
    var centx = Math.random()*ctx.canvas.width+5;
    var centy = Math.random()*ctx.canvas.height+5;
    var edges = 13 * (Math.floor(Math.random()*7)+4);
    var maxradius = Math.random() * canvas.width/3 + canvas.height/3;
    var increase = Math.PI * 2/edges*0.98;
    var points = [];
    var bez = [];
    var d_angle = angle;
    for (var i = 0; i < edges; i++) {
      if (i % 3 == 0)
        radius = (Math.random() * maxradius) + maxradius * 0.8;
      else
        radius = maxradius * 1.2;
      x = radius * Math.cos(d_angle)+centx;
      y = radius * Math.sin(d_angle)+centy;
      points.push([x, y]);
      x = (radius*1.3) * Math.cos(d_angle)+centx;
      y = (radius*1.3) * Math.sin(d_angle)+centy;
      prepoints.push([x, y]);
      d_angle += increase;
    }
    var i = 0;
    for (; i < points.length; i++) {
      x = points[i][0];
      y = points[i][1];
      var prex = prepoints[i][0];
      var prey = prepoints[i][1];
      if (i == 0) {
        x0 = x;
        y0 = y;
        ctx.moveTo(x, y);
        petalpoints.push([prex, prey]);
      } else
      if (i % 3 == 0) {
        petalpoints.push([points[i][0], points[i][1]]);
      }
    }
    
    i = 0;
    for(; i < petalpoints.length; i++) {
      centx = petalpoints[i][0];
      centy = petalpoints[i][1];
      edges = 12;
      increase = Math.PI * 2/edges*0.98;
      d_angle =  angle + (Math.random() - 0.5) * 1.5;
      var ppoints = [];
      var cents = [];
      
      birdradius = br +  Math.random() * 0.3 * br;
      for (var p = 0; p < edges; p++) {
        radius = birdradius + Math.random() * 0.5 * birdradius;
        if (p === 6) // 6
          radius = birdradius * 1.7 + pet(1);
        if ((p === 3 || p === 9) && m_mod === 2)
          radius = birdradius * (4.5 + Math.random()/3);
        if (p === 5 || p === 7)
          radius = birdradius * (0.2 + Math.random()/3);
        if (p === 2 || p === 10)
          radius = birdradius * (1.0 + Math.random()/3);
        if (p === 1 || p === 11)
          radius = birdradius * (0.05 + Math.random()/3);
        if (p == 0)
          radius = birdradius * (0.6 + Math.random()/3);
        if (p === 4 || p === 8) {
          if (Math.random() > 0.8)
            radius = birdradius * 0.6;
          else
            radius = birdradius * 1.2;
        }
        if (Math.random() < 0.1) {
          if (p === 3 || p === 9 || p == 2 || p == 10)
            radius = birdradius * (1.2 + Math.random()/3);
        }
        x = (radius+pet(8)) * Math.cos(d_angle + pet(bpet)/100)+centx;
        y = (radius+pet(8)) * Math.sin(d_angle + pet(bpet)/100)+centy;
        ppoints.push([x, y]);
        d_angle += increase;
      }
      ctx.beginPath();
      var j = 0;
      for (;j < ppoints.length; j++) {
        x = ppoints[j][0];
        y = ppoints[j][1];
        if (j == 0) {
          x0 = x;
          y0 = y;
          ctx.moveTo(x, y);
        } else
        if (j % m_mod === 0) {
          ctx.bezierCurveTo(ppoints[j-2][0] + pet(bpet), ppoints[j-2][1] + pet(bpet), ppoints[j-1][0] + pet(bpet), ppoints[j-1][1] + pet(bpet), ppoints[j][0], ppoints[j][1]);
        }
      }
      ctx.bezierCurveTo(ppoints[j-2][0], ppoints[j-2][1], ppoints[j-1][0], ppoints[j-1][1], x0, y0);
      ctx.closePath();
      ctx.fill();
    }
  }
}

function rothko () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let w = canvas.width
  let ch = canvas.height
  let rows = 3
  let margin = 16 + Math.random() * rows * 9
  let gap = margin/4
  let oc = ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let op = document.getElementById("opacity").value
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let grunge = document.getElementById("grungy").checked
  let numshapes = 2 + (Math.floor(Math.random() * 2))
  let colors = shuffle(['#cc0000', '#bb4000', '#a000a0', '#0000aa','#004099', '#007020', '#F8A500', '#d8c500', '#dddddd', '#300000','#444444','#666666'])
  let fcolors = []
  let i = 0
  for (; i < numshapes; i++)
    fcolors.push(randomPick(colors))
  let bcolors = ['#300000','#444444', '#dddddd', '#666666']
  i = 0
  for (; i < fcolors.length; i++)
    bcolors.push(fcolors[i])
  ctx.fillStyle  = randomPick(bcolors)
  ctx.fillRect(0, 0, w, ch)
  let hts = new Array(numshapes)
  let h = 0, H = ch - (margin/numshapes)
  for (; h < numshapes; h++) {
    let part = 61+ Math.random() * H/numshapes
    hts[h] = part
    H -= part
  }
  if (H > margin)
    hts[1] += H - margin
  if (H < 0)
    hts[0] -= H
  let shapeheight = w/numshapes - (margin/numshapes)
  i = 0, g = 0
  let top = margin
  let m0 = margin
  let marvar = w/24
  for (; i < numshapes; i++) {
    let points = []
    shapeheight = hts[i]
    margin += (Math.random() * marvar)
    ctx.beginPath();
    ctx.moveTo(margin+pet(9), top+pet(9))
    ctx.lineTo(w-margin+pet(9), top+pet(9))
    ctx.lineTo(w-margin+pet(9), top+shapeheight-margin+pet(9))
    ctx.lineTo(margin+pet(9), top+shapeheight-margin+pet(9))
    points.push(margin+pet(9), top+pet(9))
    points.push(w-margin+pet(9), top+pet(9))
    points.push(w-margin+pet(9), top+shapeheight-margin+pet(9))
    points.push(margin+pet(9), top+shapeheight-margin+pet(9))
    ctx.closePath()
    ctx.fillStyle = petColor(randomPick(fcolors), 30)
    ctx.fill()
    ctx.globalAlpha = document.getElementById("opacity").value/180
    frameRect(points, ctx.fillStyle, margin)
    ctx.globalAlpha = document.getElementById("opacity").value/100
    g += gap
    top += shapeheight
    margin = m0
  }
  let functions = ["dotblur", /*"jaggyblur", "dirblur"*/]
  document.getElementById("featuresize").value = 45 + pet(15)
  document.getElementById("opacity").value = 25 + pet(15)
  ctx.fillStyle = petColor(randomPick(bcolors), 30)
  dissOver()
  let f = randomPick(functions)
  document.getElementById("opacity").value = 20 + pet(10)
  window[f](canvas)
  document.getElementById("featuresize").value = 20 + Math.random() * 5
  f = randomPick(functions)
  window[f](canvas)
  document.getElementById("featuresize").value = 9 + Math.random() * 5
  dissOver()
  f = randomPick(functions)
  window[f](canvas)
  document.getElementById("opacity").value = 20 + pet(10)
  randomPick(getCurrentPalette()) // was paintcolor =  "#000000"
  haze()
  document.getElementById("opacity").value = op
  randomPick(getCurrentPalette()) // was paintcolor = oc
  refreshMode()
}

function testPattern () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.fillStyle = randomColor()
  ctx.fillRect(0,0,canvas.width, canvas.height)
  ctx.fillStyle = randomGradient(canvas);
  drawCircleAt(ctx,canvas.width/2, canvas.height/2, canvas.width/3)
  //ctx.fillRect(0,0,canvas.width, canvas.height)
  grid()
  rcc()
  grid()
  rc()
}

function grid () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let w = canvas.width, h = canvas.height
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineWidth = Math.floor(1 +  document.getElementById("featuresize").value/20)
  let spacing = Math.floor(1 + (document.getElementById("number").value/200))
  let ratio = 1
  if (document.getElementById("grungy").checked)
    ratio = 3
  spacing += ctx.lineWidth * 2
  let i = 0
  let margin = 40
  let maxh = (h - (2 * margin))/spacing
  let y = margin
 /* for (; i < maxh; i++) { // horizontal
    ctx.beginPath()
    ctx.moveTo(margin, y)
    ctx.lineTo(w-margin, y)
    ctx.closePath()
    ctx.stroke()
    y += spacing
  }*/
  i = 0
  maxh = (w - (2 * margin))/(spacing*ratio)
  let x = margin
  for (; i < maxh; i++) {
    ctx.beginPath()
    ctx.moveTo(x, margin)
    ctx.lineTo(x, h-margin)
    ctx.closePath()
    ctx.stroke()
    x += spacing*ratio
  }
}

function rays () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let D =  (5 + Math.floor(document.getElementById("featuresize").value/50))
  let grunge = document.getElementById("grungy").checked
  let W = canvas.width
  let H = canvas.height
  ctx.globalAlpha = document.getElementById("opacity").value/200
  //clip()
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineWidth = 0.25
  let x = Math.random() * W, y = Math.random() * H
  let w = 2 +Math.random()*14
  let p = 1+D*3
  let i = 0
  let s = 0
  let x2 = 0, y2 = 0
  while (s < 100) {
    x2 = (Math.random() - 0.5) * W * 4
    y2 = (Math.random() - 0.5) * W * 4
    ctx.beginPath()
    ctx.moveTo(x + pet(p), y+pet(p))
    ctx.lineTo(x2, y2)
    ctx.closePath()
    ctx.stroke()
    
    y += pet(89)
    x += pet(89)
    s++
  }
}

function curveAcross () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let D =  (5 + Math.floor(document.getElementById("featuresize").value/80))
  let grunge = document.getElementById("grungy").checked
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineWidth = 12
  ctx.lineCap = "round"
  let W = canvas.width
  let H = canvas.height
  
  let x = 50, y = 100
  let x2 = W - 50, y2 = 100
  let i = 0
  for (; i < 50; i++) {
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.bezierCurveTo(W/3+pet(100), y+pet(450), 2*W/3+pet(100), y+pet(450), x2, y2);
    ctx.stroke();
    y += 100
    y2 += 100
    if (y > H)
      break;
  }
}


function roadmap () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let D =  (5 + Math.floor(document.getElementById("featuresize").value/80))
  let grunge = document.getElementById("grungy").checked
  let angledelta = 0.4
  if (grunge)
    angledelta = 0.8
  let W = canvas.width
  let H = canvas.height
  let colors = ['red', 'blue', 'green', 'yellow',]// 'orange', 'purple']
  ctx.lineCap = "round"
  let x = Math.random() * W, y = Math.random() * H
  let p = 1+D*1
  let i = 0
  let s = 0
  let angle = Math.random()*2*Math.PI;
  let stepsize = 1
  let w = 1 + Math.random()*D/10
  let points = []
  lavalamp()
  let numroads = 5 + Math.floor(Math.random() * 5)
  let k = 0
  while (k < numroads) {
    points = []
    s = 0
    ctx.lineWidth = 2 + Math.floor(10 * Math.random())
    ctx.fillStyle = randomPick(colors)
    x = Math.random() * W, y = Math.random() * H
    while (s < 3000) {
      points.push([x,y])
      x += 5 * Math.cos(angle)
      y += 7 * Math.sin(angle)
      s++
      angle += (Math.random()-0.51) * angledelta
    }
    i = 1
    ctx.beginPath()
    ctx.moveTo(points[0][0], points[0][1])
    for(; i < points.length; i++) {
      ctx.lineTo(points[i][0], points[i][1])
    }
    ctx.strokeStyle = randomPick(colors)
    ctx.globalAlpha = 0.4
    ctx.stroke();
    
    // dots on raods
    let rt = ctx.lineWidth * 0.6
    let spacing = randomPick([23, 91, 15, 11, 31, 1000])
    i = 0
     for(; i < points.length; i++) {
      if (i % spacing === 1) {
        ctx.strokeStyle = ("#303030")
        ctx.lineWidth = 3
        ctx.beginPath()
        ctx.arc(points[i][0], points[i][1], rt, 0, 2* Math.PI)
        ctx.globalAlpha = 0.8
        ctx.stroke()
        ctx.fillStyle = "#ffffff"
        ctx.fill()
      }
    }
    // route numbers
    rt = ctx.lineWidth * 4
    spacing = randomPick([120, 91, 150, 1000])
    let routes = [11, 21,31, 17, 6, 89, 50, 67, 3, 10, 104, 24, 33, 2, 6, 44, 128, 95]
    let rtext = randomPick(routes)
    i = 0
     for(; i < points.length; i++) {
      if (i > 0 && i % spacing === 0) {
        ctx.strokeStyle = ("#303030")
        ctx.lineWidth = 3
        ctx.beginPath()
        ctx.ellipse(points[i][0], points[i][1], rt*1.5, rt, 0, 0, 2* Math.PI)
        ctx.globalAlpha = 0.8
        ctx.stroke()
        ctx.fillStyle = "#ffffff"
        ctx.fill()
        ctx.textBaseline = "bottom";
        ctx.textalign = 'left'
        ctx.fillStyle = "#000000"
        ctx.font = "12px helvetica";
        let d = ctx.measureText(rtext).width/2
        ctx.fillText (rtext, points[i][0]-d, points[i][1]+rt/2)
      }
    }
   
    k++
  }
  ctx.globalAlpha = 0.8

  k = 0
  for (; k < 19; k++) {
    angle = pet(2)/6//Math.random() * Math.PI * 2
    //placeText(randomPick(placenames), angle)
  }
  
  // dots
   i = 0
  for (; i < 31; i++) {
    ctx.fillStyle = randomPick(colors)
    ctx.beginPath()
    x = Math.random() * W, y = Math.random() * H
    ctx.moveTo(x, y)
    ctx.arc(x, y, Math.random() * 9 + 3 , 0, Math.PI * 2)
    ctx.fill()
    ctx.fillStyle = "#333333"
    ctx.fillText(capitalize(randomWord(Math.random() > 0.5)), x + 20, y+6)
    
  }
  // blue grid lines
  ctx.globalAlpha = document.getElementById("opacity").value / 200
  let yoff = 2*(Math.random()-0.5) * 45
  let div = (2 + Math.random() +3)
  let d = W/div
  y = 2//24 + Math.random() + 40
  i = 0
  for (; i < W/d; i++) {
    ctx.lineWidth = 2 + Math.floor(5 * Math.random())
    ctx.strokeStyle = "#2040ff"
    ctx.beginPath()
    ctx.moveTo(0, y)
    ctx.lineTo(W, y+yoff)
    ctx.stroke();
    y += d
  }
  i = 0, x = 0
  for (; i < H/d; i++) {
    ctx.lineWidth = 2 + Math.floor(3 * Math.random())
    ctx.strokeStyle = "#2040ff"
    ctx.beginPath()
    ctx.moveTo(x, 0)
    ctx.lineTo(x+yoff, H)
    ctx.stroke();
    x += d
  }
}

function lavalamp () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let increase = Math.PI * 2 / 40;
  let x = 350, y = 270, angle = 4.7;
  //var centerx = ctx.canvas.width / 2;
  //var centery = ctx.canvas.height / 2;
  let colors = shuffle(['red', 'green', 'yellow', 'blue'])
  colors = shuffle(['#ffb3ba', '#baffc9', '#ffffba', '#bae1ff'])
  let centers = shuffle([[0, canvas.height/4],
                 [3 * canvas.width/4, canvas.height/2],
                 [canvas.width/5, 3*canvas.height/4],
                 [canvas.width, canvas.height]])
  ctx.globalAlpha = document.getElementById("opacity").value/100;
  ctx.lineCap = "round";
  ctx.lineJoin = 'round';
  let centx = Math.random()*canvas.width/2;
  let centy = Math.random()*canvas.height/2;
  let numshapes = Math.random() * 2 + 2;
  for (var t = 0; t < numshapes; t++) {
    var radius = Math.floor(Math.random() * 100) + 20;
    x = 0;
    y = 0;
    centx = centers[t][0]
    centy = centers[t][1]
    var x0 = x;
    var y0 = y;
    angle = Math.floor(Math.random() * 6.42);
    let edges = 7 * (Math.floor(Math.random()*3)+3);
    let maxradius = canvas.width/2;
    increase = Math.PI * 2/edges*0.98;
    points = [];
    bez = [];
    for (var i = 0; i < edges; i++) {
      radius = (Math.random() * maxradius/2) + maxradius;
      x = radius * Math.cos(angle)+centx;
      y = radius * Math.sin(angle)+centy;
      points.push([x, y]);
      angle += increase;
    }
    ctx.beginPath();
    ctx.fillStyle= colors[t];
    //ctx.globalAlpha = 0.2;
    var i = 0;
    for (; i < points.length; i++) {
      x = points[i][0];
      y = points[i][1];
      if (i == 0) {
        x0 = x;
        y0 = y;
        ctx.moveTo(x, y);
      } else
      if (i % 3 == 0)
        ctx.bezierCurveTo(points[i-2][0], points[i-2][1], points[i-1][0], points[i-1][1], points[i][0], points[i][1]);
    }
    ctx.bezierCurveTo(points[i-2][0], points[i-2][1], points[i-1][0], points[i-1][1], x0, y0);
    
    ctx.lineWidth = 2 + Math.random()*13;
    if (Math.random() < 0.33)
      ctx.setLineDash([ctx.lineWidth*2, ctx.lineWidth*2]);
    else
      ctx.setLineDash([]);
    ctx.strokeStyle = randomPick(colors);
  //  ctx.globalAlpha = 0.4;
    ctx.stroke()
    ctx.closePath();
  //  ctx.globalAlpha = 0.2;
    ctx.fill();
    ctx.setLineDash([]);
  }
}

function cracklelines () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let alt = document.getElementById("grungy").checked
  let W = canvas.width
  let H = canvas.height
  let cx = W/2, cy = H/2
  let fs = 2 + +document.getElementById("featuresize").value
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.imageSmoothingQuality = "high"
  ctx.strokeStyle = randomPick(getCurrentPalette())
  ctx.lineCap = "square"
  let i = 0, j = 0
  let nx = 0, ny = 0, x0, y0, NOPE = false
  let x = Math.random() * W/2, y = Math.random() * H/2//, a
  a = Math.PI*2
  for (; i < 99; i++) {
    NOPE = false
    x = Math.floor(Math.random() * W)
    y = Math.floor(Math.random() * H)
    j = 0
    let inc = 1
    let xinc = 0.2+(Math.random()), yinc = 0.2+(Math.random())
    
    if (Math.random() > 0.5) xinc *= -1
    if (Math.random() > 0.5) yinc *= -1
    if (alt)
      fs*=0.95
    ctx.lineWidth = fs
    ctx.beginPath()
    ctx.moveTo(x,y)
    let wmax = 200//20*Math.random()*fs//(xinc*yinc)
    for (; j < wmax; j++) {
      x += xinc
      y += yinc
      ctx.lineTo(x,y)
      nx = x + xinc*2;
      ny = y + yinc*2;
      if (pixelIsColor(nx, ny, ctx.strokeStyle) || !inBounds(nx,ny,-100,-100,W+100,H+100)){
        NOPE = true
        break;
      }
    }
    if (!NOPE)
      ctx.stroke()
  }
}

function crackle () { // curves
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let alt = document.getElementById("grungy").checked
  let fs = 2+ +document.getElementById("featuresize").value/2

  let W = canvas.width
  let H = canvas.height
  let cx = W/2, cy = H/2
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let color = randomPick(getCurrentPalette())
  ctx.strokeStyle = color
  ctx.lineJoin = "miter"
  ctx.miterLimit = 100
  let R = Math.floor(W*0.4)
  let i = 0, j = 0
  let nextx = 0, nextY = 0
  let x = Math.random() * W/2, y = Math.random() * H/2
  let a = 0//Math.PI*2 * Math.random()
  let N = 32
  let flip = false
  let lw = fs, NOPE = false
  ctx.lineWidth = lw

  let ba = a
  let ea =  ba += Math.PI/1800, inc = 1
  let BA = a
  for (; i < N; i++) {
    R = R + pet(R*0.5)
    x = Math.floor(Math.random() * W)
    y = Math.floor(Math.random() * H)
    j = 0
    let ba = a
    let ea =  ba += Math.PI/180, inc = 1
    if (alt)
      lw*=0.94
    ctx.lineWidth = lw
    ctx.beginPath()
    for (; j < 380; j++) {
      ctx.ellipse(x,y,R,R,a,ba,ea)
      ba = ea
      ea += Math.PI/180
      // point on a circle
      nextx = (R) * Math.cos(ea+Math.PI/180*2)+x;
      nexty = (R) * Math.sin(ea+Math.PI/180*2)+y;
      let nx = (R) * Math.cos(ea+Math.PI/180)+x;
      let ny = (R) * Math.sin(ea+Math.PI/180)+y;
      if (pixelIsColor(nextx, nexty, color) || pixelIsColor(nx, ny, color) || isOff(nx,ny,W,H)) {
        break;
      }
    }
    ctx.stroke()
    if (flip)
      flipV()
    else
      rc()
    flip != flip
    ctx.strokeStyle = color
  }
}

function crackle_OG () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let alt = document.getElementById("grungy").checked
  let W = canvas.width
  let H = canvas.height
  let cx = W/2, cy = H/2
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.imageSmoothingQuality = "high"
  ctx.strokeStyle = "#000000"
  ctx.lineCap = "round"
  ctx.lineJoin = "round"
  ctx.fillStyle = "#ffffff"
  let R = Math.floor(W*0.69)
  let i = 0, j = 0
  let nextx = 0, nextY = 0
  let x = Math.random() * W/2, y = Math.random() * H/2
  let a = Math.PI*2
  let N = 24,  ct = 0
  let flip = false
  for (; i < N; i++) {
    x = Math.floor(Math.random() * W)/2
    y = Math.floor(Math.random() * H)
    j = 0
    let ba = a
    let ea =  ba += Math.PI/1800, inc = 1
    ctx.lineWidth = 1
    ctx.beginPath()
    for (; j < 3600; j++) {
      if (alt)
        ctx.lineWidth = 2
      else
        ctx.lineWidth = 1
      ctx.ellipse(x,y,R,R,a,ba,ea)
      ba = ea
      ea += Math.PI/1800
      // point on a circle
      nextx = (R) * Math.cos(ea+Math.PI/1800*2)+x;
      nexty = (R) * Math.sin(ea+Math.PI/1800*2)+y;
      let nx = (R) * Math.cos(ea+Math.PI/1800)+x;
      let ny = (R) * Math.sin(ea+Math.PI/1800)+y;
      if (pixelIsDark(nextx, nexty) || pixelIsDark(nx, ny) || (isOff(nx,ny,W,H))) {
        break;
      }
    }
    ctx.stroke()
    if (flip)
      flipV()
    else
      rc()
    flip != flip
  }
  if (i > 3)
    R *= 0.98
}


function isOff (x,y,W,H) {
  return ((x<=100 || x>W+100) || (y<-100||y>H+100))
}

function pixelIsColor (x, y, color) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let data = ctx.getImageData(x,y,1,1)
  i = 0, len = 1, w = 1, h = 1, d = 500
  for (;i < len; i++) {
    x = i % w
    if (x === 0)
      y += 1
    let px = data.data.slice(i*4, i*4+4)
    d = colorDistance(rgbtohex(px[0],px[1],px[2]), color)
    if (d < 10) {
      return true
    }
  }
  return false
}

function pixelIsDark (x, y) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let data = ctx.getImageData(x,y,1,1)
  i = 0, len = 1, w = 1, h = 1
  for (;i < len; i++) {
    x = i % w
    if (x === 0)
      y += 1
    d = Math.random() * w
    let px = data.data.slice(i*4, i*4+4)
    brightness = (px[0]+px[1]+px[2])/(255*3)
    if (brightness < 0.5) {
      return true
    }
  }
  return false
}

function walk () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let D =  (5 + Math.floor(document.getElementById("featuresize").value/80))
  let grunge = document.getElementById("grungy").checked
  let angledelta = 0.1
  if (grunge)
    angledelta = 0.8
  let W = canvas.width
  let H = canvas.height
  ctx.globalAlpha = document.getElementById("opacity").value/100
 // clip()
 ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
 ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  let x = 2, y = 100
  let p = 1+D*1
  let i = 0
  let s = 0
  let angle = 0//Math.random()*2*Math.PI;
  let stepsize = 3
  let w = 1 + Math.random()*D/10
  while (s < 2000) {
    w = 1 + Math.random()*D/25
    ctx.beginPath()
    if (s > 100  && s < 800 && Math.random() > 0.96) {
      D *=1.03
      p = 1+D/2
      stepsize = 2
    } else
    if (s > 800 && Math.random() > 0.9) {
      D /=1.03
      p = 1+D
      stepsize = 1
    }
    angle += (Math.random()-0.5) * angledelta
    ctx.moveTo(x + pet(p), y+pet(p))
    ctx.lineTo(x + w + pet(p), y +pet(p))
    ctx.lineTo(x + w + pet(p), y+w +pet(p))
    ctx.lineTo(x + pet(p), y+w+pet(p))
    ctx.stroke()
    //ctx.closePath()
   //ctx.fill()
    x += 1 * Math.cos(angle)
    y += 1 * Math.sin(angle)
    w += 0.001
    s++
  }
}

function frame () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let D =  (5 + Math.floor(document.getElementById("featuresize").value/4))
  let grunge = document.getElementById("grungy").checked
  let W = canvas.width
  let H = canvas.height
  ctx.globalAlpha = document.getElementById("opacity").value/100
 // clip()
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let x = -1, y = -1
  let w = 6 +Math.random()*14
  let p = 6+D*1.2
  let i = 0
  while (y < canvas.height) {
    w = D +Math.random()*D/2
    ctx.beginPath()
    ctx.moveTo(x + pet(p), y+pet(p))
    ctx.lineTo(x + w + pet(p), y +pet(p))
    ctx.lineTo(x + w + pet(p), y+w +pet(p))
    ctx.lineTo(x + pet(p), y+w+pet(p))
    ctx.closePath()
    ctx.fill()
    
    ctx.beginPath()
    ctx.moveTo(W - pet(p), y+pet(p))
    ctx.lineTo(W - w + pet(p), y +pet(p))
    ctx.lineTo(W - w + pet(p), y+w +pet(p))
    ctx.lineTo(W - pet(p), y+w+pet(p))
    ctx.closePath()
    ctx.fill()
    y += 2
  }
  x = 0, y = -1
  while (x < canvas.width) {
    w = D +Math.random()*D/2
    ctx.beginPath()
    ctx.moveTo(x + pet(p), y+pet(p))
    ctx.lineTo(x + w + pet(p), y +pet(p))
    ctx.lineTo(x + w + pet(p), y+w +pet(p))
    ctx.lineTo(x + pet(p), y+w+pet(p))
    ctx.closePath()
    ctx.fill()
    
    ctx.beginPath()
    ctx.moveTo(x - pet(p), H-pet(p))
    ctx.lineTo(x - w + pet(p), H -pet(p))
    ctx.lineTo(x - w + pet(p), H-w -pet(p))
    ctx.lineTo(x - pet(p), H-w-pet(p))
    ctx.closePath()
    ctx.fill()
    x += 2
  }
  ctx.restore()
}

function roundedFrame (n) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let off = document.createElement('CANVAS')
  let ctxoff = off.getContext("2d");
  let D =  (5 + Math.floor(document.getElementById("featuresize").value/3))
  if (n)
    D = n
  let grunge = document.getElementById("grungy").checked
  let W = canvas.width
  let H = canvas.height
  off.height = H
  off.width = W
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.save()
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let radius = 36
  //if (grunge)
  //  radius *= 2
  let x = D, y = D
  let w = W - 2*D, h = H - 2*D
  var r = x + w;
  var b = y + h;
  ctxoff.drawImage(canvas, 0, 0)
  ctx.clearRect(0, 0, W, H)
  ctx.fillRect(0,0,W,H)
  ctx.beginPath();
  ctx.lineWidth="4";
  ctx.moveTo(x+radius, y);
  ctx.lineTo(r-radius, y);
  ctx.quadraticCurveTo(r, y, r, y+radius);
  ctx.lineTo(r, y+h-radius);
  ctx.quadraticCurveTo(r, b, r-radius, b);
  ctx.lineTo(x+radius, b);
  ctx.quadraticCurveTo(x, b, x, b-radius);
  ctx.lineTo(x, y+radius);
  ctx.quadraticCurveTo(x, y, x+radius, y);
  ctx.closePath()
  ctx.clip()
  ctx.globalAlpha = 1
  ctx.clearRect(0, 0, W, H)
  ctx.drawImage(off, 0, 0)
  ctx.restore()
  let mode = document.getElementById("mode").value
  ctx.globalCompositeOperation = "destination-over"
  //fill()
  ctx.globalCompositeOperation = mode
}

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
}

function mockparagraphWords (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let fs = 2.6*(4 + document.getElementById("featuresize").value/10)
  alpha = document.getElementById("opacity").value
  document.getElementById("opacity").value = 50
  let W = canvas.width
  let H = canvas.height
  let x = 20 + Math.random()*W * 0.5
  let y = 20 + Math.random() * 3*H/4
  let wrap = randomPick([3,4,5])
  let N = 3 + Math.floor(Math.random() * 14)
  let stops = [".", ".", ".",". ",".", ".","?", "!", ":"]
  let stopwords = ["a","adeus","agora","ainda","alem","algo","ali","além","ambas","ambos","ano","anos","antes","ao","aonde","aos","apoio","apos","após","aqui","as","assim","atrás","até","aí","baixo","bem","boa","boas","bom","bons","breve","cada","cedo","cento","cima","cinco","coisa","com","como","cuja","cujas","cujo","cujos","custa","cá","da","dar","das","de","dela","delas","dele","deles","desde","dessa","desse","desta","deste","deve","devem","deverá","dez","dia","diz","dizem","dizer","do","dois","dos","doze","duas","dá","dão","dúvida","e","ela","elas","ele","eles","em","entao","entre","então","era","eram","essa","essas","esse","esses","esta","estar","estará","estas","este","estes","estou","está","estás","estão","eu","falta","fará","favor","faz","fazem","fazer","fazes","fazia","faço","fez","fim","final","foi","fomos","for","fora","foram","forem","forma","fosse","foste","fui","geral","grupo","ha","haja","hajam","havia","hei","hoje","hora","horas","houve","há","hão","ir","irá","isso","ista","iste","isto","já","lado","lhe","lhes","local","logo","longe","lugar","lá","maior","mais","mal","mas","me","meio","menor","menos","meses","mesma","mesmo","meu","meus","mil","minha","muito","máximo","mês","na","nada","nao","nas","nem","nessa","nesse","nesta","neste","no","noite","nome","nos","nossa","nosso","nova","novas","nove","novo","novos","num","numa","numas","nunca","nuns","não","nível","nós","número","o","obra","oito","onde","ontem","onze","os","ou","outra","outro","para","parte","pegar","pela","pelas","pelo","pelos","perto","pode","podem","poder","poderá","podia","pois","ponto","por","posso","pouca","pouco","povo","pôde","põe","põem","quais","qual","que","quem","quer","quero","questão","quáis","quê","relação","sabe","sabem","saber","se","sei","seis","seja","sejam","sem","sendo","ser","serei","seria","será","serão","seríamos","sete","seu","seus","sexta","sexto","sim","sob","sobre","sois","somos","sou","sua","suas","são","sétima","sétimo","só","tal","também","tanta","tanto","tarde","te","tem","temos","tempo","tenha","tenho","tens","tente","ter","terei","teria","terá","terão","teu","teus","teve","tinha","tipo","tive","tiver","toda","todas","todo","todos","treze","três","tu","tua","tuas","tudo","tão","tém","têm","um","uma","umas","uns","usa","usar","vai","vais","valor","veja","vem","vens","ver","vez","vezes","vindo","vinte","você","vocês","vos","vossa","vosso","vários","vão","vêm","vós","zero","à","às","área","é","éramos","és"]
  let i = 0
  for (; i < 50; i++)
    stopwords.push(Math.floor(10+Math.random()*100))
  //["is","a","the","to","on","in","at","but", "and", "or","was","it","for","by","this","that"]
  LASTCLICK[0] = x
  LASTCLICK[1] = y
  i = 0
  for(;i < N; i++) {
    if (i > 0 && i % wrap === 0 || (LASTCLICK[0]+fs*3) > W) {
      LASTCLICK[0] = x
      LASTCLICK[1] += fs*2
    }
    let s = ""
    if (Math.random() > 0.8)
      s = randomPick(stops)
    let word = randomWord(true)
    if (i === 0)
      word = capitalize(word)
    placeTextAt(word+s) // str.charAt(0).toUpperCase() + str.slice(1)
    if (Math.random() > 0.5) {
      placeTextAt(randomPick(stopwords))
      i++
      if (i > 0 && i % wrap === 0 || (LASTCLICK[0]+fs*3) > W) {
        LASTCLICK[0] = x
        LASTCLICK[1] += fs*2
      }
    }
  }
  placeTextAt(randomPick(stops))
  document.getElementById("opacity").value = alpha
}

function mockparagraphScript (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let fs = 2.6*(4 + document.getElementById("featuresize").value/10)
  alpha = document.getElementById("opacity").value
  document.getElementById("opacity").value = 50
  let W = canvas.width
  let H = canvas.height
  let x = 20 + Math.random()*2*W/3
  let y = 20 + Math.random() * 3*H/4
  let wrap = randomPick([5,6,8])
  let N = 3 + Math.floor(Math.random() * 23)
  LASTCLICK[0] = x
  LASTCLICK[1] = y
  let i = 0
  for(;i < N; i++) {
    if (i > 0 && i % wrap === 0 || (LASTCLICK[0]+fs*3) > W) {
      LASTCLICK[0] = x
      LASTCLICK[1] += fs*2
    }
    script()
  }
  document.getElementById("opacity").value = alpha
}

function pageOfBook (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let alt  = document.getElementById("grungy").checked
  let W = canvas.width
  let H = canvas.height
  let pad = W/10, PW = W - pad*2
  let x = pad
  let y = pad
  let wrap = randomPick([3,4,5])
  let N = 3 + Math.floor(Math.random() * 14)
  let stops = [".", ".", ".",". ",".",". ",".", ".","?", "!"]
  let stopwords = ["a","adeus","agora","ainda","alem","algo","ali","além","ambas","ambos","ano","anos","antes","ao","aonde","aos","apoio","apos","após","aqui","as","assim","atrás","até","aí","baixo","bem","boa","boas","bom","bons","breve","cada","cedo","cento","cima","cinco","coisa","com","como","cuja","cujas","cujo","cujos","custa","cá","da","dar","das","de","dela","delas","dele","deles","desde","dessa","desse","desta","deste","deve","devem","deverá","dez","dia","diz","dizem","dizer","do","dois","dos","doze","duas","dá","dão","dúvida","e","ela","elas","ele","eles","em","entao","entre","então","era","eram","essa","essas","esse","esses","esta","estar","estará","estas","este","estes","estou","está","estás","estão","eu","falta","fará","favor","faz","fazem","fazer","fazes","fazia","faço","fez","fim","final","foi","fomos","for","fora","foram","forem","forma","fosse","foste","fui","geral","grupo","ha","haja","hajam","havia","hei","hoje","hora","horas","houve","há","hão","ir","irá","isso","ista","iste","isto","já","lado","lhe","lhes","local","logo","longe","lugar","lá","maior","mais","mal","mas","me","meio","menor","menos","meses","mesma","mesmo","meu","meus","mil","minha","muito","máximo","mês","na","nada","nao","nas","nem","nessa","nesse","nesta","neste","no","noite","nome","nos","nossa","nosso","nova","novas","nove","novo","novos","num","numa","numas","nunca","nuns","não","nível","nós","número","o","obra","oito","onde","ontem","onze","os","ou","outra","outro","para","parte","pegar","pela","pelas","pelo","pelos","perto","pode","podem","poder","poderá","podia","pois","ponto","por","posso","pouca","pouco","povo","pôde","põe","põem","quais","qual","que","quem","quer","quero","questão","quáis","quê","relação","sabe","sabem","saber","se","sei","seis","seja","sejam","sem","sendo","ser","serei","seria","será","serão","seríamos","sete","seu","seus","sexta","sexto","sim","sob","sobre","sois","somos","sou","sua","suas","são","sétima","sétimo","só","tal","também","tanta","tanto","tarde","te","tem","temos","tempo","tenha","tenho","tens","tente","ter","terei","teria","terá","terão","teu","teus","teve","tinha","tipo","tive","tiver","toda","todas","todo","todos","treze","três","tu","tua","tuas","tudo","tão","tém","têm","um","uma","umas","uns","usa","usar","vai","vais","valor","veja","vem","vens","ver","vez","vezes","vindo","vinte","você","vocês","vos","vossa","vosso","vários","vão","vêm","vós","zero","à","às","área","é","éramos","és"]
  let i = 0
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let fs = randomPick([12,18,24])//12 + document.getElementById("featuresize").value/25
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle'
  let w = 0, text = "", s = ""
  ctx.font = "100 "+(fs)+"pt Georgia"
  let j = 0
  for (; j < 40; j++) {
    text = "", para = ""
    w = 0, i = 0
    if (j === 0 || Math.random() > 0.9) {
      y += fs*1.5
      para = "     "
      CAP = true
    }
    if (y > H - pad)
      break
    while (w < PW*0.77) {
      s = ""
      s += para
      if (Math.random() > 0.5) {
        if (CAP)
          s += capitalize(randomWord(true))
        else
          s += randomWord(true)
        CAP = false
      } else {
        if (CAP)
          s += capitalize(randomPick(stopwords))
        else
          s += randomPick(stopwords)
        CAP = false
      }
      if (Math.random() > 0.8) {
        CAP = true
        s += randomPick(stops)
      }
      text += s + " "
      w = ctx.measureText(" "+text).width
      i++
      para = ""
    }
    if (PW - w >= 0) {
      spaceText(text, w, PW, x,y,ctx,fs, alt)
      y += fs * 2
    }
  }
  // header
  let maxl = Math.floor(Math.random() * 2)
  text = capitalize(randomWord(true))
  i = 0
  for (; i < maxl; i++)
    text += " "+capitalize(randomWord(true))
  ctx.font = "400 "+(fs*1.3)+"pt Georgia"
  w = ctx.measureText(text).width
  ctx.fillText(text, W/2-w/2, pad-fs*1.3)
  if (alt)
    grit(ctx,text,W/2-w/2, pad-fs*1.3,w,fs)

  text = Math.floor(1*(Math.random() * 200)) // page number
  w = ctx.measureText(text).width
  x = pad
  if (Math.random() > 0.5)
    x = W - pad - ctx.measureText(text).width*1.5
  ctx.fillText(text, x, pad-fs*1.3)
  if (alt)
    grit(ctx,""+text,x,pad-fs*1.3,w,fs)
}

function spaceText (t, width, finalwidth,x,y,ctx,fs, alt) {
  let ta = t.split("")
  let diff = (finalwidth-width)/ta.length
  let i = 0
  for (;i < ta.length; i++) {
    ctx.fillText(ta[i], x, y)
    w = ctx.measureText(ta[i]).width
    if (alt)
      grit(ctx,ta[i],x,y,w,fs)
    x += w+diff
  }
}

function grit (ctx,text,x,y,w,fs) {
  let j = 0
  if (text !== " ")
  for (; j < 3*text.length; j++) {
    let r = (fs*fs/10)/201 * Math.random()
    drawBlobAt(ctx, x + Math.random()*w, y-fs/2 + Math.random()*fs, r)
  }
}

function divRects (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let LW = 1 + Math.floor(document.getElementById("featuresize").value/50)
  let alt = document.getElementById("grungy").checked
  let inset = 20 + Math.random()*20
  let W = canvas.width
  let H = canvas.height
  ctx.globalAlpha = document.getElementById("opacity").value/200
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineWidth = LW + 1
  let x = inset, y = inset
  let div = 6+ Math.floor(Math.random()*20)
  let d1 = (W-3*inset)/div
  if (Math.random() > 0.5)
    y = H-inset-d1
  let ymax = (d1 > 80)? 80: d1;
  ctx.lineWidth = LW
  let i = 0
  for (; i < div+6; i++) {
  // horirontal div
    ctx.fillRect(x+i*d1, y, d1/4, ymax)
  }
  ctx.globalAlpha = document.getElementById("opacity").value/100
}

function scale (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let fs = document.getElementById("featuresize").value
  let LW = 1 + Math.floor(document.getElementById("featuresize").value/50)
  let alt = document.getElementById("grungy").checked
  let inset = 20 + Math.random()*20
  let W = canvas.width
  let H = canvas.height
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineCap = "square"
  ctx.lineWidth = LW
  let x = 3*inset + pet(inset), x0 = x
  let y = 3*inset + pet(inset), d = 0
  let w = H/32, h = w
  //let b = 0
  ctx.font = w/2 + "pt Helvetica"

  let i = 0, N = 8, FLIP = true
  for (; i < N; i++) {
    ctx.globalAlpha = ctx.globalAlpha/2
    ctx.fillRect(x,y,w,h)
    ctx.globalAlpha = document.getElementById("opacity").value/100
    ctx.strokeRect(x,y,w,h)
    if (FLIP)
      x -= w
    else
      x += w
    ctx.strokeRect(x,y,w,h)
    y += h
    FLIP = !FLIP
    if (i == 0 || i === 4)
       ctx.fillText((i+1),x0+w*1.2,y+d*w)
    if (i === 6)
       ctx.fillText("10",x0+w*1.2,y+d*w)
    d = 1
    if (i === 4)
      h *= 5
    if (i === 6)
      h *= 2
    
  }
}

function polar (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let fs = document.getElementById("featuresize").value
  let LW = 1 + Math.floor(document.getElementById("featuresize").value/100)
  let alt = document.getElementById("grungy").checked
  let inset = 20 + Math.random()*20
  let W = canvas.width
  let H = canvas.height
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineCap = "square"
  ctx.lineWidth = LW
  let x = (Math.random() > 0.5)? 0: W;
  let y = (Math.random() > 0.5)? 0: H;
  x += pet(200), y += pet(200)
  let r = 95 + Math.random() * 15
  let r0 = r, b = 0
  let i = 0, N = 7 + Math.floor(Math.random() * 5)
  for (; i < N; i++) {
    b = (Math.random() > 0.5)? 3: -3;
    b = (LW + b)
    //ctx.lineWidth = randomPick[1,2,3,4,5]
    ctx.beginPath()
    ctx.arc(x,y,r,0,Math.PI*2)
    ctx.closePath()
    ctx.stroke()
    r += r0
  }
  x = (Math.random() > 0.5)? 0: W;
  y = (Math.random() > 0.5)? 0: H;
  let x2 = W-x, y2 = H-y
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(x2,y2)
  ctx.closePath()
  ctx.stroke()
  
  i = 0
  //r0 = Math.pow(r0*r0, 0.5)
  for(; i < N; i++) {
    x += r0*1.42, x2 += r0*1.42
    //ctx.lineWidth = randomPick[1,2,3,4,5]
    ctx.beginPath()
    ctx.moveTo(x,y)
    ctx.lineTo(x2,y2)
    ctx.closePath()
    ctx.stroke()
  }
}

function pairedwords () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width
  let H = canvas.height
  let fs = document.getElementById("featuresize").value/2
  let alt = document.getElementById("grungy").checked
  let LW = 1 + Math.floor(document.getElementById("featuresize").value/50)
  ctx.lineWidth = LW
  ctx.lineCap = "square"
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let pairs =
  {"dir":"ls",
  "\\r":"\\n",
  "Math":"Maths","soft":"serve","read":"only","fish":"fish","hand":"wash","luke":"warm","check":"list","LP":"CD","hopes":"prayers","thermo":"nuclear",
  "colours":"colors","one":"1","5":"V","10":"X","1":"I", "hem":"haw", "xylem":"phloem", "rough":"tumble","weft":"warp","cake":"eat it too",
  "in":"cm","tumble":"dry","a horse":"an horse","luke":"warm","either":"or",
  "null":"nil","0":"nil","zero":"","empty":"","vice":"versa","measure 2X":"cut 1X",
  "realise":"realize","gray":"grey",
  "OK":"Okay","d'accord":"OK","shelf":"life","due":"date","the":"teh","bleu":"blue",
  "let":"var","bangers":"mash","beacon":"eggs",
  "row":"roe","roe":"eggs","flammable":"inflammable","half full":"half empty","half empty":"half full",
  "row":"fight","red":"#ff0000","yin":"yang","past":"prologue","time":"money",
  "g":"oz",
  "pair":"pear","e":"2.71828",
  "deer":"dear","Pi":"3.14159","N":"1, 2, 3,...","col":"row","Oh":"0","et":"&","&":"+","and":"et","O":"Oh",
  "pie":"pizza","port":"left","starboard":"right","dorsal":"back","ventral":"front",
  "X":"X","y":"f(x)","[X]":"checked","=":"equals"
  }
  let keys = shuffle(Object.keys(pairs))
  let inset = 40
  let i = 0
  let w = W/7, h = w/1.61803
  fs = h/7
  let x = inset, y = inset*2
  let N = 28
  ctx.font = fs+"pt Helvetica"
  let a = 1
  // draw boxes
  for (; i < N; i++) {
    ctx.strokeRect(x+pet(4),y+pet(4),w+pet(4),h+pet(4))
    // light fill of either side or big rect
    a = ctx.globalAlpha
    ctx.globalAlpha = 0.25
    let d = +(Math.random()>0.5)?w/2:0;
    ctx.fillRect(x+d,y,w/2-4,h-4)
    ctx.globalAlpha = a
    ctx.beginPath()
    let p = pet(12)
    ctx.moveTo(x+w/2+p, y + 6)
    ctx.lineTo(x+w/2+p, y + h - 6)
    ctx.closePath()
    ctx.stroke()
    if (!alt)
      ctx.fillText(keys[i]+"      ["+pairs[keys[i]]+"]", x, y - fs/2)
    x += (w * 1.5)
    if (x + w*1.5 > W - inset*2) {
      x = inset
      y += h * 1.5
    }
  }
  a = ctx.globalAlpha
  ctx.globalAlpha = 0.25
  ctx.fillRect(W-inset*2.3+pet(20), y=inset*2+pet(30), 11+ Math.random()* 24, H - h)
  ctx.globalAlpha = a
}

function histograph () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let fs = document.getElementById("featuresize").value
  let LW = 1 + Math.floor(document.getElementById("featuresize").value/50)
  let alt = document.getElementById("grungy").checked
  let inset = 50 + Math.random()*20
  let W = canvas.width
  let H = canvas.height
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineCap = "square"
  ctx.lineWidth = LW + 3
  let x = inset+12, y = H/2
  let divs = randomPick([4,5,6,7,8,10])
  let w = (W-2*inset)/divs - 20
  let a = ctx.globalAlpha
  let d = (W - inset*2) - (divs*w)
  ctx.strokeRect(inset,inset*2,W-inset*2,H-inset*3)
  x = d/2 + inset
  ctx.lineWidth = LW
  let i = 0
  for (; i < divs; i++) {
    y = inset*3 + Math.random() * H * 0.5
    ctx.strokeRect(x,y,w-19 ,(H-inset*3)-y)
    ctx.globalAlpha = Math.random() /2
    ctx.fillRect(x+pet(15),y+pet(15),w-19 ,(H-inset*3)-y)
    ctx.globalAlpha = a
    x += w
  }
  let t = randomWord() + " - "
  //t = randomPick(["CAT: ", "BOM: ", "Control:  ","S K U - ", "F I G U R E: ", "BAT - ", "___","I V E N T O R Y #", "L_E_M_ ", "Product - "])
  t += Math.floor(Math.random() * 100)
  ctx.font = "100 "+20+"pt AmericanTypewriter,'Courier New'"
  ctx.scale(-1, 1)
  ctx.fillText(t.toUpperCase(), -W/2-100, inset)
  ctx.setTransform(1, 0, 0, 1, 0, 0);
}

function stepchart (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let fs = document.getElementById("featuresize").value
  let LW = 1 + Math.floor(document.getElementById("featuresize").value/50)
  let alt = true//document.getElementById("grungy").checked
  let inset = 50 + Math.random()*20
  let W = canvas.width
  let H = canvas.height
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineCap = "butt"
  ctx.lineWidth = LW + 1
  let x = inset, y = H/2
  ctx.lineWidth = LW
  y = H/2 + pet(H/8)
  let w = W/randomPick([13,17,19,23,29]), y0 = y, i = 0, d = 0, gap = 8
  while (x < W-inset-w) {
    ctx.beginPath()
    ctx.moveTo(x,y)
    x += w
    ctx.lineTo(x-8,y)
    ctx.stroke()
    
    ctx.beginPath()
    ctx.moveTo(x,y)
    d = randomPick([-w,0,w])
    if (d !== 0) {
      y += d
      if (d < 0)
        gap = 8
      else
      if (d > 0)
        gap = -8
      else
        gap = 0
      ctx.lineTo(x,y+gap)
      ctx.stroke()
    }
  }
  let yE = y
  while (y < H-inset-w) { // down from end
    ctx.beginPath()
    ctx.moveTo(x,y)
    y += w
    ctx.lineTo(x,y-8)
    ctx.stroke()
  }
  while (x > inset+8) { // botton rt to left
    ctx.beginPath()
    ctx.moveTo(x,y)
    x -= w
    ctx.lineTo(x+8,y)
    ctx.stroke()
  }
  while (y > inset+w) { // left to top
    ctx.beginPath()
    ctx.moveTo(x,y)
    y -= w
    ctx.lineTo(x,y+8)
    ctx.stroke()
  }
  while (x < W - inset-w) {
    ctx.beginPath()
    ctx.moveTo(x,y)
    x += w
    ctx.lineTo(x-8,y)
    ctx.stroke()
  }
  while (y < yE) {
    ctx.beginPath()
    ctx.moveTo(x,y)
    y += w
    ctx.lineTo(x,y-8)
    ctx.stroke()
  }
  
  if (true) {
    let face = 'Helvetica'
    ctx.font = "500 "+randomPick([21,20,24])+"pt " + face
    w = ctx.measureText("Table 1").width
    ctx.fillText("Table 1", W/2-w/2, inset)
    let wrd = randomWord()
    w = ctx.measureText(wrd).width
    ctx.fillText(wrd, W/2-w/2, H-inset/2)
    
    wrd = randomWord()
    w = ctx.measureText(wrd).width
    ctx.save()
    ctx.translate(inset/2, H/2-w/2)
    ctx.rotate(Math.PI / 2)
    ctx.fillText(wrd, 0, 0)
    ctx.restore()
  }
}

function ctrlchart (canvas) {
  if (!canvas)
      canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let fs = document.getElementById("featuresize").value
  let LW = 1 + Math.floor(document.getElementById("featuresize").value/50)
  let alt = document.getElementById("grungy").checked
  let inset = 20 + Math.random()*20
  let W = canvas.width
  let H = canvas.height
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineCap = "square"
  ctx.lineWidth = LW + 1
  let x = inset, y = H/2
  ctx.lineWidth = LW + 4
  
  ctx.beginPath()
  ctx.moveTo(x,y)
  ctx.lineTo(W-inset,y)
  ctx.closePath()
  ctx.stroke()
  
  ctx.lineWidth = LW
  ctx.strokeStyle = "red"
  ctx.beginPath()
  ctx.moveTo(x,y-3*H/10)
  ctx.lineTo(W-inset,y-3*H/10)
  ctx.closePath()
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x,y-2*H/10)
  ctx.lineTo(W-inset,y-2*H/10)
  ctx.closePath()
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x,y-H/10)
  ctx.lineTo(W-inset,y-H/10)
  ctx.closePath()
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x,y+H/10)
  ctx.lineTo(W-inset,y+H/10)
  ctx.closePath()
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x,y+2*H/10)
  ctx.lineTo(W-inset,y+2*H/10)
  ctx.closePath()
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(x,y+3*H/10)
  ctx.lineTo(W-inset,y+3*H/10)
  ctx.closePath()
  ctx.stroke()
  
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  y = H/2 + pet(H/8)
  let w = W/40, i = 0
  while (x < W-inset-w) {
    ctx.beginPath()
    ctx.moveTo(x,y)
    y += pet(H/8)
    x += w
    ctx.lineTo(x,y)
    ctx.closePath()
    ctx.stroke()
  }
  
  // bottom tics
  let d = 60
  y = H-inset, x = inset
  i = 0
  while (x < W-inset) {
    ctx.beginPath()
    ctx.moveTo(x,y)
    if (i % 5 === 0)
      d = 100
    else
      d = 50
    ctx.lineTo(x,y-d)
    ctx.closePath()
    ctx.stroke()
    x += w
    i++
  }
  d = 60
  y = inset, x = inset
  i = 0
  while (x < W-inset) {
    ctx.beginPath()
    ctx.moveTo(x,y)
    if (i % 5 === 0)
      d = 100
    else
      d = 50
    ctx.lineTo(x,y+d)
    ctx.closePath()
    ctx.stroke()
    x += w
    i++
  }
  let date = new Date()
  date.setDate(date.getDate() - (365*randomPick([2.3,4.5,6.6,5.7,7.4,19.2])))
  let t = date.toString().substring(0,16)
  ctx.font = "100 "+20+"pt AmericanTypewriter,'Courier New'"
  ctx.fillText(t, W*Math.random(), H-inset*4 - Math.random()*10)
  
  t = randomPick(["CAT: ", "BOM: ", "Control:  ","S K U - ", "F I G U R E: ", "BAT - ", "___","I V E N T O R Y #", "L_E_M_ ", "Product - "])
  t += Math.floor(Math.random() * 10000000)
  ctx.font = "100 "+13+"pt AmericanTypewriter,'Courier New'"
  ctx.fillText(t, W*Math.random(), inset*4 - Math.random()*10)
}

function form3 () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let fs = document.getElementById("featuresize").value
  let LW = 1 + Math.floor(document.getElementById("featuresize").value/50)
  let alt = document.getElementById("grungy").checked
  let inset = 50 + Math.random()*20
  let W = canvas.width
  let H = canvas.height
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = getCurrentPalette()
  ctx.strokeStyle = colors[0]
  ctx.fillStyle = colors[1]
  ctx.lineCap = "square"
  ctx.lineWidth = LW + 3
  let x = 0, y = 0
  let a = ctx.globalAlpha
  
  nested(colors[0], LW -3)
  zoomOutImage()
  nested(colors[0], LW +3)
  zoomOutImage()
  //ctx.strokeRect(inset,inset*2,W-inset*2,H-inset*3)
  let x0 = 0, y0 = 0
  ctx.lineWidth = LW
  let i = 0
  for (; i < 2; i++) {
    ctx.strokeStyle = colors[0]
    ctx.fillStyle = colors[1]
    x = inset + Math.random() * W/2+pet(33)
    y = inset + Math.random() * H/3
    ctx.globalAlpha = Math.random() /4
    ctx.fillRect(x+pet(15),y+pet(15),50+W/3*Math.random() , 150 + H/2 * Math.random())
    x = inset + Math.random() * W/2 + W/3+pet(33)
    y = inset + Math.random() * H/3 + H/3
    ctx.globalAlpha = Math.random() /4
    ctx.fillRect(x+pet(15),y+pet(33),50+W/3*Math.random() , 150 + H/2 * Math.random())
    x = inset + Math.random() * W/2
    y = inset + Math.random() * H/3+pet(33)
    x0 = x, y0 = y
    ctx.beginPath()
    ctx.moveTo(x,y)
    y += 150 + H/2 * Math.random()
    ctx.lineTo(x,y+pet(33))
    
    x += 150 +W/2*Math.random()
    ctx.lineTo(x+pet(33),y)
    
    y -= H/2 * Math.random()
    ctx.lineTo(x,y+pet(33))
    x -= W/2 * Math.random()
    ctx.lineTo(x+pet(33),y)
    
    y = y0
    ctx.lineTo(x,y)
    
    ctx.closePath()
    ctx.fill()

    ctx.globalAlpha = a
    rc()
  }
  rc()
  rc()
  let letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ....::::--1234567890".split("")
  ctx.fillStyle = colors[0]
  ctx.font = "100 "+14+"pt AmericanTypewriter,'Courier New'"
  i = 0
  let N = 171 + Math.random() * 100
  for (; i < 131; i++) {
    ctx.globalAlpha = Math.random() /2

    t = randomPick(letters)
    if (Math.random() > 0.5)
      t += randomPick(letters)
    ctx.scale(-1, 1)
    ctx.fillText(t.toUpperCase(), -Math.random() * W, Math.random() *H)
    ctx.setTransform(1, 0, 0, 1, 0, 0);
  }
}

function form2 (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let fs = document.getElementById("featuresize").value
  let LW = 1 + Math.floor(document.getElementById("featuresize").value/100)
  let alt = document.getElementById("grungy").checked
  let inset = 20 + Math.random()*20
  let W = canvas.width
  let H = canvas.height
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineCap = "square"
  let x = 0, y = 0
  ctx.lineWidth = LW
  
  let i = 0
  for (; i < 2; i++) {
  // horirontal div
    x = inset
    y = Math.random()*H
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(W-inset, y);
    ctx.closePath()
    ctx.stroke()
    y = inset
    x = Math.random()*H
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x, H-inset);
    ctx.closePath()
    ctx.stroke()
  }
  
  if (Math.random() > 0.5)
    scale(canvas)
  // date stamp
  if (Math.random() > 0.5) {
    let date = new Date()
    date.setDate(date.getDate() - (365*randomPick([2.3,4.5,6.6,5.7,7.4,19.2])))
    let t = date.toString().substring(0,16)
   // ctx.font = "11pt AmericanTypewriter-Bold"
    ctx.font = "100 "+10+"pt AmericanTypewriter,'Courier New'"
    ctx.fillText(t, W*Math.random(), H-20 - Math.random()*10)
  }
  // column
  if (Math.random() > 0.5) {
    ctx.lineWidth += 1
    i = 1, x = inset+Math.random() * W/2, y = H/3 +Math.random() * (H/3)
    let h = H/2 + pet(H/4), w = h/1.8
    ctx.strokeRect(x,y,w,h)
    ctx.lineWidth -= 1
    let divs = randomPick([6,7,8,9,11,14])
    let d = h/divs
    for (; i < divs; i++) {
      ctx.beginPath();
      ctx.moveTo(x+6, y + i * d);
      ctx.lineTo(x+w-6, y + i * d);
      ctx.closePath()
      ctx.stroke()
    }
  }
  
  if (Math.random() > 0.5) {
    x = inset
    y = inset + Math.random() * (H/2)
    ctx.strokeRect(x,y,W-(2*inset), H- (2*inset))
  }
  
  if (Math.random() > 0.2)
    polar(canvas)
  if (Math.random() > 0.5)
    divRects(canvas)
  document.getElementById("featuresize").value = 24
  //if (Math.random() > 0.5)
  //  mockparagraphScript(canvas)
  //if (Math.random() > 0.5)
   // mockparagraphWords(canvas)
  document.getElementById("featuresize").value = fs
}

function form1 (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let LW = 1 + Math.floor(document.getElementById("featuresize").value/50)
  let alt = document.getElementById("grungy").checked
  let inset = 20 + Math.random()*20
  let W = canvas.width
  let H = canvas.height
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineWidth = LW + 1
  let x = 0, y = 0
  ctx.strokeRect(inset,inset,W-inset*2, H-inset*2)
  ctx.lineWidth = LW
  if (Math.random() > 0.5) {
    inset += 4 * Math.random() * 10
    ctx.strokeRect(inset,inset,W-inset*2, H-inset*2)
  }

  // horirontal div
  let dtop = H/4 + pet(H/8)
  let dy = dtop + Math.random() * (H/5)
  ctx.beginPath();
  ctx.moveTo(x+inset, y+dy);
  ctx.lineTo(W-inset, y+dy);
  ctx.closePath()
  ctx.stroke()
  
  // lower vert divs
  dx = W/2 + Math.random() * W/3
  ctx.beginPath();
  ctx.moveTo(x+dx, y+dy);
  ctx.lineTo(x+dx, H-inset);
  ctx.closePath()
  ctx.stroke()
  if (Math.random() > 0.5) {
    dx = inset + Math.random() * W/3
    ctx.beginPath();
    ctx.moveTo(x+dx, y+dy);
    ctx.lineTo(x+dx, H-inset);
    ctx.closePath()
    ctx.stroke()
  }
  
  // as alt
  //ctx.strokeStyle = "#ff0000"
  //ctx.lineWidth = 3
  if (alt) {
    inset += 6+Math.random()*24
    ctx.strokeRect(inset,inset,W-inset*2,dtop)
    dx = inset+W/5
    ctx.beginPath();
    ctx.moveTo(x+dx, y+inset);
    ctx.lineTo(x+dx, dtop+inset);
    ctx.closePath()
    ctx.stroke()
    dx += W/4
    ctx.beginPath();
    ctx.moveTo(x+dx, y+inset);
    ctx.lineTo(x+dx, dtop+inset);
    ctx.closePath()
    ctx.stroke()
    dx += W/4
    ctx.beginPath();
    ctx.moveTo(x+dx, y+inset);
    ctx.lineTo(x+dx, dtop+inset);
    ctx.closePath()
    ctx.stroke()
    // horx div
    ctx.beginPath();
    ctx.moveTo(inset, dtop/2+inset);
    ctx.lineTo(x+dx, dtop/2+inset);
    ctx.closePath()
    ctx.stroke()
    // 2 H divs in rightmost cell
    let dh = dtop/3
    ctx.beginPath();
    ctx.moveTo(x+dx, dh+inset);
    ctx.lineTo(W-inset, dh+inset);
    ctx.closePath()
    ctx.stroke()
    
    ctx.beginPath();
    ctx.moveTo(x+dx, dh*2+inset);
    ctx.lineTo(W-inset, dh*2+inset);
    ctx.closePath()
    ctx.stroke()
  }
  
}

function lineFrame () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let LW = 1 + Math.floor(document.getElementById("featuresize").value/10)
  let grunge = document.getElementById("grungy").checked
  let inset = 1+document.getElementById("number").value/100 // max == 10000
  let W = canvas.width
  let H = canvas.height
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineWidth = LW
  let x = 0, y = 0
  ctx.beginPath();
  ctx.moveTo(x+inset, y+inset);
  ctx.lineTo(W-inset, y+inset);
  ctx.lineTo(W-inset, H-inset);
  ctx.lineTo(x+inset, H-inset);
  ctx.closePath()
  ctx.stroke()
}

function rectFrame () {
  const rect = true
  framePolaroid(rect)
}

function framePolaroid (rect) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let D =  (5 + Math.floor(document.getElementById("featuresize").value/3))
  let alt = document.getElementById("grungy").checked
  let W = canvas.width
  let H = canvas.height
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let x = -1, y = -1
  let w = 6 + Math.random()*14
  let wobble = 6
  let i = 0
  while (y < canvas.height) {
    w = D +Math.random()*D/wobble
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(x + w, y )
    ctx.lineTo(x + w, y+w )
    ctx.lineTo(x , y+w)
    ctx.closePath()
    ctx.fill()
    
    ctx.beginPath()
    ctx.moveTo(W, y)
    ctx.lineTo(W - w, y )
    ctx.lineTo(W - w, y+w )
    ctx.lineTo(W, y+w)
    ctx.closePath()
    ctx.fill()
    y += 2
  }
  
  if (alt)
    return
  x = 0, y = -1
  while (x < canvas.width) {
    w = D +Math.random()*D/wobble
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(x + w, y )
    ctx.lineTo(x + w, y+w )
    ctx.lineTo(x, y+w)
    ctx.closePath()
    ctx.fill()
    if (rect) {
      ctx.beginPath()
      ctx.moveTo(x, H)
      ctx.lineTo(x - w, H)
      ctx.lineTo(x - w, H-w)
      ctx.lineTo(x, H-w)
      ctx.closePath()
      ctx.fill()
      x += 2
    } else {
      ctx.beginPath()
      ctx.moveTo(x, H)
      ctx.lineTo(x - w, H)
      ctx.lineTo(x - w, H-3*w)
      ctx.lineTo(x, H-3*w)
      ctx.closePath()
      ctx.fill()
      x += 2
    }
  }
  //ctx.restore()
}


function frameCircle () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let off = document.createElement('CANVAS')
  let offctx = off.getContext("2d")
  off.width = canvas.width
  off.height = canvas.height
  offctx.drawImage(canvas, 0, 0)
  let alpha = document.getElementById("opacity").value
  let r = document.getElementById("featuresize").value/500
  let W = canvas.width
  let H = canvas.height
  let cx = W/2, cy = H/2
  let rx = cx - (cx * r), ry = cy - (cy * r)
  ctx.globalAlpha = 1
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.clearRect(0,0,W,H)
  ctx.save()
  ctx.beginPath()
  ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2);
  ctx.closePath()
  ctx.clip()
  ctx.drawImage(off,0,0)
  ctx.restore()
  let mode = document.getElementById("mode").value
  ctx.globalCompositeOperation = "destination-over"
  ctx.fillRect(0,0,W,H)
  document.getElementById("mode").value = mode
  ctx.globalCompositeOperation = mode
  ctx.globalAlpha = alpha/100
}

function frameRect (points, c, margin) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let D =  (5 + Math.floor(document.getElementById("featuresize").value/10))
  let grunge = document.getElementById("grungy").checked
  let H = distance(points[0], points[1], points[6], points[7])
  let W = distance(points[0], points[1], points[2], points[3])
  ctx.fillStyle = c
  let w = 6 + Math.random()*14
  let h = w/2
  let p = 6+D*1.5
  let x = points[0], y = points[1]

  while (y < points[5]-w) {
    w = D +Math.random()*D/2
    ctx.beginPath()
    ctx.moveTo(x + pet(p), y+pet(p))
    ctx.lineTo(x + w + pet(p), y +pet(p))
    ctx.lineTo(x + w + pet(p), y+w +pet(p))
    ctx.lineTo(x + pet(p), y+w+pet(p))
    ctx.closePath()
    ctx.fill()
    
    ctx.beginPath()
    ctx.moveTo(points[2] - pet(p), y + pet(p))
    ctx.lineTo(points[2] - w + pet(p), y + pet(p))
    ctx.lineTo(points[2] - w + pet(p), y + w + pet(p))
    ctx.lineTo(points[2] - pet(p), y + w + pet(p))
    ctx.closePath()
    ctx.fill()
    y += 2
  }
  x = points[0], y = points[1]
  while (x < points[2]-w) {
    w = D +Math.random()*D/2
    ctx.beginPath()
    ctx.moveTo(x + pet(p), y+pet(p))
    ctx.lineTo(x + w + pet(p), y+pet(p))
    ctx.lineTo(x + w + pet(p), y+w +pet(p))
    ctx.lineTo(x + pet(p), y+pet(p))
    ctx.closePath()
    ctx.fill()
    
    ctx.beginPath()
    ctx.moveTo(x + pet(p), points[5]-pet(p))
    ctx.lineTo(x + w + pet(p), points[5] -pet(p))
    ctx.lineTo(x + w + pet(p), points[5]-pet(p))
    ctx.lineTo(x + pet(p), points[5]-pet(p))
    ctx.closePath()
    ctx.fill()
    x += 2
  }
}

function shuffle (array) {
  return array.sort(() => Math.random() - 0.5);
}

function circle () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let cx = canvas.width/2
  let cy = canvas.height/2
  let pad = 0 + document.getElementById("featuresize").value
  pad = 500 - pad
  let r = canvas.width/2 - pad
  ctx.fillStyle = randomPick(getCurrentPalette())
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.beginPath()
  ctx.moveTo(cx, cy)
  ctx.arc (cx, cy, r, 0, 2*Math.PI)
  ctx.closePath()
  ctx.fill()
}

function sides () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let w = 21+document.getElementById("featuresize").value/1
  w += 41 * Math.random()
  let x = 0, y = 0
  let x2 = w
  let y2 = canvas.height
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  if (document.getElementById("grungy").checked)
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
  ctx.globalAlpha = document.getElementById("opacity").value/100
  
  ctx.beginPath()
  ctx.moveTo(x, y)
  ctx.lineTo(x2, y)
  ctx.lineTo(x2, y2)
  ctx.lineTo(x, y2)
  ctx.closePath()
  ctx.fill()
}

function sides2 () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let w = 21+document.getElementById("featuresize").value/3
  w += 41 * Math.random()
  let x = canvas.width * Math.random() - w, y = 0
  let x2 = x + w
  let y2 = canvas.height
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  if (document.getElementById("grungy").checked)
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.beginPath()
  ctx.moveTo(x, y)
  ctx.lineTo(x2, y)
  ctx.lineTo(x2, y2)
  ctx.lineTo(x, y2)
  ctx.closePath()
  ctx.fill()
}

function square (x, y, w) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let cx = canvas.width/2 + (Math.random()-0.5) * 200
  let cy = canvas.height/2 + (Math.random()-0.5) * 200
  let len = 10 + 2 * Math.floor(document.getElementById("featuresize").value)
  cx -= len/2
  cy -= len/2
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  if (document.getElementById("grungy").checked)
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.beginPath()
  ctx.moveTo(cx, cy)
  ctx.lineTo(cx+len, cy)
  ctx.lineTo(cx+len, cy+len)
  ctx.lineTo(cx, cy+len)
  ctx.closePath()
  ctx.fill()
}

function bwash (x, y, w) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.save()
  if (Math.random() > 0.01) {
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
    ctx.beginPath()
    ctx.moveTo(x,y)
    ctx.lineTo(x+w, y)
    ctx.lineTo(x+w, y+w)
    ctx.lineTo(x, y+w)
    ctx.closePath()
    ctx.fill()
  }
  ctx.restore()
}

function paintByDots () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let OC = document.getElementById("OC")
  let ctxOC = OC.getContext("2d")
  let pad = 0
  let W = canvas.width
  let H = canvas.height
  OC.width = W, OC.height = H
  ctxOC.clearRect(0,0,W,H)
  let d = (canvas.width)/60
  let space = 1
  if (document.getElementById("grungy").checked)
    space = 2
  let face = "AmericanTypewriter-Bold"
  let text = ""
  let size = d*0.75
  ctx.font = size+"pt " + face
  ctxOC.font = size+"pt " + face
  let colors = extractPalette()
  tintByCloseness()
  let colors2 = []
  let colorkeys = ["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"]
  let j = 0, vals = {}
  for (; j < colors.length; j++)
    vals[colors[j]] = colorkeys[j]
  let x = pad*1.5, y = pad*1.5
  let values = []
  while (y < H - pad*1.5) {
    while (x < W - pad*1.5) {
      let c = colorOf(ctx,x,y,d)
      colors2.push(c)
      values.push(vals[c] || "x")//colorkeys[colors.length])
      x += space * d
    }
    x = pad*1.5
    y += space * d
  }
  let i = 0
  x = pad*1.5, y = pad*1.5
  while (y < H - pad*1.5) {
    while (x < W - pad*1.5) {
      if (Math.random() > 0.994) {
        ctxOC.fillStyle = colors2[i]
        ctxOC.beginPath()
        ctxOC.arc(x+d/4, y+d*0.8, 34,0,Math.PI*2)
        ctxOC.closePath()
      ctxOC.fill()
      }
      i++
      x += space * d
    }
    x = pad*1.5
    y += space * d
  }
}


function paintByNumbers2 () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let OC = document.getElementById("OC")
  let ctxOC = OC.getContext("2d")
  let pad = 0
  let W = canvas.width
  let H = canvas.height
  OC.width = W, OC.height = H
  ctxOC.clearRect(0,0,W,H)
  let d = (canvas.width)/60
  let space = 1
  if (document.getElementById("grungy").checked)
    space = 2
  let face = "AmericanTypewriter-Bold"
  let text = ""
  let size = d*0.75
  ctx.font = size+"pt " + face
  ctxOC.font = size+"pt " + face
  let colors = extractPalette()
  tintByCloseness()
  let colors2 = []
  let colorkeys = ["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"]
  let j = 0, vals = {}
  for (; j < colors.length; j++)
    vals[colors[j]] = colorkeys[j]
  let x = pad*1.5, y = pad*1.5
  let values = []
  while (y < H - pad*1.5) {
    while (x < W - pad*1.5) {
      let c = colorOf(ctx,x,y,d)
      colors2.push(c)
      values.push(vals[c] || "x")//colorkeys[colors.length])
      x += space * d
    }
    x = pad*1.5
    y += space * d
  }
  let i = 0
  x = pad*1.5, y = pad*1.5
  while (y < H - pad*1.5) {
    while (x < W - pad*1.5) {
      ctxOC.fillStyle = colors2[i]
      ctxOC.fillText(values[i], x+d/4, y+d*0.8)
      i++
      x += space * d
    }
    x = pad*1.5
    y += space * d
  }
}

function ascript () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let fs = 100// + document.getElementById("featuresize").value/10
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alt = document.getElementById("grungy").checked
  let W = canvas.width, H = canvas.height
  let pad = 4 + Math.floor(Math.random() * 2)
  let linespace = 18 + Math.floor(pet(8))
  ctx.fillStyle = "#ffffff"//color
  ctx.clearRect(0,0,W,H)
  //let colors = ["#ed6060", "#6060ba", "#6060ed", "#ed6060", "#000000"]
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = "#000000"
  ctx.lineJoin = "round"
  ctx.lineWidth = Math.floor(1 + fs/20)
  ctx.imageSmoothingQuality = "high"
  let i = 0, x = 300, y = 300, rot = 1
  let sa = Math.PI*Math.random(), ea = sa + 300, cw = true
  let yD = fs/2
  rot = 1
  let r1 = fs, r2 = fs*2
  
  ctx.beginPath()
  rot = randomPick([2.3,2.5,2.7,2.8,2.1,1.9])
  
  ctx.moveTo(x,y)
  ctx.bezierCurveTo(x+pet(fs*9),y+pet(fs*9), x+pet(fs*9),y+pet(fs*9),x+pet(fs*2), y+pet(fs*2))
  //ctx.ellipse(x,y,r1,r2,rot,sa,ea,cw)
// ellipse1 (ctx, x, y, x, y, rot)
  //sa = ea//Math.PI * Math.random()
 // ea = sa+Math.PI * Math.random() *1.25
 sa = ea, ea += Math.PI
  rot += 0.3
  //ctx.ellipse(x,y,r1,r2,rot,sa,ea,cw)
  ctx.stroke()
  ctx.closePath()
}

function markwriter () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let OC = document.getElementById("OC")
  let ctxOC = OC.getContext("2d")
  let W = canvas.width
  let H = canvas.height
 // OC.width = W, OC.height = H
  ctxOC.globalAlpha = document.getElementById("opacity").value/100
  let grays = ["#000000", "#1e1e1e", "#353535", "#4e4e4e", "#696969", "#858585", "#a2a2a2", "#c0c0c0", "#dfdfdf", "#ffffff"].reverse()
  let d = 9+document.getElementById("featuresize").value/40
  
  // use w and h to prevent off-canvas sampling like nicksmith?
  //let w = W/d
  //let h = H/d
  let N = 1+Math.floor(document.getElementById("number").value/5000)
  let alt = document.getElementById("grungy").checked
  let space = 1
  let face = "AmericanTypewriter"
  let text = ""
  let size = d*2, fs = d/2
  let x = 0, y = 0
  let values = [], colors = []
  const PI = Math.PI
  let sa = Math.PI*Math.random(), ea = sa + Math.PI*Math.random()*2//, cw = true
  ctx.lineWidth = 1
  ctxOC.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  let i = 0, j = 0, N1 = N, v = 0
  x = 0, y = 0
  while (y < H) {
    while (x < W) {
      v = 9-brightnessOf10(ctx,x,y,d)
      N1 = v
      if (alt) {
        ctxOC.strokeStyle = grays[v]
        N1 = N * 1.5
      }
      j = 0
      for (; j < N1; j++) {
        ctxOC.beginPath()
        sa = Math.random() * PI, ea = sa + Math.random() * PI
        ctxOC.moveTo(x,y)
        ctxOC.bezierCurveTo(x+pet(fs*13),y+pet(fs*13), x+pet(fs*13),y+pet(fs*13),x+pet(fs*3), y+pet(fs*3))
        ctxOC.stroke()
        ctxOC.closePath()
      }
      i++
      x += space * d
    }
    x = 0
    y += space * d
  }
  swapWithOff()
}

function typewriter () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let OC = document.getElementById("OC")
  let ctxOC = OC.getContext("2d")
  let W = canvas.width
  let H = canvas.height
 // OC.width = W, OC.height = H
  ctxOC.globalAlpha = document.getElementById("opacity").value/100
  let grays = ["#000000", "#1e1e1e", "#353535", "#4e4e4e", "#696969", "#858585", "#a2a2a2", "#c0c0c0", "#dfdfdf", "#ffffff"].reverse()
  let d = 9+document.getElementById("featuresize").value/40
  let N = 1+Math.floor(document.getElementById("number").value/5000)
  let alt = document.getElementById("grungy").checked
  let space = 2
  let face = "AmericanTypewriter"
  let size = d*2
  ctx.font = size+"pt " + face
  ctxOC.font = size+"pt " + face
  let chars = ["s","s","s","s","e","e","e","e","e","e","e","e","e","e","r","r","r","r","r","i","a","t","i","a","t","i","a","t","n","n","n","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q"
    ,"r","s","t","u","v","w","x","y","z"]
  let x = 0, y = 0
  ctxOC.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let i = 0, j = 0, N1 = N, v = 0
  x = 0, y = 0
  while (y < H) {
    while (x < W) {
      v = (9-brightnessOf10(ctx,x,y,d))
      N1 = v//values[i]
      if (alt) {
        ctxOC.fillStyle = grays[v]//values[i]]
        N1 = N * 1.5
      }
      j = 0
      for (; j < N1; j++)
        ctxOC.fillText(randomPick(chars), x+pet(d*3), y+pet(d*3))
      i++
      x += space * d
    }
    x = 0
    y += space * d
  }
  swapWithOff()
}

function paintByNumbers () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let OC = document.getElementById("OC")
  let ctxOC = OC.getContext("2d")
  let pad = 60
  let W = canvas.width
  let H = canvas.height
  OC.width = W, OC.height = H
  ctxOC.clearRect(0,0,W,H)
  let grays = ["#000000", "#1e1e1e", "#353535", "#4e4e4e", "#696969", "#858585", "#a2a2a2", "#c0c0c0", "#dfdfdf", "#ffffff"]

  let d = (canvas.width-2*pad)/50
  let space = 3
  if (document.getElementById("grungy").checked)
    space = 2
  let face = "AmericanTypewriter-Bold"
  let text = ""
  let size = d*0.75
  ctx.font = size+"pt " + face
  ctxOC.font = size+"pt " + face
 // ctx.strokeStyle = "#000000"
  //ctx.lineWidth = 2+Math.floor(document.getElementById("featuresize").value/100)
  let x = pad*1.5, y = pad*1.5
  let values = [], colors = []
  while (y < H - pad*1.5) {
    while (x < W - pad*1.5) {
      values.push(brightnessOf10(ctx,x,y,d))
      colors.push(brightnessOf(ctx,x,y,d))
      x += space * d
    }
    x = pad*1.5
    y += space * d
  }
  let i = 0
  x = pad*1.5, y = pad*1.5
  while (y < H - pad*1.5) {
    while (x < W - pad*1.5) {
      //ctx.strokeRect(x,y,d,d)
      ctxOC.fillStyle = grays[values[i]]
      ctxOC.fillText(values[i], x+d/4, y+d*0.8)
      ctx.fillStyle = colors[i]
      ctx.fillText(values[i++], x+d/4, y+d*0.8)
      x += space * d
    }
    x = pad*1.5
    y += space * d
  }
}

function paintBalls () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let pad = 60
  let W = canvas.width
  let H = canvas.height
  let grays = getCurrentPalette().reverse()//extractPalette().reverse()//["#000000", "#1e1e1e", "#353535", "#4e4e4e", "#696969", "#858585", "#a2a2a2", "#c0c0c0", "#dfdfdf", "#ffffff"].reverse()
  let d = (canvas.width-2*pad)/100
  let space = 3
  if (document.getElementById("grungy").checked)
    space = 2
  let x = pad*1.5, y = pad*1.5
  let values = [], colors = []
  let max = 7, m = 0
  d = 20 + document.getElementById("featuresize").value/2
  while (m < max) {
    x = d+(Math.random() * W)
    y = d+(Math.random() * H)
    values.push(Math.floor(Math.random()*grays.length))//Math.(brightnessOf10(ctx,x,y,d))
    colors.push(brightnessOf(ctx,x,y,d))
    ctx.beginPath()
    ctx.fillStyle = grays[values[m]]
    ctx.arc(x+d/4, y+d*0.8, d, 0, Math.PI*2)
    ctx.closePath()
    ctx.fill()
    m++
  }
}


function brightnessOf10 (ctx,x,y,d) {
  let imgData = ctx.getImageData(x,y,d,d)
  let pixels = imgData.data;
  let i = 0, brightness = 0
  for (; i < pixels.length; i += 4) {
    brightness += (pixels[i]/255+pixels[i+1]/255+pixels[i+2]/255)
  }
  let div = pixels.length/4
    return Math.floor(10*brightness/div/3)
}

function colorOf10 (ctx,x,y,d,color) {
  let imgData = ctx.getImageData(x,y,d,d)
  let pixels = imgData.data;
  let i = 0, D = 0
    
  D  = colorDistance(colorOf(ctx,x,y,1), color)
  return 10 - Math.floor(10*D/444) // invert
}

function colorOf (ctx,x,y,d) { // single pixel
  d = Math.floor(d)
  let imgData = ctx.getImageData(Math.floor(x),Math.floor(y),d,d)
  let pixels = imgData.data;
  let color = 0
    let R = ('0'+(Math.round(pixels[0])).toString(16)).slice(-2),
      G = ('0'+(Math.round(pixels[1])).toString(16)).slice(-2),
      B = ('0'+(Math.round(pixels[2])).toString(16)).slice(-2);
    color = "#"+R+G+B
  return color
}

function regMarks () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let OC = document.getElementById("OC")
  let ctxOC = OC.getContext("2d")
  let pad = 60
  let W = canvas.width
  let H = canvas.height
  OC.width = W, OC.height = H
  ctxOC.clearRect(0,0,W,H)
  let div = Math.floor(document.getElementById("featuresize").value/5)
  div = 8 + 100 - div
  let d = (canvas.width-2*pad)/div
  let space = 3
  if (document.getElementById("grungy").checked)
    space = 1.5
  ctx.strokeStyle = "#000000"
  ctx.lineWidth = 2//2+Math.floor(document.getElementById("featuresize").value/100)
  let x = pad*1.5, y = pad*1.5
  let values = []
  while (y < H - pad*1.5) {
    while (x < W - pad*1.5) {
      values.push(brightnessOf(ctx,x,y,d))
      x += space * d
    }
    x = pad*1.5
    y += space * d
  }
  let i = 0
  x = pad*1.5, y = pad*1.5
  while (y < H - pad*1.5) {
    while (x < W - pad*1.5) {
      ctx.strokeStyle = values[i]
      ctx.beginPath()
      ctx.moveTo(x+d/2, y)
      ctx.lineTo(x+d/2, y+d)
      ctx.stroke()
      ctx.beginPath()
      ctx.moveTo(x,   y+d/2)
      ctx.lineTo(x+d, y+d/2)
      ctx.stroke()
      
      ctxOC.strokeStyle = values[i]
      ctxOC.beginPath()
      ctxOC.moveTo(x+d/2, y)
      ctxOC.lineTo(x+d/2, y+d)
      ctxOC.stroke()
      ctxOC.beginPath()
      ctxOC.moveTo(x,   y+d/2)
      ctxOC.lineTo(x+d, y+d/2)
      ctxOC.stroke()
      i++
      x += space * d
    }
    x = pad*1.5
    y += space * d
  }
}

function brightnessOf (ctx,x,y,d) {
  let imgData = ctx.getImageData(x,y,d,d)
  let pixels = imgData.data;
  let i = 0, brightness = 0
  for (; i < pixels.length; i += 4) {
    brightness += (pixels[i]/255+pixels[i+1]/255+pixels[i+2]/255)
  }
  let div = pixels.length/4
  if (brightness/div/3 < 0.5)
    return "#ffffff"
  else
    return "#000000"
}

function tile (type) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let sides =  (2 + Math.floor(document.getElementById("featuresize").value/20))
  let w = canvas.width
  let n = canvas.width/sides
  ctx.globalAlpha = document.getElementById("opacity").value/100
  clip()
  let colors = []
  let c = 0
  let nc = 1 + (Math.floor(Math.random() * 3))
  for (; c < nc; c++)
    colors.push(randomColor())
  if (type == "C2" || type == "B2") {
    colors.push(randomColor())
    colors.push(randomColor())
    colors.push(randomColor())
  }
  let numshapes = sides*sides
  let i = 0, x = 0, y = 0
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  if (type != "W")
    ctx.fillRect(0, 0, w, w)
  ctx.fillStyle = randomColor()//randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
  let grunge = document.getElementById("grungy").checked
  let rc = randomColor()
  let pattern = [0,1,2,3,4,5,6,7,8,9,10,11]
  shuffle(pattern)
  for (; i < numshapes; i++) {
    ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)]
    if (grunge)
        ctx.fillStyle = randomGradient(canvas, colors[Math.floor(Math.random() * colors.length)])
    if (type == "D")
      dtile(x,y,n,pattern[i%5])
    else
    if (type == "M")
      mtile(x,y,n, pattern[i%8])
    else
    if (type == "C")
      ctile(x,y,n,pattern[i%4])
    else
    if (type == "C2") {
      ctile2(x,y,n, colors, grunge, pattern[i%4])
    } else
    if (type == "B2") {
      btile(x,y,n, colors, grunge)
    } else
    if (type == "W") {
      bwash(x,y,n)
    } else
      triangle(x, y, n, pattern[i%4])
    x += n
    if (i > 0 && i % sides === (sides-1)) {
      y += n
      x = 0
    }
  }
  ctx.restore()
}

function btile (x, y, w, colors, grunge) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.save
  if (grunge) {
    x += pet(13), y += pet(13)
  }
  if (Math.random() > 0.1) {
    shuffle(colors)
    ctx.fillStyle = colors[0]
    ctx.beginPath()
    ctx.moveTo(x,y)
    ctx.lineTo(x+w, y)
    ctx.lineTo(x+w, y+w)
    ctx.lineTo(x, y+w)
    ctx.closePath()
    ctx.fill()
  }
  if (Math.random() > 0.0) {
    
    shuffle(colors)
    ctx.fillStyle = colors[0]
    ctx.beginPath()
    ctx.moveTo(x+w/2,y+w/2)
    ctx.arc (x+w/2, y+w/2, w/2.1 - (Math.random() * w/3), 0, 2*Math.PI)
    ctx.closePath()
    ctx.fill()
  }
  ctx.restore()
}

function ctile2 (x, y, w, colors, grunge, i) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let q = i%4
  ctx.save()
  if (q == 0) {
    if (grunge)
      shuffle(colors)
    ctx.fillStyle = colors[0]
    ctx.beginPath()
    ctx.moveTo(x,y)
    ctx.arc (x, y, w, 0, 0.5*Math.PI)
    ctx.closePath()
    ctx.fill()
    ctx.fillStyle = colors[1]
    ctx.beginPath()
    ctx.moveTo(x,y)
    ctx.arc (x, y, 2*w/3, 0, 0.5*Math.PI)
    ctx.closePath()
    ctx.fill()
    ctx.fillStyle = colors[0]
    ctx.beginPath()
    ctx.moveTo(x,y)
    ctx.arc (x, y, w/3, 0, 0.5*Math.PI)
    ctx.closePath()
    ctx.fill()
  } else
  if (q == 1) {
    if (grunge)
      shuffle(colors)
    ctx.fillStyle = colors[0]
    ctx.beginPath()
    ctx.moveTo(x,y+w)
    ctx.arc (x, y+w, w, 1.5*Math.PI, 0)
    ctx.closePath()
    ctx.fill()
    ctx.fillStyle = colors[1]
    ctx.beginPath()
    ctx.moveTo(x,y+w)
    ctx.arc (x, y+w, 2*w/3, 1.5*Math.PI, 0)
    ctx.closePath()
    ctx.fill()
    ctx.fillStyle = colors[0]
    ctx.beginPath()
    ctx.moveTo(x,y+w)
    ctx.arc (x, y+w, w/3, 1.5*Math.PI, 0)
    ctx.closePath()
    ctx.fill()
  } else
  if (q == 2) {
    if (grunge)
      shuffle(colors)
    ctx.fillStyle = colors[0]
    ctx.beginPath()
    ctx.moveTo(x+w,y)
    ctx.arc (x+w, y, w, 0.5*Math.PI, Math.PI)
    ctx.closePath()
    ctx.fill()
    ctx.fillStyle = colors[1]
    ctx.beginPath()
    ctx.moveTo(x+w,y)
    ctx.arc (x+w, y, 2*w/3, 0.5*Math.PI, Math.PI)
    ctx.closePath()
    ctx.fill()
    ctx.fillStyle = colors[0]
    ctx.beginPath()
    ctx.moveTo(x+w,y)
    ctx.arc (x+w, y, w/3, 0.5*Math.PI, Math.PI)
    ctx.closePath()
    ctx.fill()
  } else
  if (q == 3) {
    if (grunge)
      shuffle(colors)
    ctx.fillStyle = colors[0]
    ctx.beginPath()
    ctx.moveTo(x+w,y+w)
    ctx.arc (x+w, y+w, w, Math.PI, 1.5*Math.PI)
    ctx.closePath()
    ctx.fill()
    ctx.fillStyle = colors[1]
    ctx.beginPath()
    ctx.moveTo(x+w,y+w)
    ctx.arc (x+w, y+w, 2*w/3, Math.PI, 1.5*Math.PI)
    ctx.closePath()
    ctx.fill()
    ctx.fillStyle = colors[0]
    ctx.beginPath()
    ctx.moveTo(x+w,y+w)
    ctx.arc (x+w, y+w, w/3, Math.PI, 1.5*Math.PI)
    ctx.closePath()
    ctx.fill()
  } else
  if (q == 4) {
    if (grunge)
      shuffle(colors)
    ctx.fillStyle = colors[0]
    ctx.beginPath()
    ctx.fillRect(x,y,w,w)
    ctx.closePath()
    if (Math.random() < 0.5) {
      ctx.fillStyle = colors[1]
      ctx.beginPath()
      ctx.moveTo(x+w/3, y)
      ctx.lineTo(x+2*w/3, y)
      ctx.lineTo(x+2*w/3, y+w)
      ctx.lineTo(x+w/3, y+w)
      ctx.closePath()
      ctx.fill()
    } else {
      ctx.fillStyle = colors[1]
      ctx.beginPath()
      ctx.moveTo(x, y+w/3)
      ctx.lineTo(x+w, y+w/3)
      ctx.lineTo(x+w, y+2*w/3)
      ctx.lineTo(x, y+2*w/3)
      ctx.closePath()
      ctx.fill()
    }
  }
  ctx.restore()
}

function ctile (x, y, w, i) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let q = i % 4//Math.floor(Math.random() * 4)
  ctx.beginPath()
  if (q == 1) {
    ctx.moveTo(x,y)
    ctx.arc (x, y, w, 0, 0.5*Math.PI)
  } else
  if (q == 0) {
    ctx.moveTo(x,y+w)
    ctx.arc (x, y+w, w, 1.5*Math.PI, 0)
  } else
  if (q == 3) {
    ctx.moveTo(x+w,y)
    ctx.arc (x+w, y, w, 0.5*Math.PI, Math.PI)
  } else
  if (q == 2) {
    ctx.moveTo(x+w,y+w)
    ctx.arc (x+w, y+w, w, Math.PI, 1.5*Math.PI)
  } else
    ctx.fillRect(x,y,w,w)
  ctx.closePath()
  ctx.fill()
}

function dtile (x, y, w, i) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let q = i%5
  ctx.beginPath()
  if (q == 0) {
    ctx.arc (x+w/2, y, w/2, 0, Math.PI)
  } else
  if (q == 1) {
    ctx.arc (x, y+w/2, w/2, 1.5*Math.PI, 0.5*Math.PI)
    
  } else
  if (q == 2) {
    ctx.arc (x+w, y+w/2, w/2, 0.5*Math.PI, 1.5*Math.PI)
    
  } else
  if (q == 3) {
    ctx.arc (x+w/2, y+w, w/2, Math.PI, 0)
  } else
    ctx.arc (x+w/2, y+w/2, w/2, 2*Math.PI, 0)
  ctx.closePath()
  ctx.fill()
}

function mtile (x, y, w, i) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");

  let q = i%8
  ctx.beginPath()
  if (q == 0) {
    ctx.moveTo (x, y)
    ctx.lineTo(x+w, y)
    ctx.lineTo(x+w/2, y+w/2)
  } else
  if (q == 1) {
    ctx.moveTo (x, y)
    ctx.lineTo(x, y+w)
    ctx.lineTo(x+w/2, y+w/2)
  } else
  if (q == 2) {
    ctx.moveTo (x+w, y)
    ctx.lineTo(x+w, y+w)
    ctx.lineTo(x+w/2, y+w/2)
  } else
  if (q == 3) {
    ctx.moveTo (x+w, y)
    ctx.lineTo(x, y)
    ctx.lineTo(x+w/2, y+w/2)
  } else
  if (q == 4) {
    ctx.arc (x+w/2, y, w/2, 0, Math.PI)
  } else
  if (q == 5) {
    ctx.arc (x, y+w/2, w/2, 1.5*Math.PI, 0.5*Math.PI)
    
  } else
  if (q == 6) {
    ctx.arc (x+w, y+w/2, w/2, 0.5*Math.PI, 1.5*Math.PI)
    
  } else
  if (q == 7) {
    ctx.arc (x+w/2, y+w, w/2, Math.PI, 0)
  }
  ctx.closePath()
  ctx.fill()
}

function triangle (x, y, w, i) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  // draw a triangle in one or four orientations
  // pick 3 corners |_ -| _| |-
  
  let q = i % 4
  ctx.beginPath()
  if (q == 0) {
    ctx.moveTo (x, y)
    ctx.lineTo(x+w, y)
    ctx.lineTo(x+w, y+w)
  } else
  if (q == 1) {
    ctx.moveTo (x, y)
    ctx.lineTo(x, y+w)
    ctx.lineTo(x+w, y+w)
  } else
  if (q == 2) {
    ctx.moveTo (x+w, y)
    ctx.lineTo(x+w, y+w)
    ctx.lineTo(x, y+w)
  } else {
    ctx.moveTo (x+w, y)
    ctx.lineTo(x, y)
    ctx.lineTo(x, y+w)
  }
  ctx.closePath()
  ctx.fill()
}



function albers () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width
  let f1 = W/9.6
  let f2 = 2* f1
  let f3 = 3 * f1
  let f4 = 4 *f1
  let len = W/2, maxy = W/2
  let quat = len/2
  let top = f1/4
  let t = top
  // 4 rects
  ctx.save()
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let grunge = document.getElementById("grungy").checked
  
  top = 0

  ctx.fillStyle = randomColor()
  ctx.beginPath();
  ctx.moveTo(0+top, 0 + top)
  ctx.lineTo(W-top, 0 + top)
  ctx.lineTo(W-top, W-top)
  ctx.lineTo(0+top, W-top)
  ctx.closePath()
  ctx.fill()
  
  top += t*2
  ctx.fillStyle = randomColor()
  ctx.beginPath();
  ctx.moveTo(f1, f1+top)
  ctx.lineTo(W-f1, f1+top)
  ctx.lineTo(W-f1, W-f1+top)
  ctx.lineTo(f1, W-f1+top)
  ctx.closePath()
  ctx.fill()
  
  top += t * 2
  ctx.fillStyle = randomColor()
  ctx.beginPath();
  ctx.moveTo(f2, f2+top)
  ctx.lineTo(W-f2, f2+top)
  ctx.lineTo(W-f2, W-f2+top)
  ctx.lineTo(f2, W-f2+top)
  ctx.closePath()
  ctx.fill()
  
  top += t*2
  ctx.fillStyle = randomColor()
  if (grunge)
    ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.beginPath();
  ctx.moveTo(f3, f3+top)
  ctx.lineTo(W-f3, f3+top)
  ctx.lineTo(W-f3, W-f3+top)
  ctx.lineTo(f3, W-f3+top)
  ctx.closePath()
  ctx.fill()
  ctx.restore()
}
/*
function concentriccirc() {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let r = canvas.width/2
  let f1 = r/4
  let x = r, y = r
  let grunge = document.getElementById("grungy").checked
  ctx.globalAlpha = document.getElementById("opacity").value/100
  clip()
  ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
  if (grunge)
    ctx.fillStyle = randomColor()
  ctx.fillRect(0,0,canvas.width,canvas.height)
  ctx.beginPath();
  ctx.arc(x, y, r, 0, 2*Math.PI);
  ctx.closePath()
  ctx.fill()

  r -= f1
  ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
  if (grunge)
    ctx.fillStyle = randomColor()
  ctx.beginPath();
  ctx.arc(x, y, r, 0, 2*Math.PI);
  ctx.closePath()
  ctx.fill()

  r -= f1
  ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
  if (grunge)
    ctx.fillStyle = randomColor()
  ctx.beginPath();
  ctx.arc(x, y, r, 0, 2*Math.PI);
  ctx.closePath()
  ctx.fill()

  r -= f1
  ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
  if (grunge)
    ctx.fillStyle = randomColor()
  ctx.beginPath();
  ctx.arc(x, y, r, 0, 2*Math.PI);
  ctx.closePath()
  ctx.fill()
  ctx.restore()
}

function concentric () {
  if (Math.random() > 0.5)
    concentriccirc()
  else
    concentricrect()
}

function concentricrect () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width
  let f1 = W/8
  let f2 = 2* f1
  let f3 = 3 * f1
  let len = W/2, maxy = W/2
  let quat = len/2
  // 4 rects
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let grunge = document.getElementById("grungy").checked

  clip()
  ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
  if (grunge)
    ctx.fillStyle = randomColor()
  ctx.beginPath();
  ctx.moveTo(0, 0)
  ctx.lineTo(W, 0)
  ctx.lineTo(W, W)
  ctx.lineTo(0, W)
  ctx.closePath()
  ctx.fill()

  ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
  if (grunge)
    ctx.fillStyle = randomColor()
  ctx.beginPath();
  ctx.moveTo(f1, f1)
  ctx.lineTo(W-f1, f1)
  ctx.lineTo(W-f1, W-f1)
  ctx.lineTo(f1, W-f1)
  ctx.closePath()
  ctx.fill()

  ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
  if (grunge)
    ctx.fillStyle = randomColor()
  ctx.beginPath();
  ctx.moveTo(f2, f2)
  ctx.lineTo(W-f2, f2)
  ctx.lineTo(W-f2, W-f2)
  ctx.lineTo(f2, W-f2)
  ctx.closePath()
  ctx.fill()

  ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette()) // was paintcolor)
  if (grunge)
    ctx.fillStyle = randomColor()
  ctx.beginPath();
  ctx.moveTo(f3, f3)
  ctx.lineTo(W-f3, f3)
  ctx.lineTo(W-f3, W-f3)
  ctx.lineTo(f3, W-f3)
  ctx.closePath()
  ctx.fill()
  ctx.restore()
}*/


function chipAt (x,y,big) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.globalAlpha = document.getElementById("opacity").value/100
  //let maxdist = Math.pow(Math.pow(cx, 2) + Math.pow(cy, 2), 0.5) +200
  let r = 0.5 + Math.random()*0.2
  if (big)
    r += Math.random() * 1
  //ctx.fillStyle = "#ffffff"//randomPick(getCurrentPalette()) // was paintcolor
  for (var t = 0; t < 1; t++) {
    let radius = r + pet(r/2)
    let r0 = radius
    angle = Math.random() * 6.42
    ctx.beginPath();
    var cent = x//Math.random()*ctx.canvas.width+50;
    var centy = y//Math.random()*ctx.canvas.height+50;
    var edges = 13+Math.random()*16;
    let max = Math.PI * 1.4
    let increase = Math.PI * 2/edges;
    let turn = 0
    for (var i = 0; i < 100; i++) {
      increase += Math.random()/100
      radius = r0+pet(r/2)
      radius += radius * i%2*1.2
      x = radius * Math.cos(angle)+cent;
      y = radius * Math.sin(angle)+centy;
      ctx.lineTo(x, y);
      angle += increase;
      turn += increase
      if (turn >= max)
        break;
    }
    ctx.closePath();
    ctx.fill()
  }
}

function chips () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let cx = ctx.canvas.width/2;
  let cy = ctx.canvas.height/2;
  let maxdist = Math.pow(Math.pow(cx, 2) + Math.pow(cy, 2), 0.5) +200
  let r = 2 + document.getElementById("featuresize").value/10
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  for (var t = 0; t < 5; t++) {
    let radius = r + pet(r/2)
    let r0 = radius
    x = 0;
    y = 0;
    angle = Math.random() * 6.42
    ctx.beginPath();
    var cent = Math.random()*ctx.canvas.width+50;
    var centy = Math.random()*ctx.canvas.height+50;
    var edges = 3+Math.random()*26;
    let max = Math.PI * 1.4
    let increase = Math.PI * 2/edges;
    let turn = 0
    for (var i = 0; i < 100; i++) {
      increase += Math.random()/100
      radius = r0+pet(r/2)
      x = radius * Math.cos(angle)+cent;
      y = radius * Math.sin(angle)+centy;
      ctx.lineTo(x, y);
      angle += increase;
      turn += increase
      if (turn >= max)
        break;
    }
    ctx.closePath();
    ctx.fill()
  }
}

function chaze () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let G = document.getElementById("grungy").checked
  let multiplier = 1.5
  if (G)
    multiplies = 3
  let x = canvas.width/2 + pet(170)
  let y = canvas.height/2 + pet(170)
  let x1 = canvas.width/2 + pet(300)
  let y1 = canvas.height/2 + pet(300)
  let r = x * (multiplier + Math.random()/2)
  let r1 = r/5
  let rg = ctx.createRadialGradient(x, y, r, x1, y1, r1)
  let col1 = randomPick(getCurrentPalette()) // was paintcolor
  let col2 = "rgba("+hexToR(col1)+", "+hexToG(col1)+", "+hexToB(col1)+", 0.0)";// transparent
  rg.addColorStop(0.01, col1);
  rg.addColorStop(document.getElementById("opacity").value/100, col2);
  ctx.fillStyle = rg
  ctx.fillRect(0,0,canvas.width, canvas.height)
}

function rectify () {
  let width = document.getElementById("featuresize").value/5
  width = (100 - width + 2)
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let W = 2 + Math.floor(document.getElementById("featuresize").value/10)
  let wdivs = W
  let cw = canvas.width
  let ch = canvas.height
  let w = cw/wdivs
  let hdivs = Math.round(wdivs * ch/cw)
  let h = ch/hdivs
  let i = 0, x = w, y = 0
  let N =(1+wdivs) * (1+hdivs)
  for (; i < N; i++) {
    if (Math.random() < 0.5)
      hazeRect(x, y, x+w, y-h)
    x += w
    if (x >= (wdivs)*w) {
      x = 0
      y += h
    }
  }
}

function hazeRect (x1, y1, x2, y2) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.fillStyle = randomGradientRect(canvas, randomPick(getCurrentPalette())) // was paintcolor, x1, y1, x2, y2, true)
  let sx = (x1<x2)? x1:x2
  let lx = (x1>x2)? x1:x2
  
  let sy = (y1<y2)? y1:y2
  let ly = (y1>y2)? y1:y2
  
  ctx.fillRect(sx,sy,lx-sx,ly-sy)
}

function haze () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  ctx.globalAlpha = document.getElementById("opacity").value/100
  //clip()
  ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
  ctx.fillRect(0,0,canvas.width, canvas.height)
  //ctx.restore()
}

function make4to5 (all) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let mode = ctx.globalCompositeOperation
  let alpha = document.getElementById("opacity").value
  W = canvas.width
  H = canvas.height
  let ratio = W/H
  if (ratio == 0.8)
    return
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let canvasoff = document.getElementById("off")
  let ctxoff = canvasoff.getContext("2d")
  canvasoff.width = canvas.width
  canvasoff.height = canvas.height
  ctxoff.drawImage(canvas,0,0)
  let pad = 0, x = 0, y = 0
  if (ratio > 0.8) { // too wide: increase height
    pad = 5 * W/4
    canvas.height = pad
    y = (canvas.height-H)/2
  } else
  if (ratio < 0.8) { // too tall: increase width
    pad = 4 * H/5
    canvas.width = pad
    x = (canvas.width-W)/2
  }
  syncBackground(canvas)
  ctx.drawImage(canvasoff, x, y)
  canvasoff.width = canvas.width
  canvasoff.height = canvas.height
  ctx.globalCompositeOperation = mode
  ctx.globalAlpha = alpha/100
  syncMarker()
}


function cropSquare (top) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let mode = ctx.globalCompositeOperation
  let alpha = document.getElementById("opacity").value
  W = canvas.width
  H = canvas.height
  //if (W == H)
  //  return
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let canvasoff = document.getElementById("off")
  let ctxoff = canvasoff.getContext("2d")
  canvasoff.width = canvas.width
  canvasoff.height = canvas.height
  ctxoff.drawImage(canvas,0,0)
  let pad = 0, x = 0, y = 0
  if (H > W) {
    y -= (H-W)/2
    if (top)
      y = 0
    canvas.height -= (H-W)
  } else
  if (W > H) {
    x -= (W-H)/2
    if (top)
      x = 0
    canvas.width -= (W-H)
  }
  syncBackground(canvas)
  ctx.drawImage(canvasoff, x, y)
  canvasoff.width = canvas.width
  canvasoff.height = canvas.height
  ctx.globalCompositeOperation = mode
  ctx.globalAlpha = alpha/100
  syncMarker()
}

function makeSquare (all) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let mode = ctx.globalCompositeOperation
  W = canvas.width
  H = canvas.height
  if (W == H)
    return
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let alpha = document.getElementById("opacity").value
  let canvasoff = document.getElementById("off")
  let ctxoff = canvasoff.getContext("2d")
  canvasoff.width = canvas.width
  canvasoff.height = canvas.height
  ctxoff.drawImage(canvas,0,0)
  let pad = 0, x = 0, y = 0
  if (H > W) {
    x = (H-W)/2
    canvas.width += (H-W)
  } else
  if (W > H) {
    y = (W-H)/2
    canvas.height += (W-H)
  }
  syncBackground(canvas)
  ctx.drawImage(canvasoff, x, y)
  canvasoff.width = canvas.width
  canvasoff.height = canvas.height
  ctx.globalCompositeOperation = mode
  ctx.globalAlpha = alpha/100
  syncMarker()
}

function expandMarginsDown() {
  expandMargins()
}

function expandMarginsAll() {
  expandMargins(true)
}

function expandMargins (all) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let mode = ctx.globalCompositeOperation
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let alpha = document.getElementById("opacity").value
  let canvasoff = document.getElementById("off")
  let ctxoff = canvasoff.getContext("2d")
  let grunge = document.getElementById("grungy").checked
  let value = +document.getElementById("rednumber").value

  canvasoff.width = canvas.width
  canvasoff.height = canvas.height
  ctxoff.drawImage(canvas,0,0)
  W = canvas.width
  if (all)
    canvas.width += value
  H = canvas.height
  if (!all && grunge)
    canvas.height *= 2
  else
    canvas.height += value
  let yoffset = 0
  if (all)
    yoffset = (canvas.height-H)/2
  ctx.drawImage(canvasoff, (canvas.width-W)/2, yoffset)
  
  syncMarker()
  canvasoff.width = canvas.width
  canvasoff.height = canvas.height
  ctx.globalCompositeOperation = mode
  ctx.globalAlpha = alpha/100
  syncBackground(canvas)
}

function tiltshift () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let mode = ctx.globalCompositeOperation
  let alpha = document.getElementById("opacity").value
  clearOff()
  copyToOff()
  copyToOff()
  fadeDown()
  smeardown2()
  document.getElementById("opacity").value = alpha
  ctx.globalAlpha = alpha/100
  ctx.globalCompositeOperation = "destination-over"
  document.getElementById("mode").value = "destination-over"
  ctx.globalAlpha = 1.0
  pasteFromOff()
  ctx.globalAlpha = alpha/100
  document.getElementById("opacity").value = alpha
  ctx.globalCompositeOperation = mode
  document.getElementById("mode").value = mode
}

function opacity100 () {
  document.getElementById("opacity").value = 100
  return true
}
function invertLASTCLICK () {
  let h = document.getElementById("myCanvas").height
  LASTCLICK[1] = h - LASTCLICK[1]
  return true
}

function sourceOver () {
  let ctx = document.getElementById("myCanvas").getContext("2d")
  ctx.globalCompositeOperation = "source-over"
  return true
}

function destinationOver () {
  let ctx = document.getElementById("myCanvas").getContext("2d")
  ctx.globalCompositeOperation = "destination-over"
  return true
}

function motionblur (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let alpha = ctx.globalAlpha = document.getElementById("opacity").value
  let step = document.getElementById("featuresize").value
  let stepsize = step
  let grunge = document.getElementById("grungy").checked
 // let maxangle = 9
  if (grunge) {
    stepsize *= 1.5
  }
  ctx.globalAlpha = document.getElementById("opacity").value/200

  let dir = [5 + (Math.random()-0.5) * stepsize, 5 + (Math.random()-0.5) * stepsize]
  smearrandom(canvas, dir)
  dir[0] += pet(23), dir[1] += pet(23)
  smearrandom(canvas, dir)
  dir[0] += pet(23), dir[1] += pet(23)
  smearrandom(canvas, dir)
 // dir[0] += pet(23), dir[1] += pet(23)
 // smearrandom(canvas, dir)

  ctx.globalAlpha = alpha/100
  document.getElementById("opacity").value = alpha
}

function ripinhalf () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let top = document.createElement('CANVAS')
  top.width = canvas.width, top.height = canvas.height
  let topctx = top.getContext("2d")
  let bottom = document.createElement('CANVAS')
  bottom.width = canvas.width, bottom.height = canvas.height
  let bottomctx = bottom.getContext("2d")

  let sign =(Math.random() > 0.5)? 1: -1;
  let angle = 2 + 24 * Math.random()
  angle *= sign * -1
  let p = pet(50)
  topctx.translate(top.width/2+p, top.height/2+p)
  topctx.rotate(angle*Math.PI/180)
  topctx.translate(-(top.width/2+p), -(top.height/2+p))
  topctx.drawImage(canvas,0,0, bottom.width, bottom.height/2, 0, 0, canvas.width, canvas.height/2)
  ctx.clearRect(0, 0, canvas.width, canvas.height/2) // clear top rect
  angle = 2 + 24 * Math.random()
  angle *= sign
  p = pet(50)
  bottomctx.translate(bottom.width/2+p, bottom.height/2+p)
  bottomctx.rotate(angle*Math.PI/180)
  bottomctx.translate(-(bottom.width/2+p), -(bottom.height/2+p))
  bottomctx.drawImage(canvas, 0, 0)
  ctx.clearRect(0,0,canvas.width, canvas.height)
  if (Math.random() >= 0.5) {
    ctx.drawImage(bottom,0,0)
    ctx.drawImage(top, 0, 0)
  } else {
    ctx.drawImage(top, 0, 0)
    ctx.drawImage(bottom,0,0)
  }
}

function duplicate () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let top = document.createElement('CANVAS')
  top.width = canvas.width, top.height = canvas.height
  let topctx = top.getContext("2d")
  ctx.clearRect(0,0,canvas.width, canvas.height/4)
  ctx.clearRect(0,Math.round(canvas.height * 0.75) ,canvas.width, canvas.height)
  topctx.drawImage(canvas,0,0)//, bottom.width, bottom.height/2, 0, 0, canvas.width, canvas.height/2)
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(top, 0, canvas.height/4)
  ctx.drawImage(top, 0, -canvas.height/4)
}


function halfRip_mod () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = canvas.height, W = canvas.width
  let grunge = document.getElementById("grungy").checked
  let s = document.getElementById("featuresize").value/500
  let half = W*s
  let lx = LASTCLICK[0]
  const offset = 2 + W/100
  let x = 0, y = 0
  x = 0, y = 0
  ctx.save()
  ctx.beginPath()
  ctx.moveTo(x,y)
  x = lx + pet(50)//half-offset
  ctx.lineTo(x, y)
  H += 40
  while (y <= H) {
    x += pet(9)
    y += 9 + pet(4)
    ctx.lineTo(x, y)
    if (Math.random() > 0.95)
      x += pet(60)
    if (Math.random() > 0.95)
      y += 39
  }
  ctx.lineTo(0, y)
  ctx.closePath()
  ctx.clip()
  let color = (Math.random() > 0.5)? "#000000": "#ffffff";
  ctx.fillStyle = randomGradient(canvas, color)
  ctx.globalAlpha = 0.3
  ctx.fillRect(0,0,canvas.width, canvas.height)
  ctx.restore()
  ctx.restore()
}

function ripShade () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let alpha = document.getElementById("opacity").value
  // clip to ragged edge region
  ctx.save()
  
  //left rip
  let color = (Math.random() > 0.5)? "#000000": "#ffffff";
  ctx.fillStyle = randomGradient(canvas, color)
  ctx.globalAlpha = 0.2
  ctx.fillRect(0,0,canvas.width, canvas.height)
  ctx.restore()
  ctx.globalAlpha = alpha/100
}

function crumple () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let H = canvas.height, W = canvas.width
  let increase = Math.PI * 2 / 40;
  let x = 0, y = 0, angle = 4.7;
  ctx.globalAlpha = 0.05
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = document.getElementById("mode").value
  const numshapes = 10 + Math.random() * 5;
  let radius = (H+W)/3
  const maxradius = (H+W)/3
  for (var t = 0; t < numshapes; t++) {
    var centx = Math.random()*W;
    var centy = Math.random()*H;
    var edges = Math.random()*25+10;
    x = 0;
    y = 0;
    var x0 = x;
    var y0 = y;
    angle = Math.floor(Math.random() * 6.42);
    ctx.beginPath();
    increase = Math.PI * 2/edges*0.98;
    points = [];
    bez = [];
    let maxx = -1000000000, maxy = -1000000000, minx = 1000000000, miny = 1000000000
    for (var i = 0; i < edges; i++) {
      radius = Math.random() * maxradius*.4 + maxradius;
      x = radius * Math.cos(angle)+centx;
      y = radius * Math.sin(angle)+centy;
      var cp1x = radius * Math.cos(angle)+centx;
      var cp1y = radius * Math.sin(angle)+centy;
      var cp2x = radius * Math.cos(angle-(0.3*increase))+centx;
      var cp2y = radius * Math.sin(angle-(0.3*increase))+centy;
      var fx = (Math.random()-0.5)*30;
      var fy = (Math.random()-0.5)*30;
      sx = radius * 0.9 * Math.cos(angle)+centx+fx;
      sy = radius * 0.9 * Math.sin(angle)+centy+fy;
      var icp1x = 0.9*radius * Math.cos(angle)+centx+fx;
      var icp1y = 0.9*radius * Math.sin(angle)+centy+fy;
      var icp2x = 0.9*radius * Math.cos(angle-(0.3*increase))+centx+fx;
      var icp2y = 0.9*radius * Math.sin(angle-(0.3*increase))+centy+fy;
      points.push([sx, sy]);
      maxx = (maxx > sx)? maxx: sx;
      maxy = (maxy > sy)? maxy: sy;
      minx = (minx < sx)? minx: sx;
      miny = (miny < sy)? miny: sy;
      bez.push([icp1x, icp1y, icp2x, icp2y]);
      if (i == 0) {
        x0 = x;
        y0 = y;
        ctx.moveTo(x,y);
      } else
        ctx.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y);
      angle += increase;
    }
    ctx.lineTo(x0,y0);
    ctx.closePath();
    ctx.beginPath();
    for (var i = 0; i < points.length; i++) {
      x = points[i][0]-100;
      y = points[i][1]-100;
      if (i == 0) {
        x0 = x;
        y0 = y;
      }
      ctx.bezierCurveTo(bez[i][0], bez[i][1],bez[i][2],bez[i][3], points[i][0], points[i][1]);
    }
    ctx.closePath();
    if (Math.random() > 0.5)
      ctx.fillStyle = randomGradientRect(canvas, "#ffffff", minx+Math.random() * (maxx-minx), miny+Math.random() * (maxy-miny),  minx+Math.random() * (maxx-minx), miny+Math.random() * (maxy-miny))
    else
      ctx.fillStyle = randomGradientRect(canvas, "#000000", minx+Math.random() * (maxx-minx), miny+Math.random() * (maxy-miny),  minx+Math.random() * (maxx-minx), miny+Math.random() * (maxy-miny))
    ctx.fill();
    centx = Math.random()*W;
    centy = Math.random()*H;
  }
  ctx.globalCompositeOperation = mode
}

function fourXfour () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let alpha = document.getElementById("opacity").value
  let alt = document.getElementById("grungy").checked
  let colors = getCurrentPalette()
  let bnw = ["#ffffff", "#000000"]
  ctx.globalAlpha = alpha/100
  let i = 0, j = 0, w = canvas.width/4, h = canvas.height/4
  let x1 = canvas.width/2, y1 = 0, x2 = canvas.width/2, y2 = canvas.height/4
  let t = 0, cnt = 0
  for (; i < 4; i++) {
    j = 0
    for (; j < 4; j++) {
      x1 = i*w, x2 = x1+w
      y1 = j*h, y2 = y1+h
      if (j % 2 === 0) {
        t = x1
        x1 = x2
        x2 = t
      }
      if (i % 2 === 0) {
        t = y1
        y1 = y2
        y2 = t
      }
      if (alt)
        ctx.fillStyle = randomGradientRect(canvas, bnw[cnt%2], x1, y1, x2, y2)
      else
        ctx.fillStyle = randomGradientRect(canvas, randomPick(colors), x1, y1, x2, y2)
      ctx.fillRect(i*w,j*h,w,h)
      cnt++
    }
    cnt--
  }
}


function fourfold () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let nudge = canvas.height/20
  let alpha = document.getElementById("opacity").value
  let colors = (["#ffffff", "#000000"])
  ctx.globalAlpha = 0.1
  let x1 = canvas.width/2, y1 = 0, x2 = canvas.width/2, y2 = canvas.height/4
  ctx.fillStyle = randomGradientRect(canvas, colors[1], x1, y1, x2, y2 + nudge)
  ctx.fillRect(0,0,canvas.width,canvas.height/4)
  
  y1 = canvas.height/4, y2 = 2*canvas.height/4
  ctx.fillStyle = randomGradientRect(canvas, colors[0], x1, y1, x2, y2 - nudge)
  ctx.fillRect(0, canvas.height/4, canvas.width, 2*canvas.height/4)

  y1 = 2*canvas.height/4, y2 = 3*canvas.height/4
  ctx.fillStyle = randomGradientRect(canvas, colors[1], x1, y1, x2, y2 - nudge)
  ctx.fillRect(0, 2*canvas.height/4, canvas.width, 3*canvas.height/4)
  
  y1 = 3*canvas.height/4, y2 = canvas.height
  ctx.fillStyle = randomGradientRect(canvas, colors[0], x1, y1, x2, y2 - nudge)
  ctx.fillRect(0, 3*canvas.height/4, canvas.width, canvas.height)
  ctx.globalAlpha = alpha/100
}

function trifold () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let nudge = canvas.height/20
  let alpha = document.getElementById("opacity").value
  let colors = (["#ffffff", "#000000"])
  ctx.globalAlpha = 0.1
  let x1 = canvas.width/2, y1 = 0, x2 = canvas.width/2, y2 = canvas.height/3
  ctx.fillStyle = randomGradientRect(canvas, colors[1], x1, y2, x2, y1 + nudge)
  ctx.fillRect(0,0,canvas.width,canvas.height/3)
  
  y1 = canvas.height/3, y2 = 2*canvas.height/3
  ctx.fillStyle = randomGradientRect(canvas, colors[0], x1, y1, x2, y2 - nudge)
  ctx.fillRect(0, canvas.height/3, canvas.width, 2*canvas.height/3)

  y1 = 2*canvas.height/3, y2 = canvas.height
  ctx.fillStyle = randomGradientRect(canvas, colors[1], x1, y1, x2, y2 - nudge)
  ctx.fillRect(0, 2*canvas.height/3, canvas.width, canvas.height)
  ctx.globalAlpha = alpha/100
}

function stiches (pad) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let alpha = document.getElementById("opacity").value
  ctx.fillStyle = "#cccccc"
  ctx.globalAlpha = 1
  ctx.shadowColor = "#ffffff"
  ctx.shadowBlur = 7 + Math.random() * 1
  ctx.shadowOffsetY = -3//2+ Math.random() * 1
  ctx.shadowOffsetX = -4 + Math.random() * 1
  let i = 1
  let h = (canvas.height - pad*2)/9
  let x = canvas.width/2-1, y = 0
  for (; i < 9; i++) {
    ctx.beginPath()
    y = i*h+pad
    ctx.moveTo(x,y)
    ctx.arc(x+pet(1),y,3+pet(1),0,Math.PI*2)
    ctx.fill()
    ctx.closePath()
  }
  ctx.shadowBlur = 0
  ctx.shadowOffsetY = 0
  ctx.shadowOffsetX = 0
  ctx.globalAlpha = alpha/100
}

function afoldAt (pad) {
  if (!pad)
    pad = 0
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let alpha = document.getElementById("opacity").value
  let colors = (["#000000", "#ffffff"])
  let x1 = canvas.width/2, y1 = 0, x2 = canvas.width/2, y2 = canvas.height/2
  ctx.fillStyle = randomGradientRect(canvas, colors[0], x1, y1, x2, y2 - Math.random() * canvas.width/3)
  ctx.globalAlpha = 0.2

  console.log(LASTCLICK[1])
  y1 = LASTCLICK[1], y2 = LASTCLICK[1]+80
  ctx.fillStyle = randomGradientRect(canvas, colors[1], x1, y1, x2, y2)// - Math.random() * canvas.width/3)
  ctx.fillRect(pad,LASTCLICK[1], canvas.width-pad*2, LASTCLICK[1]+240)
  
  ctx.globalAlpha = alpha/100
}
  
function afold (pad) {
  rcc()
  if (!pad)
    pad = 0
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let alpha = document.getElementById("opacity").value
  let colors = (["#000000", "#ffffff"])
  let x1 = canvas.width/2, y1 = 0, x2 = canvas.width/2, y2 = canvas.height/2
  ctx.fillStyle = randomGradientRect(canvas, colors[0], x1, y1, x2, y2 - Math.random() * canvas.width/3)
  ctx.globalAlpha = 0.2
  ctx.fillRect(pad,0,canvas.width-pad*2,canvas.height/2)
  y1 = canvas.height/2, y2 = canvas.height
  ctx.fillStyle = randomGradientRect(canvas, colors[0], x1, y1, x2, y2 - Math.random() * canvas.width/3)
  ctx.fillRect(pad,canvas.height/2, canvas.width-pad*2, canvas.height)
 
 // if pad ??
  
  y1 = canvas.height/2, y2 = canvas.height/2-80
  ctx.fillStyle = randomGradientRect(canvas, colors[1], x1, y1, x2, y2)// - Math.random() * canvas.width/3)
  ctx.fillRect(pad,canvas.height/2 - 140, canvas.width-pad*2, 140)
  
  y1 = canvas.height/2, y2 = canvas.height/2+13+Math.random()*11
  ctx.fillStyle = randomGradientRect(canvas, "#202020", x1, y1, x2, y2)// - Math.random() * canvas.width/3)
  ctx.fillRect(pad,canvas.height/2, canvas.width-pad*2, 40+Math.random() *15)
  ctx.globalAlpha = alpha/100
  rc()
}

function dfold () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let alpha = document.getElementById("opacity").value
 // ctx.clearRect(0,0,canvas.width, canvas.height/2)
  ctx.fillStyle = randomGradient(canvas, "#ffffff")
  ctx.globalAlpha = 0.2
  ctx.beginPath()
  ctx.moveTo(0,0)
  ctx.lineTo(canvas.width,canvas.height)
  ctx.lineTo(0,canvas.height)
  ctx.closePath()
  ctx.fill()
  
  ctx.fillStyle = randomGradient(canvas, "#000000")
  ctx.beginPath()
  ctx.moveTo(0,0)
  ctx.lineTo(canvas.width,canvas.height)
  ctx.lineTo(canvas.width,0)
  ctx.closePath()
  ctx.fill()
  
  ctx.globalAlpha = alpha/100
}

function snow (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let H = canvas.height;
  let W = canvas.width;
  let N = document.getElementById("number").value/10
  let SIZE = 0.5+document.getElementById("featuresize").value/50
  let alpha = document.getElementById("opacity").value
  let i = 0, x, y, scale = 1, dx=1, dy=1
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineCap = "round"
  let maxAlpha = alpha/100
  dx = 2+Math.random()*4, dy = 2+Math.random()*4
  if (Math.random() > 0.5) dx *= -1
  if (Math.random() > 0.5) dy *= -1
  for (; i < N; i++) {
    x = -50 + Math.random() * (W+100)
    y = -50 + Math.random() * (H+100)
    scale = 1 + Math.random() * 23
    ctx.globalAlpha = Math.random() * maxAlpha
    ctx.lineWidth = Math.min(scale/2, SIZE)
    ctx.beginPath()
    ctx.moveTo(x,y)
    ctx.lineTo(x+dx*(scale+pet(scale)), y+dy*(scale+pet(scale)))
    ctx.stroke()
  }
  ctx.globalAlpha = alpha/100
}

function nudgeCW () {
  nudgeCWorCCW()
}

function nudgeCCW () {
  nudgeCWorCCW(true)
}

function nudgeCWorCCW (cc, canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let h = canvas.height;
  let w = canvas.width;
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  let alpha = document.getElementById("opacity").value
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let angle = +document.getElementById("rednumber").value
  angle *= Math.PI/180
  if (cc)
    angle *= -1
  let x = LASTCLICK[0]
  let y = LASTCLICK[1]
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  ctx.drawImage(canvas,-x,-y,canvas.width, canvas.height)
  ctx.restore();
  ctx.globalAlpha = alpha/100
}

function rotateRandom (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let h = canvas.height;
  let w = canvas.width;
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  let alpha = document.getElementById("opacity").value
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let angle = (Math.random()-0.5) * 11
  angle *= Math.PI/180
  let x = w/2
  let y = h/2
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  ctx.drawImage(canvas,-x,-y,canvas.width, canvas.height)
  ctx.restore();
  ctx.globalAlpha = alpha/100
}

function shaken () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let canvasoff = document.createElement("CANVAS")
  let ctxoff = canvasoff.getContext("2d")
  let alt = document.getElementById("grungy").checked
  let a = document.getElementById("opacity").value/100
  let dh = 3+document.getElementById("featuresize").value/2
  canvasoff.width = canvas.width
  canvasoff.height = canvas.height
  ctx.globalAlpha = a
  ctxoff.globalAlpha = 0.2
  ctxoff.drawImage(canvas, 0, 0)
  let i = 0
  let d = 0
  let N = 9
  for (; i < N; i++) {
    d = 5 + Math.random() * dh
    if (Math.random() > 0.5)
      d *= -1
    if (Math.random() > 0.1)
      ctx.drawImage(canvasoff, d, 0)
    else
      ctx.drawImage(canvasoff, 0, d)
    if (alt && i % 2 === 0) {
      contrastImage(5)
    }
  }
  ctx.globalAlpha = 1
}


function nudgeRight () {
  nudgeCanvas(true)
}

function nudgeDown () {
  nudgeCanvas(false)
}

function nudgeCanvas (right) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let mode = ctx.globalCompositeOperation
  ctx.globalAlpha = 1.0//document.getElementById("opacity").value/100
  let alpha = document.getElementById("opacity").value
  let canvasoff = document.getElementById("off")
  let ctxoff = canvasoff.getContext("2d")
  let value = +document.getElementById("rednumber").value
  canvasoff.width = canvas.width
  canvasoff.height = canvas.height
  ctxoff.drawImage(canvas,0,0)
  ctx.clearRect(0,0,canvas.width, canvas.height)
  if (right)
    ctx.drawImage(canvasoff, value, 0)
  else
    ctx.drawImage(canvasoff, 0, value)
  ctxoff.clearRect(0,0,canvasoff.width, canvasoff.height)
  ctx.globalAlpha = alpha/100
}

async function fillA (canvas, fs) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  if (fs)
    ctx.fillStyle = fs
  await ctx.fillRect(0,0,canvas.width, canvas.height)
  return true
}

async function fill (canvas, fs) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let gco = ctx.globalCompositeOperation
  let sel = document.getElementById("mode").value
  if (gco !== sel) {
    ctx.globalCompositeOperation = sel
  }
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  if (fs)
    ctx.fillStyle = fs
  ctx.imageSmoothingQuality = 'high'
  await ctx.fillRect(0,0,canvas.width, canvas.height)
  return true
}

function hazeo () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
  let G = document.getElementById("grungy").checked
  if ((G && Math.random() > 0.7) || !G)
    ctx.fillRect(0,0,canvas.width, canvas.height)
}

function stack_rc () {
  pushFunction("rc")
  rc()
}

function stack_rcc () {
  pushFunction("rcc")
  rcc()
}

function stack_flipV () {
  pushFunction("flipV")
  flipV()
}

function stack_flipH () {
  pushFunction("flipH")
  flipH()
}

function rc (canvas) {
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "source-over"
  let a = ctx.globalAlpha
  ctx.globalAlpha = 1.0
  let cx = canvas.height/2, cy = canvas.width/2
  ocanvas.height = (canvas.height > canvas.width)? canvas.height: canvas.width
  ocanvas.width = (canvas.height > canvas.width)? canvas.height: canvas.width
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  octx.drawImage(canvas, 0, 0)
  let swap = canvas.height
  canvas.height = canvas.width
  canvas.width = swap
  syncBackground(canvas)
  cx = canvas.height/2, cy = canvas.width/2
  ctx.translate(cy, cx)
  ctx.rotate(Math.PI * 0.5)
  ctx.translate(-cx,-cy)
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(ocanvas, 0, 0)
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  ctx.setTransform(1,0,0,1,0,0)
  ctx.drawImage(ocanvas,0,0,canvas.width,canvas.height)
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  ctx.globalAlpha = a
  refreshMode()
  ctx.globalCompositeOperation = mode
  syncMarker()
}

function rcc (canvas) {
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "source-over"
  let a = ctx.globalAlpha
  ctx.globalAlpha = 1.0
  let cx = canvas.height/2, cy = canvas.width/2
  ocanvas.height = (canvas.height > canvas.width)? canvas.height: canvas.width
  ocanvas.width = (canvas.height > canvas.width)? canvas.height: canvas.width
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  octx.drawImage(canvas, 0, 0)
  let swap = canvas.height
  canvas.height = canvas.width
  canvas.width = swap
  syncBackground(canvas)
  cx = canvas.height/2, cy = canvas.width/2
  ctx.translate(cy, cx)
  ctx.rotate(Math.PI * -0.5)
  ctx.translate(-cx,-cy)
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(ocanvas, 0, 0)
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  ctx.setTransform(1,0,0,1,0,0)
  ctx.drawImage(ocanvas,0,0,canvas.width,canvas.height)
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  ctx.globalAlpha = a
  refreshMode()
  syncMarker()
  ctx.globalCompositeOperation = mode
}

function flipH () {
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "source-over"
  let a = ctx.globalAlpha
  ctx.globalAlpha = 1.0
  ocanvas.height = canvas.height
  ocanvas.width = canvas.width
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  octx.drawImage(canvas, 0, 0)
  ctx.translate(canvas.width, 0)
  ctx.scale(-1,1)
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(ocanvas, 0, 0)
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  ctx.setTransform(1,0,0,1,0,0)
  ctx.globalAlpha = a
  ctx.globalCompositeOperation = mode
  return true
}

function flipV () {
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "source-over"
  let a = ctx.globalAlpha
  ctx.globalAlpha = 1.0
  ocanvas.height = canvas.height
  ocanvas.width = canvas.width
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  octx.drawImage(canvas, 0, 0)
  ctx.translate(0, canvas.height)
  ctx.scale(1,-1)
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(ocanvas, 0, 0)
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  ctx.setTransform(1,0,0,1,0,0)
  ctx.globalAlpha = a
  //refreshMode()
  ctx.globalCompositeOperation = mode
  return true
}

function flipStrip () {
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let a = ctx.globalAlpha
  ctx.globalAlpha = 1.0
  ocanvas.height = canvas.height
  ocanvas.width = canvas.width
  let w = 40 + Math.random() * canvas.width/2
  let x = (canvas.width) * Math.random()
  octx.clearRect(0,0,canvas.width,ocanvas.height)
  octx.drawImage(canvas, 0, 0)
  octx.clearRect(0,0,x,ocanvas.height)
  octx.clearRect(x+w,0,ocanvas.width,ocanvas.height)
  ctx.translate(0, canvas.height)
  ctx.scale(1,-1)
  ctx.clearRect(x,0,w,canvas.height)
  ctx.drawImage(ocanvas, 0, 0)
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  ctx.setTransform(1,0,0,1,0,0)
  ctx.globalAlpha = a
}

function flipStripH () {
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let a = ctx.globalAlpha
  ctx.globalAlpha = 1.0
  ocanvas.height = canvas.height
  ocanvas.width = canvas.width
  let h = 40 + Math.random() * canvas.height/2
  let y = (canvas.height) * Math.random()
  octx.clearRect(0,0,canvas.width,ocanvas.height)
  octx.drawImage(canvas, 0, 0)
  octx.clearRect(0,0,canvas.width,y)
  octx.clearRect(0,y+h,ocanvas.width,ocanvas.height)
  ctx.translate(canvas.width, 0)
  ctx.scale(-1,1)
  ctx.clearRect(0,y,canvas.width, h)
  ctx.drawImage(ocanvas, 0, 0)
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  ctx.setTransform(1,0,0,1,0,0)
  ctx.globalAlpha = a
}

function pixelado () {
  slices()
  rc()
  slices()
  rcc()
}

function shred2 () {
  shred()
  clearOff()
  copyToOff()
  nudgeRight()
  copyToOff()
  nudgeDown()
  copyToOff()
  document.getElementById("rednumber").value *= -1
  nudgeRight()
  pasteFromOff()
}

function shred () {
  blasco()
  rc()
  blasco()
  rcc()
}

function slices () {
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let a = ctx.globalAlpha
  let grunge = document.getElementById("grungy").checked
  ctx.globalAlpha = 1.0
  ocanvas.height = canvas.height
  ocanvas.width = canvas.width
  let ch = canvas.height
  let h = 4 + Math.floor(document.getElementById("featuresize").value/2)
  let count = ch/h - 1
  let y = 0, i = 0
  for (;i < count; i++) {
    sliceH(y, h, ctx, octx, canvas, ocanvas)
    y += h
  }
  ctx.globalAlpha = a
}

function sliceH (y, h, ctx, octx, canvas, ocanvas) {
  octx.clearRect(0,0,canvas.width,ocanvas.height)
  octx.drawImage(canvas, 0, 0)
  octx.clearRect(0,0,canvas.width,y)
  octx.clearRect(0,y+h,ocanvas.width,ocanvas.height)
  ctx.translate(0,2*y+h)
  ctx.scale(1,-1)
  ctx.clearRect(0,y,canvas.width, h)
  ctx.drawImage(ocanvas, 0, 0)
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  ctx.setTransform(1,0,0,1,0,0)
}

function pasta () {
  pastaSlice()
  rc()
  pastaSlice()
  rcc()
}

function closediv (N, d) {
  if (N % d === 0)
    return d
  let i = 0
  let results = []
  for (; i < N; i++) {
    if (N % i == 0)
      results.push(i)
  }
  let min = N
  i = 0
  for (; i < results.length; i++) {
    if (results[i] - d >= 0)
      return results[i]
  }
  return d
}

function pastaSlice () {
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let a = ctx.globalAlpha
  let grunge = document.getElementById("grungy").checked
  ctx.globalAlpha = 1.0
  ocanvas.height = canvas.height
  ocanvas.width = canvas.width
  octx.drawImage(canvas, 0, 0)
  canvas.width *= 2
  canvas.height /= 2
  let ch = canvas.height
  let h = 4 + Math.floor(document.getElementById("featuresize").value/2)
  //h = closediv(canvas.height, h)
  let count = ch/h*2
  let y = 0, yon =0, i = 0
  for (;i < count; i++) {
    ctx.drawImage(ocanvas, 0, y, ocanvas.width, h, 0, yon, canvas.width/2, h);
    ctx.drawImage(ocanvas, 0, y+h, ocanvas.width, h, canvas.width/2, yon, canvas.width/2, h);
    y += h*2
    yon += h
  }
  ctx.globalAlpha = a
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
}
 
function reverse () { // rotate canvas at touch x,y. concentric circles
  let ocanvas = document.createElement("CANVAS")
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let grunge = document.getElementById("grungy").checked
  let h = 2 + Math.floor(document.getElementById("featuresize").value/10)
  let n = canvas.width/h/2
  let a = ctx.globalAlpha
  ctx.globalAlpha = 1.0
  octx.globalAlpha = 1.0
  ocanvas.height = canvas.height
  ocanvas.width = canvas.width
  let cx = canvas.width/2
  let cy = canvas.height/2
  let x = 0, y = 0
  let x2 = canvas.width, y2 = canvas.height
  let i = 0
  let angle = Math.PI
  if (grunge)
    angle /= 2
  octx.drawImage(ocanvas, 0,0)

  for (; i < n; i++) {
    ctx.save()
    ctx.beginPath()
    ctx.moveTo(x,y)
    ctx.lineTo(x2,y)
    ctx.lineTo(x2,y2)
    ctx.lineTo(x,y2)
    ctx.closePath()
    ctx.clip()
    octx.translate(cx, cy)
    octx.rotate(angle);
    octx.translate(-cx,-cy)
    octx.drawImage(canvas, 0, 0)
    ctx.drawImage(ocanvas, 0,0)
    ctx.restore()
    x += h
    y += h
    x2 -= h
    y2 -= h
  }
  ctx.globalAlpha = a
  octx = ocanvas.getContext('2d')
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
}

function rotateCent () { // rotate canvas at touch x,y. concentric circles
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let grunge = document.getElementById("grungy").checked
  let radius = 4 + Math.floor(document.getElementById("featuresize").value/2)
  let r0 = radius
  let n = canvas.width/radius
  let a = ctx.globalAlpha
  ctx.globalAlpha = 1.0
  octx.globalAlpha = 1.0
  ocanvas.height = canvas.height
  ocanvas.width = canvas.width
  let x = canvas.width/2
  let y = canvas.height/2
  x = LASTCLICK[0]
  y = LASTCLICK[1]
  let i = 0
  let angle = -Math.PI/n
  for (; i < n/2; i++) {
    octx.translate(x, y)
    octx.rotate(angle);
    octx.translate(-x,-y)
    ctx.save()
    octx.drawImage(canvas, 0, 0)
    ctx.beginPath()
    ctx.arc(x, y, radius, 0, 2*Math.PI)
    ctx.closePath()
    ctx.clip()
    ctx.drawImage(ocanvas, 0,0)
    octx.translate(x,y)
    octx.rotate(-angle);
    octx.translate(-x,-y)
    ctx.restore()
    radius += r0
  }
  ctx.globalAlpha = a
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
}

function rotateCirc () { // grip of rotated circles
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let grunge = document.getElementById("grungy").checked
  let n = 2 + Math.floor(document.getElementById("featuresize").value/20)
  // 27 ... 2 => 2 ... 27
  // max+min - n
  n = (27 + 2) - n
  let a = ctx.globalAlpha
  ctx.globalAlpha = 1.0
  ocanvas.height = canvas.height
  ocanvas.width = canvas.width
  let h = canvas.height/n
  let w = canvas.width/n
  let x = w/2
  let y = h/2
  let i = 0
  for (; i < n*n; i++) {
    if (i > 0 && i % (n) == 0) {
      x = w/2
      y += h
    }
    let angle = (Math.PI * (Math.random() - 0.5) * Math.PI/2)
    let radius = canvas.width/(n+1)/2
    if (grunge) {
      radius += pet(radius/2)
      x += pet(radius/2)
      y += pet(radius/2)
    }
    octx.translate(x, y)
    octx.rotate(angle);
    octx.translate(-x,-y)
    ctx.save()
    octx.drawImage(canvas, 0, 0)
    ctx.beginPath()
    ctx.arc(x, y, radius, 0, 2*Math.PI)
    ctx.closePath()
    ctx.clip()
    ctx.drawImage(ocanvas, 0,0)
    octx.translate(x,y)
    octx.rotate(-angle);
    octx.translate(-x,-y)
    ctx.restore()
    x += w
  }
  ctx.globalAlpha = a
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
}

function dots () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let grunge = document.getElementById("grungy").checked
  ctx.globalAlpha = 1.0
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let ch = canvas.height
  let h = 2 + Math.floor(document.getElementById("featuresize").value/4)
  let w = h
  let off = h/2
  let r = w/2
  let t = 0
  if (grunge) {
    t = 2
    r *= 0.7
  }
  let count = (canvas.height/h + 2) * (canvas.width/w + 2)
  let newline = Math.floor(canvas.width/w)+2
  let counter = 0
  let x = 0, y = 0
  let i = 0
  for (;i < count; i++) {
    ctx.beginPath()
    ctx.arc(x+w/2+pet(t),y+h/2+pet(t),r+pet(w/5),0,Math.PI*2)
    ctx.closePath()
    ctx.fill()
    x += w
    counter++
    if (i > 0 && newline == counter) {
      counter = 0
      x = -w/2
      y += h
      off *= -1
      x += off/2
    }
  }
}

function diamonds () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let grunge = document.getElementById("grungy").checked
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let ch = canvas.height
  let h = 4 + Math.floor(document.getElementById("featuresize").value/4)
  let w = h
  let off = 0

  let count = 4*(1+canvas.height/h) * (1+canvas.width/w)
  let newline = 2*Math.floor(canvas.width/w) + 1
  let counter = 0
  let x = 0, y = 0
  let i = 0
  ctx.save()
  ctx.beginPath()
  for (;i < count; i++) {
    ctx.moveTo(x+w/4,y)
    ctx.lineTo(x+w/2, y+h/4)
    ctx.lineTo(x+w/4, y+h/2)
    ctx.lineTo(x, y+h/4)
    x += w/2
    counter++
    if (i > 0 && newline == counter) {
      counter = 0
      x = 0
      y += h/2
    }
  }
  ctx.closePath()
  ctx.clip()
  ctx.clearRect(0,0,canvas.width, canvas.height)
  ctx.restore()
}

function checkerboard () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let grunge = document.getElementById("grungy").checked
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let ch = canvas.height
  let h = 4 + Math.floor(document.getElementById("featuresize").value/4)
  let w = h
  let off = -1
  let count = 2*(1+canvas.height/h) * (1+canvas.width/w)
  let newline = Math.floor(canvas.width/w) + 1
  let counter = 0
  let x = 0, y = 0
  let i = 0
  ctx.save()
  ctx.beginPath()
  for (;i < count; i++) {
    ctx.moveTo(x,y)
    ctx.lineTo(x+w/2, y)
    ctx.lineTo(x+w/2, y+h/2)
    ctx.lineTo(x, y+h/2)
    x += w
    counter++
    if (i > 0 && newline == counter) {
      counter = 0
      if (off < 0)
        x = w/2
      else
        x = 0
      y += h/2
      off *= -1
    }
  }
  ctx.closePath()
  ctx.clip()
  ctx.clearRect(0,0,canvas.width, canvas.height)
  ctx.restore()
}

function dashes (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let grunge = document.getElementById("grungy").checked
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let ch = canvas.height
  let h = 4 + Math.floor(document.getElementById("featuresize").value/4)
  let w = h/4
  let off = h/4
  let r = w/2
  let t = r
  if (grunge) {
    t = r*2
    r *= 1.4
  }
  ctx.lineCap = "round"
  ctx.lineWidth = r
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  let count = canvas.height/h * canvas.width/w * 4.3
  let newline = Math.floor(canvas.width/w) + 2
  let counter = 0
  let x = 0, y = 0
  let i = 0
  for (;i < count; i++) {
    ctx.save()
    ctx.beginPath()
    ctx.moveTo(x+pet(t), y+pet(t))
    ctx.lineTo(x+w/2+pet(t),y+pet(t))
    ctx.stroke()
    x += w
    counter++
    if (i > 0 && newline == counter) {
      counter = 0
      x = 0
      y += h/4
    }
  }
}
  
function holes2 (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let grunge = document.getElementById("grungy").checked
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let ch = canvas.height
  let h = 2 + Math.floor(document.getElementById("featuresize").value/4)
  let w = h
  let off = h/2
  let r = w/2
  let t = r
  if (grunge) {
    t = r*2
    r *= 1.4
  }
  let count = canvas.height/h * canvas.width/w
  let newline = Math.floor(canvas.width/w)
  let counter = 0
  let x = w, y = h/2
  let xo = 0, yo = 0, i = 0
  for (;i < count; i++) {
    ctx.save()
    ctx.beginPath()
    ctx.arc(x+w/2+pet(t),y+h/2+pet(t),r+pet(w/5),0,Math.PI*2)
    ctx.closePath()
    ctx.clip()
    ctx.clearRect(0,0,canvas.width, canvas.height)
    ctx.restore()
    x += w*1.8
    xo += w
    counter++
    if (i > 0 && newline == counter) {
      counter = 0
      x = w
      xo = 0
      y += 1.5*h
      yo += h
      off *= -1
      x =+ off
    }
  }
}

function holes () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let grunge = document.getElementById("grungy").checked
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let ch = canvas.height
  let h = 2 + Math.floor(document.getElementById("featuresize").value/4)
  let w = h
  let off = h/2
  let r = w/2
  let t = 0
  if (grunge) {
    t = r
    r *= 1.4
  }
  let count = canvas.height/h * canvas.width/w
  let newline = Math.floor(canvas.width/w)
  let counter = 0
  let x = w, y = h/2
  let xo = 0, yo = 0, i = 0
  for (;i < count; i++) {
    ctx.save()
    ctx.beginPath()
    ctx.arc(x+w/2+pet(t),y+h/2+pet(t),r+pet(w/5),0,Math.PI*2)
    ctx.closePath()
    ctx.clip()
    ctx.clearRect(0,0,canvas.width, canvas.height)
    ctx.restore()
    x += w*2
    xo += w
    counter++
    if (i > 0 && newline == counter) {
      counter = 0
      x = w
      xo = 0
      y += 2*h
      yo += h
      off *= -1
      x =+ off
    }
  }
}

function samplec () { // circular samples
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let a = ctx.globalAlpha
  let grunge = document.getElementById("grungy").checked
  ctx.globalAlpha = 1.0
  ocanvas.height = canvas.height
  ocanvas.width = canvas.width
  octx.drawImage(canvas, 0, 0)
  ctx.clearRect(0,0,ocanvas.width,canvas.height)
  canvas.width /= 2
  canvas.height /= 2
  syncBackground(canvas)
  let ch = canvas.height
  let h = 4 + Math.floor(document.getElementById("featuresize").value/2)
  let w = h
  let count = canvas.height/h * canvas.width/w
  let newline = Math.floor(canvas.width/w)
  let counter = 0
  let x = w, y = h
  let xo = 0, yo = 0, i = 0
  for (;i < count; i++) {
    ctx.save()
    ctx.beginPath()
    ctx.arc(xo+w/2,yo+h/2,w/2,0,Math.PI*2)
    ctx.closePath()
    ctx.clip()
    ctx.drawImage(ocanvas, x, y, w, h, xo, yo, w, h);
    ctx.restore()
    x += w*2
    xo += w
    counter++
    if (i > 0 && newline == counter) {
      counter = 0
      x = w
      xo = 0
      y += 2*h
      yo += h
    }
  }
  ctx.globalAlpha = a
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
}

function sample () { // rect samples
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let a = ctx.globalAlpha
  let grunge = document.getElementById("grungy").checked
  ctx.globalAlpha = 1.0
  ocanvas.height = canvas.height
  ocanvas.width = canvas.width
  octx.drawImage(canvas, 0, 0)
  ctx.clearRect(0,0,ocanvas.width,canvas.height)
  canvas.width /= 2
  canvas.height /= 2
  syncBackground(canvas)
  let ch = canvas.height
  let h = 4 + Math.floor(document.getElementById("featuresize").value/2)
  let w = h
  let count = canvas.height/h * canvas.width/w
  let newline = Math.floor(canvas.width/w)
  let counter = 0
  let x = w, y = h
  let xo = 0, yo = 0, i = 0
  for (;i < count; i++) {
    ctx.drawImage(ocanvas, x, y,  w, h, xo, yo, w, h);
    x += w*2
    xo += w
    counter++
    if (i > 0 && newline == counter) {
      counter = 0
      x = w
      xo = 0
      y += 2*h
      yo += h
    }
  }
  ctx.globalAlpha = a
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
}

function dropFrameRagged () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let mode = document.getElementById("mode").value//ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "source-over"
  document.getElementById("mode").value = "source-over"
  let alpha = ctx.globalAlpha
  ctx.globalAlpha = 1.0
  let W = canvas.width, H = canvas.height
  let padx = (W - 0.95 * W)/2
  let pady = (H - 0.95 * H)/2
  let points = [], x = padx, y = pady
  let endX = W - padx, endY =y
  
  clearOff()
  zoomImage(true, true)
  copyToOff()
  ctx.save()
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor//"#ffffff"
  ctx.shadowColor = "#606060"
  ctx.shadowBlur = 29 + Math.random() * 5
  ctx.shadowOffsetY = 19+ Math.random() * 3
  ctx.shadowOffsetX = 19 + Math.random() * 2
  ctx.beginPath()
  ctx.moveTo(x,y)
  ragged (ctx, endX, endY, x, y) // top right
  x = endX, y = endY
  endY = H -pady
  endX+=12
  ragged (ctx, endX, endY, x, y) //bottom right
  x = endX, y = endY
  endX = padx
  ragged (ctx, endX, endY, x, y) //bottom left
  x = endX, y = endY
  endY = pady
  ragged (ctx, endX, endY, x, y) //top left
  ctx.closePath()
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.fill()
  
  pasteFromOff()
  ctx.clip()

  ctx.shadowBlur = 0
  ctx.shadowOffsetY = 0
  ctx.shadowOffsetX = 0
  
  ctx.restore()
  ctx.globalCompositeOperation = mode
  document.getElementById("mode").value = mode
  ctx.globalAlpha = alpha
}

function detail () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.lineWidth = 1 + Math.floor(document.getElementById("featuresize").value/50)
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let colors = shuffle(getCurrentPalette())
  let mode = document.getElementById("mode").value
  let alpha = document.getElementById("opacity").value
  let alt = document.getElementById("grungy").checked
  let cx = canvas.width/2, cy = canvas.height/2
  let r = canvas.width/9 * 0.8 + pet(40)
  let r2 = r * 0.5
  let x = r + Math.random() * cx/2, y = r +Math.random() *cy/2
  let x2 = cx + r ,y2 = cy + r
  //let div = 1 + Math.random() * 4
  let a = Math.random() * 2 * Math.PI
  ctx.lineJoin = "round"
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let i = 0
  for (; i < 1 ;i++) {
    a = Math.random() * 2 * Math.PI
    r = canvas.width/9 * 0.8 + pet(80)
    r2 = r * 0.1+ pet(10)

    cx =  LASTCLICK[0], cy =  LASTCLICK[1]
    if (cy < canvas.height/2)
      a = Math.random()  * Math.PI
    if (cy > canvas.height/2)
      a = Math.PI +Math.random()  * Math.PI
    x = cx, y = cy
    
    x2 = cx + r*3 * Math.cos(a)
    y2 = cy + r*3 * Math.sin(a)
    
    ctx.beginPath()
    ctx.ellipse(x, y, r2, r2, a,  0, 2 * Math.PI)
    ctx.ellipse(x2, y2, r, r, a, Math.PI, Math.PI*2)
    ctx.ellipse(x2, y2, r, r, a, 0, Math.PI)
    ctx.stroke()
    if (alt)
      chairAt(x2-r/2,y2-r/2,r,ctx.strokeStyle)
    else
      cubeAt(x2-r/2,y2-r/2,r,ctx.strokeStyle)
  }
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = alpha
}

function label () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let W = canvas.width, H = canvas.height
  let x = Math.random() * W, y = Math.random() *H
  let color = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineWidth = 1 +document.getElementById("featuresize").value/50
  ctx.strokeStyle = color
  let w = W / 40, lw = W/9
  let text = document.getElementById("points").value
  if (text.length < 1)
    text = randomWord()
  x = LASTCLICK[0], dx =(W-lw-x)*Math.random()-w*1.2
  y = LASTCLICK[1], dy = 20 + H*0.9*Math.random()
  if (document.getElementById("grungy").checked) {
    let face = "AmericanTypewriter"
    ctx.font = "100 "+(lw/6)+"pt " + face
    ctx.fillStyle = color
    ctx.fillText(text, x+pet(7), y-lw/9)
  }
  
  let yend = y
  ctx.beginPath()
  ctx.moveTo(x+pet(7),y+pet(7))
  ctx.lineTo(x+lw, y)
  ctx.lineTo(x+lw+dx, yend = Math.random()*H*0.9)
  ctx.stroke()
  ctx.strokeRect(x+lw+dx,yend,w+pet(3),w+pet(3))
  LASTCLICK[1] += lw*0.6
}

function dropFrame () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "source-over"
  document.getElementById("mode").value = "source-over"
  let r = 7
  let alpha = document.getElementById("opacity").value/100
  ctx.globalAlpha = 1.0
  clearOff()
  zoomImage(true)
  copyToOff()
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.fillStyle = "#ffffff"
  ctx.shadowColor = "#202020"
  ctx.shadowBlur = 15 + Math.random() * 5
  ctx.shadowOffsetY = 13 + Math.random() * 2
  ctx.shadowOffsetX = 4 + Math.random() * 2
  let padx = (canvas.width - 0.9 * canvas.width)/2
  let pady = (canvas.height - 0.9 * canvas.height)/2
  roundedRect(padx, pady, canvas.width-2*padx, canvas.height-2*pady, r, ctx)
  
  ctx.fillStyle = "#ffffff"
  ctx.shadowColor = "#707070"
  ctx.shadowBlur = 6 + Math.random() * 5
  ctx.shadowOffsetY = 3 + Math.random() * 2
  ctx.shadowOffsetX =- 4 + Math.random() * 2
  roundedRect(padx, pady, canvas.width-2*padx, canvas.height-2*pady, r, ctx)
  
  ctx.shadowBlur = 0
  ctx.shadowOffsetY = 0
  ctx.shadowOffsetX = 0
  
  ctx.save()
  let x = padx, y = pady, w = canvas.width-2*padx, h = canvas.height-2*pady
  ctx.beginPath()
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y,   x+w, y+h, r); // across to right
  ctx.arcTo(x+w, y+h, x,   y+h, r);
  ctx.arcTo(x,   y+h, x,   y,   r);
  ctx.arcTo(x,   y,   x+w, y,   r);
  ctx.closePath();
  ctx.clip()
  
  pasteFromOff()
  ctx.restore()
  ctx.globalCompositeOperation = mode
  document.getElementById("mode").value = mode
  ctx.globalAlpha = alpha
  ctx.shadowBlur = 0
  ctx.shadowOffsetY = 0
  ctx.shadowOffsetX = 0
}

function compress () { // vertical
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "source-over"
  let a = ctx.globalAlpha
  ctx.globalAlpha = 1.0
  ocanvas.height = canvas.height
  ocanvas.width = canvas.width
  octx.drawImage(canvas, 0, 0)
  ctx.clearRect(0,0,canvas.width, canvas.height)
  syncBackground(canvas)
  ctx.drawImage(ocanvas,0,canvas.height*0.05,canvas.width,canvas.height-(canvas.height*0.1))
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  //document.getElementById("canvaswidth").value = canvas.width
  //document.getElementById("canvasheight").value = canvas.height
  ctx.globalCompositeOperation = mode
  ctx.globalAlpha = a
  syncMarker()
}

function stretch () { // vertical
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "source-over"
  let a = ctx.globalAlpha
  ctx.globalAlpha = 1.0
  ocanvas.height = canvas.height
  ocanvas.width = canvas.width
  octx.drawImage(canvas, 0, 0)
  ctx.clearRect(0,0,canvas.width, canvas.height)
  canvas.height *= 1.1
  syncBackground(canvas)
  ctx.drawImage(ocanvas,0,0,canvas.width,canvas.height)
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  document.getElementById("canvaswidth").value = canvas.width
  document.getElementById("canvasheight").value = canvas.height
  ctx.globalCompositeOperation = mode
  ctx.globalAlpha = a
  syncMarker()
}

function zoomOutImage () {
  zoomImage(true)
}

function zoomImage (out, d) {
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas")
  let alpha = document.getElementById("opacity").value

  let ctx = canvas.getContext("2d")
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "source-over"
  let a = ctx.globalAlpha
  ctx.globalAlpha = 1.0
  let W = canvas.width, H = canvas.height
  ocanvas.height = canvas.height
  ocanvas.width = canvas.width
  octx.imageSmoothingEnabled = true
  octx.imageSmoothingQuality = 'high'
  ctx.imageSmoothingEnabled = true
  ctx.imageSmoothingQuality = 'high'
  octx.drawImage(canvas, 0, 0)
  
  let dx = (out)? canvas.width * 0.9: canvas.width * 1.1
  let dy = (out)? canvas.height * 0.9: canvas.height * 1.1
  if (d) {
    dx = (out)? canvas.width * 1/d: canvas.width * d
    dy = (out)? canvas.height * 1/d: canvas.height * d

  }
  let diffx = dx - W
  let diffy = dy - H
  let ox = (W/2/W * diffx)
  let oy = (H/2/H * diffy)
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.drawImage(ocanvas, -ox, -oy, dx, dy)
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  ctx.globalCompositeOperation = mode
  ctx.globalAlpha = alpha/100
}

function zoom () {
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "source-over"
  let a = ctx.globalAlpha
  ctx.globalAlpha = 1.0
  ocanvas.height = canvas.height
  ocanvas.width = canvas.width
  octx.drawImage(canvas, 0, 0)
  canvas.width = Math.round(canvas.width * 1.2)
  canvas.height = Math.round(canvas.height * 1.2)
  syncBackground(canvas)
  ctx.drawImage(ocanvas,0,0,canvas.width,canvas.height)
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  //document.getElementById("canvaswidth").value = canvas.width
 // document.getElementById("canvasheight").value = canvas.height
  ctx.globalCompositeOperation = mode
  ctx.globalAlpha = a
  syncMarker()
}

function zoom_neg () {
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let mode = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = "source-over"
  let a = ctx.globalAlpha
  ctx.globalAlpha = 1.0
  ocanvas.height = canvas.height
  ocanvas.width = canvas.width
  octx.drawImage(canvas, 0, 0)
  canvas.width = Math.round(canvas.width / 1.2)
  canvas.height = Math.round(canvas.height / 1.2)
  syncBackground(canvas)
  ctx.drawImage(ocanvas,0,0,canvas.width,canvas.height)
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
 // document.getElementById("canvaswidth").value = canvas.width
 // document.getElementById("canvasheight").value = canvas.height
  ctx.globalCompositeOperation = mode
  ctx.globalAlpha = a
  syncMarker()
}

function blasco () {
  let h = 4 + Math.floor(document.getElementById("featuresize").value/2)
  document.getElementById("rednumber").value = h
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let temp = document.createElement("CANVAS")
  let tempctx = temp.getContext("2d")
  let a = ctx.globalAlpha
  let grunge = document.getElementById("grungy").checked
  ctx.globalAlpha = 1.0
  ocanvas.height = canvas.height
  ocanvas.width = canvas.width
  temp.height = canvas.height * 2 + h*2
  temp.width = canvas.width
  let ch = canvas.height
  let count = ch/h - 1
  let y = 0, i = 0
  for (;i < count; i++) {
    if (grunge) {
      if (i % 2 == 0) {
        sliceHC(y, h, ctx, octx, canvas, ocanvas, temp, tempctx, grunge)
        y += h
      } else
        y += h
    } else {
      sliceHC(y, h, ctx, octx, canvas, ocanvas, temp, tempctx, grunge)
        y += h
    }
  }
  
  if (grunge) {
    canvas.height *= 1
    canvas.height += 2*h
  } else {
    canvas.height *= 2
    canvas.height += 2*h
  }
  syncBackground(canvas)
  ctx.drawImage(temp, 0, 0)
  ctx.globalAlpha = a
  ctx.setTransform(1,0,0,1,0,0)
  //syncMarker()
}

function sliceHC (y, h, ctx, octx, canvas, ocanvas, t, tctx, g) {
  octx.clearRect(0,0,canvas.width,ocanvas.height)
  octx.drawImage(canvas, 0, 0)
  octx.clearRect(0,0,canvas.width,y)
  octx.clearRect(0,y+h,ocanvas.width,ocanvas.height)
  if (g)
    tctx.translate(0,h)
  else
    tctx.translate(0,y+h)
  tctx.clearRect(0,y,canvas.width, h)
  tctx.drawImage(ocanvas, 0, 0)
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  tctx.setTransform(1,0,0,1,0,0)
}

function randomGradientRect (canvas, col1, x1, y1, x2, y2, R) {
  let centx = Math.random() * canvas.width;
  let centy = Math.random() * canvas.height;
  let radius = canvas.width/2;
  let angle = Math.random()*6.27;
  let p = 0//(x1-x2)
  if (R)
    ;//p = (x1-x2)
  let my_gradient = canvas.getContext('2d').createLinearGradient(x1-pet(p), y1-pet(p), x2+pet(p), y2+pet(p));
  let col2 = "rgba("+hexToR(col1)+", "+hexToG(col1)+", "+hexToB(col1)+", 0.0)";// transparent
  my_gradient.addColorStop(0,col1);
  my_gradient.addColorStop(1,col2);
  return my_gradient;
}

function randomGradientRect2(canvas, col1, col2, x1, y1, x2, y2, R) {
  let centx = Math.random() * canvas.width;
  let centy = Math.random() * canvas.height;
  let radius = canvas.width/2;
  let angle = Math.random()*6.27;
  let p = 2
  let my_gradient = canvas.getContext('2d').createLinearGradient(x1-pet(p), y1-pet(p), x2+pet(p), y2+pet(p));
  col2 = "rgba("+hexToR(col2)+", "+hexToG(col2)+", "+hexToB(col2)+", 0.2)";// transparent
  my_gradient.addColorStop(0,col2);
  my_gradient.addColorStop(1,col1);
  return my_gradient;
}

function petColor (c, p) {
  let r = hexToR(c) + Math.floor(pet(p))
  let g = hexToG(c) + Math.floor(pet(p))
  let b = hexToB(c) + Math.floor(pet(p))
  if (r > 255 || r < 0)
    r =  hexToR(c)
  if (g > 255 || g < 0)
    g =  hexToG(c)
  if (b > 255 || b < 0)
    b =  hexToB(c)
  let R = ('0'+(Math.round(r)).toString(16)).slice(-2),
      G = ('0'+(Math.round(g)).toString(16)).slice(-2),
      B = ('0'+(Math.round(b)).toString(16)).slice(-2);
  return "#"+R+G+B
}

function randomGradient(canvas, col1) {
  let x1 = 0, y1 = 0, x2 = 0, y2 = 0;
  let centx = Math.random() * canvas.width;
  let centy = Math.random() * canvas.height;
  let radius = canvas.width/2;
  let angle = Math.random()*6.27;
  x1 = radius * Math.cos(angle)+centx;
  y1 = radius * Math.sin(angle)+centy;
  x2 = radius * Math.cos(angle+3.14)+centx;
  y2 = radius * Math.sin(angle+3.14)+centy;
  let my_gradient = canvas.getContext('2d').createLinearGradient(x1, y1, x2, y2);
  if (col1 === undefined)
    col1 = randomColor();

  let col2 = "rgba("+hexToR(col1)+", "+hexToG(col1)+", "+hexToB(col1)+", 0.0)";// transparent
  my_gradient.addColorStop(0,col1);
  my_gradient.addColorStop(1,col2);
  return my_gradient;
}

function randomGradientLeft(canvas, col1) {
  let x1 = 0, y1 = 0, x2 = 0, y2 = 0;
  let centx = -1//Math.random() * canvas.width;
  let centy = Math.random() * canvas.height;
  let radius = canvas.width/2;
  let angle = Math.random()*6.27;
  x1 = radius * Math.cos(angle)+centx;
  y1 = 0//radius * Math.sin(angle)+centy;
  x2 = radius * Math.cos(angle+3.14)+centx;
  y2 = 0//radius * Math.sin(angle+3.14)+centy;
  let my_gradient = canvas.getContext('2d').createLinearGradient(x1, y1, x2, y2);
  if (col1 === undefined)
    col1 = randomColor();
  let col2 = "rgba("+hexToR(col1)+", "+hexToG(col1)+", "+hexToB(col1)+", 0.0)";// transparent
  my_gradient.addColorStop(0,col1);
  my_gradient.addColorStop(1,col2);
  return my_gradient;
}

function randomGradientPal (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  let x1 = 0, y1 = 0, x2 = 0, y2 = 0;
  let centx = Math.random() * canvas.width;
  let centy = Math.random() * canvas.height;
  let radius = canvas.width/2;
  let angle = Math.random()*6.27;
  x1 = radius * Math.cos(angle)+centx;
  y1 = radius * Math.sin(angle)+centy;
  x2 = radius * Math.cos(angle+3.14)+centx;
  y2 = radius * Math.sin(angle+3.14)+centy;
  let my_gradient = canvas.getContext('2d').createLinearGradient(x1, y1, x2, y2);
  let col1 = randomPick(getCurrentPalette());
  let col2 = randomPick(getCurrentPalette());
  my_gradient.addColorStop(0,col1);
  my_gradient.addColorStop(1,col2);
  return my_gradient;
}

function shadeColor (color, percent) { // hex color, percet -100 to 100
  var R = parseInt(color.substring(1,3),16);
  var G = parseInt(color.substring(3,5),16);
  var B = parseInt(color.substring(5,7),16);

  R = parseInt(R * (100 + percent) / 100);
  G = parseInt(G * (100 + percent) / 100);
  B = parseInt(B * (100 + percent) / 100);

  R = (R<255)?R:255;
  G = (G<255)?G:255;
  B = (B<255)?B:255;

  R = Math.round(R)
  G = Math.round(G)
  B = Math.round(B)

  var RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
  var GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
  var BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));

  return "#"+RR+GG+BB;
}


function rgbtohex (r, g, b) {
  function c(v) {
    let hex = v.toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  }
  return "#" + c(r) + c(g) + c(b);
}

// input: r,g,b in [0,1], out: h in [0,360) and s,v in [0,1]
function rgbtohsv (r,g,b) {
  let v=Math.max(r,g,b), c=v-Math.min(r,g,b);
  let h= c && ((v==r) ? (g-b)/c : ((v==g) ? 2+(b-r)/c : 4+(r-g)/c));
  return [60*(h<0?h+6:h), v&&c/v, v];
}


/**
 * Converts an HSV color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes h, s, and v are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @param   Number  h       The hue
 * @param   Number  s       The saturation
 * @param   Number  v       The value
 * @return  Array           The RGB representation
 */
function hsvtorgb(h, s, v) {
  var r, g, b;
  h /= 360
  v /= 255
  var i = Math.floor(h * 6);
  var f = h * 6 - i;
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);

  switch (i % 6) {
    case 0: r = v, g = t, b = p; break;
    case 1: r = q, g = v, b = p; break;
    case 2: r = p, g = v, b = t; break;
    case 3: r = p, g = q, b = v; break;
    case 4: r = t, g = p, b = v; break;
    case 5: r = v, g = p, b = q; break;
  }
  return [ Math.round(r * 255), Math.round(g * 255), Math.round(b * 255) ];
}

function colorAngle (c, angle) {
  let rgb = hextorgb(c)
  let hsv = rgbtohsv(rgb[0], rgb[1], rgb[2])
  hsv[0] = (hsv[0]+angle) % 360
  rgb = hsvtorgb(hsv[0], hsv[1], hsv[2])
  return rgbtohex(rgb[0], rgb[1], rgb[2])
  
}

function hextorgb (c)  {
  return ([hexToR(c), hexToG(c), hexToB(c)])
}

function quadcolors (r,g,b) {
  console.log(rgbtohex(r,g,b))
  let hsv = rgbtohsv(r,g,b)
  hsv[0] = (hsv[0]+90) % 360
  let rgb = hsvtorgb(hsv[0],hsv[1],hsv[2])
  console.log(rgb)
  console.log(rgbtohex(rgb[0],rgb[1],rgb[2]))
}

function analogousColors (r,g,b) {
  console.log(r,g,b)
  let hsv = rgbtohsv(r,g,b)
  console.log(hsv)
  console.log(HSVtoRGB(hsv[0], hsv[1], hsv[2]))
  return
  hsv[0] = (hsv[0]+30) % 360
  console.log(hsv)
  hsv[0] = (hsv[0]+30) % 360
  console.log(hsv)
}

function plus60 (r,g,b) {
  console.log(r,g,b)
  let hsv = rgbtohsv(r,g,b)
  hsv[0] = (hsv[0]+60) % (2*255)
  console.log(hsv)
}

// (R, G, B) = (256*cos(x), 256*cos(x + 120), 256*cos(x - 120))
function colorAngleX (angle) {
  let r = 256 * Math.cos(angle)
  let g = 256 * Math.cos(angle+120*Math.PI/180)
  let b = 256 * Math.cos(angle-120*Math.PI/180)
  console.log(Math.floor(r),Math.floor(g),Math.floor(b))
}

function hextorgb (h) {
  return [hexToR(h),hexToG(h),hexToB(h)]
}

function hexToR(h) { return parseInt((cutHex(h)).substring(0,2),16) }
function hexToG(h) { return parseInt((cutHex(h)).substring(2,4),16) }
function hexToB(h) { return parseInt((cutHex(h)).substring(4,6),16) }
function cutHex(h) { return (h.charAt(0)=="#") ? h.substring(1,7) : h}

function hrips () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let centerx = canvas.width / 2;
  let centery = canvas.height / 2;
  let thickness = document.getElementById("featuresize").value
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let yincrement = 4;
  let numshapes = 1
  for (let t = 0; t < numshapes; t++) {
    let points = [];
    let width = 1 + Math.random()*3;
    ctx.lineWidth = 3+Math.random()*11;
    let x = -20;
    let y = Math.random() * canvas.height * 1.5
    y //+= thickness
    let x0 = x;
    let y0 = y;
    ctx.beginPath();
    ctx.moveTo(x, y);
    points.push([x,y]);
    let direction = 0.8;
    if (y < centery)
      direction = -0.8;
    let yincrement = 1 + Math.random() * 3;
    let jump = 3 + Math.random() * 4;
    while (x < canvas.width+20) {
      y += (Math.random()-0.5) * yincrement;
      x += 1 + 3 * Math.random();
      if (Math.random() < 0.1)
        x += 3 + Math.random() * 7;
      if (Math.random() < 0.5)
        y -= jump * (Math.random()*direction);
      ctx.lineTo(x+Math.random()*4,y+(1+width + Math.random() * 5));
      points.push([x,y]);
      if (Math.random() < 0.05) {
        direction *= -1;
      }
    }
    y -= thickness
    while (x > -20) {
      y -= (Math.random()-0.5) * yincrement;
      x -= 1 + 3 * Math.random();
      if (Math.random() < 0.040)
        x -= 7 + Math.random() * 7;
      if (Math.random() < 0.5)
        y += jump * (Math.random()*direction);
      ctx.lineTo(x+Math.random()*4,y+(1+width + Math.random() * 5));
      points.push([x,y]);
      if (Math.random() < 0.1) {
        direction *= -1;
      }
    }
    ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
    if (document.getElementById("grungy").checked)
      ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
    ctx.closePath();
    ctx.fill();
  }
}

function smudgearcs2 (canvas, color) {
  smudge ('arcs2', canvas, color)
}

function smudgearcs (canvas, color) {
  smudge ('arcs', canvas, color)
}

function smudgestars (canvas, color) {
  smudge ('stars', canvas, color)
}

function smudgestreaks (canvas, color) {
  smudge ('streaks', canvas, color)
}
function smudgestreaks2 (canvas, color) {
  smudge ('streaks2', canvas, color)
}

function smudgewatercolor (canvas, color) {
  smudge ('watercolor', canvas, color)
}

function smudgehorizontal (canvas, color) {
  smudge ('horizontal', canvas, color)
}

function smudgehorizontal2 (canvas, color) {
  smudge ('horizontal2', canvas, color)
}

function smudge (type, canvas, color) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width
  let H = canvas.height
  let xoff = -W, yoff = -W
  let len = W/2, maxy = W/2
  let off = document.getElementById("offscreen");
  let ctoff = off.getContext("2d");
  let canvasoff = document.getElementById("offscreen");
  let ctxoff = canvasoff.getContext("2d");
  let n = 0, x = 0, y = 0
  ctx.globalAlpha = document.getElementById("opacity").value/100 //* 0.75
  let smudge_size = 2 + Math.random()*13
  let dx = pet(smudge_size*3), dy = pet(smudge_size*3)
  let smudge_ct = 1 + document.getElementById("number").value/150
  let area = canvas.width * canvas.height
  let shapemultiplier = area/(1024*1024)
  smudge_ct *= shapemultiplier
  if (type == "watercolor")
    smudge_ct /= 2
  for (; n < smudge_ct; n++) {
    if (type === "streaks")
      offstreaks(color)
    else
    if (type === "streaks2")
      offmix(color)
    else
    if (type === "horizontal")
      offhorizontal(color)
    else
    if (type === "horizontal2")
      offhorizontal2(color)
    else
    if (type === "arcs")
      offarcs(color)
    else
    if (type === "arcs2")
      offarcs2(color)
    else
    if (type === "stars")
      offstars(color)
    else
    if (type === "watercolor")
      offwatercolor(color)
    else
      offspecks(color)
    x = Math.random()*canvas.width - 256 // 256 == half the width of the offseceen canvas
    y = Math.random()*canvas.height - 256
    dx = pet(13), dy = pet(13)
    let i = 0
    let moves = smudge_size
    if (type == "arcs2")
      moves = 1
    for (; i < moves; i++) {
      ctx.drawImage(canvasoff, x,   y)
      /*
      ctx.drawImage(canvasoff, x-W, y-H)
      ctx.drawImage(canvasoff, x,   y-H)
      ctx.drawImage(canvasoff, x+W, y-H)
      ctx.drawImage(canvasoff, x-W, y+H)
      ctx.drawImage(canvasoff, x,   y+H)
      ctx.drawImage(canvasoff, x+W, y+H)
      ctx.drawImage(canvasoff, x-W, y)
      ctx.drawImage(canvasoff, x+W, y)*/
      x += dx + pet(23)
      y += dy + pet(23)
    }
  }
  ctxoff.clearRect(0,0,canvasoff.width, canvasoff.height)
}

function offcray (color, fs) {
  let canvas = document.getElementById("offscreen");
  let ctx = canvas.getContext("2d");
  let cx = ctx.canvas.width/2;
  let cy = ctx.canvas.height/2;
  let x = 0, y = 0
  ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height)
  ctx.globalAlpha = 0.5
  let maxradius = 4 + document.getElementById("featuresize").value/10
  if (fs)
    maxradius = fs
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  if (color)
    ctx.fillStyle = color
  let d =  maxradius/5//14 + Math.random() * 1
  let count = maxradius/3
  for (let j = 0; j < count; j++) {
    ctx.beginPath();
    x = cx + pet(d)*Math.cos(Math.random()*6.28)
    y = cy + pet(d)*Math.sin(Math.random()*6.28)
    ctx.arc(x, y, randomPick([0.5,0.5,0.5,0.5,0.5,1,1]), 0, 2*Math.PI);
    ctx.fill();
  }
}

function paintbrushAt (x,y,ctx, fs) {
  let off = document.getElementById("offscreen")
  let ctoff = off.getContext("2d")
  let canvasoff = document.getElementById("offscreen")
  let ctxoff = canvasoff.getContext("2d")
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let color = null
  if (!x)
    x = LASTCLICK[0]
  if (!y)
    y = LASTCLICK[1]
  x -= 256, y -= 256
  if (Math.random() > 0.1)
    //offpaintbrush(color, fs)
  ctx.drawImage(canvasoff, x, y)
}

function offpaintbrush (color, fs) {
  let canvas = document.getElementById("offscreen");
  let ctx = canvas.getContext("2d");
  let cx = ctx.canvas.width/2;
  let cy = ctx.canvas.height/2;
  let x = 0, y = 0
  ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height)
  ctx.globalAlpha = 0.1
  let maxradius = 4 + document.getElementById("featuresize").value/10
  if (fs)
    maxradius = fs
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  if (color)
    ctx.fillStyle = color
  let d =  maxradius*1
  let count = maxradius*4
  for (let j = 0; j < count; j++) {
    ctx.fillStyle = shadeColor(ctx.fillStyle, pet(1))
    ctx.beginPath();
    x = cx + pet(d)*Math.cos(Math.random()*6.28)
    y = cy + pet(d)*Math.sin(Math.random()*6.28)
    ctx.arc(x, y, randomPick([2,3,4,2,6,6,6,6]), 0, 2*Math.PI);
    ctx.fill();
  }
}
function crayAt (x,y,ctx, fs) {
  let off = document.getElementById("offscreen")
  let ctoff = off.getContext("2d")
  let canvasoff = document.getElementById("offscreen")
  let ctxoff = canvasoff.getContext("2d")
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let color = null
  if (!x)
    x = LASTCLICK[0]
  if (!y)
    y = LASTCLICK[1]
  x -= 256, y -= 256
  //if (Math.random() > 0.33)
    offcray(color, fs)
  ctx.drawImage(canvasoff, x, y)
}

function bez_pts_cray (ax,ay, bx,by, cx,cy, dx, dy, ctx, fs) {
  // b and c are control points, a = start, d = end
  let t = 0, a = 1.3*Math.PI
  for (; t < 1; t += 0.005) {
    let B0_t = (1-t) * (1-t) * (1-t)
    let B1_t = 3 * t * (1-t) * (1-t)
    let B2_t = 3 * t*t * (1-t)
    let B3_t = t*t*t
    let px_t = (B0_t * ax) + (B1_t * bx) + (B2_t * cx) + (B3_t * dx)
    let py_t = (B0_t * ay) + (B1_t * by) + (B2_t * cy) + (B3_t * dy)
    // draw at x,y here or
    crayAt(px_t, py_t, ctx, fs)
  }
}

function crayonScript () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let fs = 7 + document.getElementById("featuresize").value/5
  let D = 1 + document.getElementById("number").value/4000
  D/= 2
  let bump = fs/2.4
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alt = document.getElementById("grungy").checked
  let W = canvas.width, H = canvas.height
  let pad = 4 + Math.floor(Math.random() * 2)
  let linespace = 18 + Math.floor(pet(8))
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineJoin = "round"
  ctx.lineWidth = Math.floor(1 + fs/12)
  ctx.imageSmoothingQuality = "high"
  let i = 0, x = LASTCLICK[0], y = LASTCLICK[1]
  let cx1, cy1, cx2, cy2
  let maxX = x+1*fs + Math.random() * 8 * fs
  let x2 = 0,y2 = 0, CT = 0

  fs *= 1
  ctx.beginPath()
  while (x < maxX) {
    CT++
    cx1 = x+fs*1, cy1 = y -3*fs
    cx2 = x-fs*4, cy2 = y +3*fs
    bump = 0.8*fs + pet(fs*D/4)
    /*
    if (Math.random() < 0.07) {
      cy2 += 2*fs
    } else
    if (Math.random() < 0.23) {
      cy1 -= 2*fs
    }*/
    bez_pts_cray (x,y,cx1+pet(D*fs),cy1+pet(D*fs),cx2+pet(D*fs),cy2+pet(D*fs), x+bump, y, ctx)
    /*
    // occasional dot or cross
    if (Math.random() < 0.0) {
      x2 = x + pet(fs/3)
      y2 = y - fs*1.3+pet(fs)
      cx1 = x2 + fs/4
      cy1 = y2 - fs/5 +pet(fs/4)
      cx2 = x2 + fs/4 + pet(fs)
      cy2 = y2 - fs/5 + pet(fs/4)
      bez_pts_cray (x2,y2,cx1,cy1,cx2,cy2, x2+pet(fs/2), y2 += pet(fs/2), ctx)
    }*/
    if (alt)
      ctx.lineWidth = Math.floor(1 + fs/20) + pet(1)
    x += bump
    if (x > W) {
      LASTCLICK[1] += fs*4
      LASTCLICK[0] = 0
      return
    }
  }
  LASTCLICK[0] = x + bump
}

function paintDrips () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d");
  let W = canvas.width
  let H = canvas.height
  let i = 0, n = 5 + Math.random() * 5
  for (; i < n; i++)
    paintDrip(W*Math.random(), H*Math.random())
}

function paintDrip (x,y) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d");
  let W = canvas.width
  let H = canvas.height
  let alt = document.getElementById("grungy").checked
  let off = document.getElementById("offscreen")
  let ctoff = off.getContext("2d")
  let canvasoff = document.getElementById("offscreen")
  let ctxoff = canvasoff.getContext("2d")
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let smudge_size = 2 + Math.random()*13
  let dx = pet(smudge_size*3), dy = pet(smudge_size*3)
  let smudge_ct = 1 + document.getElementById("number").value/150
  let maxradius = 4 + document.getElementById("featuresize").value/10
  let color = null
  if (!x)
    x = LASTCLICK[0]
  if (!y)
    y = LASTCLICK[1]
  if (!alt)
    color = colorOf (ctx,x,y,4)
  x -= 256, y -= 256
  offdrops(color)
  dx = pet(1), dy = 3+pet(2)
  let maxy = y + (H - y) * Math.random() + 51
  while (y < maxy) {
    ctx.drawImage(canvasoff, x, y)
    if (Math.random() > 0.90)
      x += dx + pet(maxradius)
    y += dy + pet(maxradius/2)
    if (Math.random() > 0.9)
      offdrops(color)
  }
  // change at end: looks more natural?
  while (y < maxy+31) {
    offdrops(color)
    ctx.drawImage(canvasoff, x, y)
    if (Math.random() > 0.90)
      x += dx + pet(maxradius)
    y += dy + pet(maxradius/2)
  }
  ctxoff.clearRect(0,0,canvasoff.width, canvasoff.height)
}

function offdrops (color) {
  let canvas = document.getElementById("offscreen");
  let ctx = canvas.getContext("2d");
  let cx = ctx.canvas.width/2;
  let cy = ctx.canvas.height/2;
  let x = 0, y = 0
  ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height)
  ctx.globalAlpha = 0.9
  let maxradius = 4 + document.getElementById("featuresize").value/10
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  if (color)
    ctx.fillStyle = color
  let d =  1 + Math.random() * 1
  let count = 5
  for (let j = 0; j < count; j++) {
    ctx.beginPath();
    x = cx + pet(d)*Math.cos(Math.random()*6.28)
    y = cy + pet(d)*Math.sin(Math.random()*6.28)
    ctx.arc(x, y, Math.random()*maxradius, 0, 2*Math.PI);
    ctx.fill();
  }
}

function fog (canvas, color) {
  
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width
  let H = canvas.height
  let xoff = -W, yoff = -H
  let len = W/2, maxy = W/2
  let canvasoff = document.getElementById("offscreen");
  let ctxoff = canvasoff.getContext("2d");
  let n = 0, x = 0, y = 0
  ctx.globalAlpha = document.getElementById("opacity").value/100 //* 0.75
  let smudge_size = 51 + Math.random()* 100
  let colors = []

 if (color)
    colors.push(color)
  else
    colors.push(randomPick(getCurrentPalette())) // was paintcolor)
  let smudge_ct = 1 + document.getElementById("number").value/100
  let area = canvas.width * canvas.height
  let shapemultiplier = area/(1024*1024)
  smudge_ct *= shapemultiplier
  ctxoff.save()
  for (; n < smudge_ct; n++) {
    x = Math.random() * (W + 40) - 256
    y = Math.random() * (H + 40) - 256
    offbrush(colors)
    let i = 0
    let moves = 15//smudge_size * 8
    for (; i < moves; i++) {
      ctx.drawImage(canvasoff, x += pet(41), y += pet(41))
    }
  }
  ctxoff.restore()
  ctxoff.clearRect(0,0,canvasoff.width, canvasoff.height)
  ctx.restore()
}

function offwatercolor (color) {
  let canvas = document.getElementById("offscreen");
  let ctx = canvas.getContext("2d");
  let cx = ctx.canvas.width/2;
  let cy = ctx.canvas.height/2;
  let x = 0, y = 0
  ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height)
  ctx.globalAlpha = 0.05
  let maxradius = 20 + document.getElementById("featuresize").value/5
  let d = 14 + Math.random() * maxradius
  d *= 5
  let count = 10
  if (color)
    ctx.fillStyle = color
  else
    ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  for (let j = 0; j < count; j++) {
    ctx.beginPath();
    x = cx + pet(d)
    y = cy + pet(d)
    ctx.arc(x, y, 5+Math.random()*maxradius, 0, 2*Math.PI);
    ctx.fill();
  }
  let size = document.getElementById("featuresize").value
  document.getElementById("featuresize").value = 30
  //dirblur(canvas)
  document.getElementById("featuresize").value = size
  smearrandom(canvas)
}

function offbrush (colors) {
  let canvas = document.getElementById("offscreen");
  let ctx = canvas.getContext("2d");
  let cx = ctx.canvas.width/2;
  let cy = ctx.canvas.height/2;
  let x = 0, y = 0
  ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height)
  ctx.globalAlpha = 0.01
  let maxradius = 1 + document.getElementById("featuresize").value/3
  let d = 41 + Math.random() * maxradius
  d *= 5
  let count = 9
  ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)]
  for (let j = 0; j < count; j++) {
    ctx.beginPath();
    x = cx + pet(d)*Math.cos(Math.random()*6.28)
    y = cy + pet(d)*Math.sin(Math.random()*6.28)
    ctx.arc(x, y, Math.random()*maxradius, 0, 2*Math.PI);
    ctx.fill();
  }
}

function offstars (color) {
  let canvas = document.getElementById("offscreen");
  let ctx = canvas.getContext("2d");
  let cx = ctx.canvas.width/2;
  let cy = ctx.canvas.height/2;
  let csize = ctx.canvas.height
  let x = 0, y = 0
  ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height)
  ctx.globalAlpha = 0.1
  let maxWidth = 0.15 + document.getElementById("featuresize").value/500
  if (color)
  ctx.strokeStyle = color
  else
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  if (document.getElementById("grungy").checked)
    maxWidth *= 2
  ctx.globalAlpha = 0.1
  let s = 0
  let count = 7
  for (; s < count; s++) {
    x = Math.random() * canvas.width;
    y = Math.random() * canvas.height;
    let spokes = 7 + Math.random() * 9
    let spokelength = 20 + 51 * Math.random()
    for (let i = 0; i < spokes; i++) {
      ctx.lineWidth = maxWidth * Math.random()
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x+Math.cos(Math.random()*6.28)*pet(spokelength), y+Math.sin(Math.random()*6.28)*pet(spokelength));
      ctx.stroke()
    }
  }
}

function offmix (color) {
  let canvas = document.getElementById("offscreen");
  let ctx = canvas.getContext("2d");
  let cx = ctx.canvas.width/2;
  let cy = ctx.canvas.height/2;
  let csize = ctx.canvas.height
  let x = 0, y = 0
  ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height)
  ctx.globalAlpha = 0.1
  let maxWidth = 0.15 + document.getElementById("featuresize").value/300
  if (color)
  ctx.strokeStyle = color
  else
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  if (document.getElementById("grungy").checked)
    maxWidth *= 2
  ctx.globalAlpha = 0.1
  let s = 0
  let count = 7
  let maxradius = 1 + document.getElementById("featuresize").value/150
  for (; s < count; s++) {
    let spokes = 27 + Math.random() * 9
    let spokelength = 20 + 51 * Math.random()
    for (let i = 0; i < spokes; i++) {
      x = Math.random() * canvas.width;
      y = Math.random() * canvas.height;
      ctx.lineWidth = maxWidth * Math.random()
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x+Math.cos(Math.random()*6.28)*pet(spokelength), y+Math.sin(Math.random()*6.28)*pet(spokelength));
      ctx.stroke()
    }
  }
}

function offhorizontal (color) {
  let  canvas = document.getElementById("offscreen");
  let ctx = canvas.getContext("2d");
  let cx = ctx.canvas.width/2;
  let cy = ctx.canvas.height/2;
  let csize = ctx.canvas.height
  let x = 0, y = 0
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.globalAlpha = 0.1
  let maxWidth = 0.15 + document.getElementById("featuresize").value/500
  if (color)
  ctx.strokeStyle = color
  else
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  let grunge = document.getElementById("grungy").checked
  if (grunge)
    maxWidth *= 2
  ctx.lineWidth = 0.1
  let count = 21
  let ybump = 0
  for (let j = 0; j < count; j++) {
    ctx.lineWidth = maxWidth * Math.random()
    ctx.beginPath()
    y = Math.random() * csize
    ctx.moveTo(Math.random() * cx, y)
    ybump = pet(43)
    ctx.lineTo(cx + Math.random() * cx/3, y + ybump)
    ctx.stroke()
  }
}

function offhorizontal2 (color) {
  let  canvas = document.getElementById("offscreen");
  let ctx = canvas.getContext("2d");
  let cx = ctx.canvas.width/2;
  let cy = ctx.canvas.height/2;
  let csize = ctx.canvas.height
  let x = 0, y = 0
  ctx.clearRect(0,0,canvas.width,canvas.height)
  ctx.globalAlpha = 0.1
  let maxWidth = 0.35 + document.getElementById("featuresize").value/500
  if (color)
  ctx.strokeStyle = color
  else
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  let grunge = document.getElementById("grungy").checked
  if (grunge)
    maxWidth *= 2
  ctx.lineWidth = 0.1
  let count = 21
  let ybump = 0
  for (let j = 0; j < count; j++) {
    ctx.lineWidth = maxWidth * Math.random()
    ctx.beginPath()
    y = Math.random() * csize
    ctx.moveTo(Math.random() * cx, y)
    ybump = pet(13)
    ctx.lineTo(cx + Math.random() * cx/3, y + ybump)
    ctx.stroke()
  }
}

function offstreaks (color) {
  let canvas = document.getElementById("offscreen");
  let ctx = canvas.getContext("2d");
  let cx = ctx.canvas.width/2;
  let cy = ctx.canvas.height/2;
  let csize = ctx.canvas.height
  let x = 0, y = 0
  ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height)
  ctx.globalAlpha = 0.1
  let maxWidth = 0.15 + document.getElementById("featuresize").value /500
  if (document.getElementById("grungy").checked)
    maxWidth *= 2
    if (color)
  ctx.strokeStyle = color
  else
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  //ctx.lineWidth = 0.1
  let count = 7
  for (let j = 0; j < count; j++) {
    ctx.lineWidth = maxWidth * Math.random()
    ctx.beginPath()
    ctx.moveTo(Math.random() * cx, Math.random() * csize)
    ctx.lineTo(cx + Math.random() * cx, Math.random() * csize)
    ctx.stroke()
  }
}

function offarcs2 (color) {
  let  canvas = document.getElementById("offscreen");
  let ctx = canvas.getContext("2d");
  let cx = ctx.canvas.width/2;
  let cy = ctx.canvas.height/2;
  let x = 0, y = 0
  let s = 0, e = 0
  ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height)
  ctx.globalAlpha = 0.25
  let maxWidth = 3 + document.getElementById("featuresize").value/500
  if (color)
  ctx.strokeStyle = color
  else
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  let maxradius = 57 + document.getElementById("featuresize").value /2
  if (document.getElementById("grungy").checked)
    maxradius *= 2
  let d = 40 + Math.random() * 39
  let count = 13
  for (let j = 0; j < count; j++) {
    ctx.beginPath();
    ctx.lineWidth = maxWidth * Math.random()
    x = cx + pet(d)*Math.cos(Math.random()*0.5)
    y = cy + pet(d)*Math.sin(Math.random()*0.5)
    e = Math.random()*6.28
    s = e+Math.random()*1.5
    ctx.arc(x, y, Math.random()*maxradius, e, s);
    ctx.stroke();
  }
}

function offarcs (color) {
  let  canvas = document.getElementById("offscreen");
  let ctx = canvas.getContext("2d");
  let cx = ctx.canvas.width/2;
  let cy = ctx.canvas.height/2;
  let x = 0, y = 0
  let s = 0, e = 0
  ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height)
  ctx.globalAlpha = 0.15
  let maxWidth = 0.15 + document.getElementById("featuresize").value /500
  if (color)
  ctx.strokeStyle = color
  else
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineWidth = 0.1
  let maxradius = 17 + document.getElementById("featuresize").value /2
  if (document.getElementById("grungy").checked)
    maxradius *= 2
  let d = 40 + Math.random() * 39
  let count = 53
  for (let j = 0; j < count; j++) {
    ctx.beginPath();
    ctx.lineWidth = maxWidth * Math.random()
    x = cx + pet(d)*Math.cos(Math.random()*0.5)
    y = cy + pet(d)*Math.sin(Math.random()*0.5)
    e = Math.random()*6.28
    s = e+Math.random()*1.5
    ctx.arc(x, y, Math.random()*maxradius, e, s);
    ctx.stroke();
  }
}

function offspecks2 (color) {
  let canvas = document.getElementById("offscreen");
  let ctx = canvas.getContext("2d");
  let cx = ctx.canvas.width/2;
  let cy = ctx.canvas.height/2;
  let x = 0, y = 0
  ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height)
  ctx.globalAlpha = 0.075
  let maxradius = 1 + document.getElementById("featuresize").value /20
  
  let d = 1 + Math.random() * 41
  let count = 7
  for (let j = 0; j < 7; j++) {
    ctx.beginPath();
    x = cx + pet(d)*Math.cos(Math.random()*6.28)
    y = cy +pet(d)*Math.sin(Math.random()*6.28)
    ctx.arc(x, y, Math.random()*maxradius, 0, 2*Math.PI);
    
    if (color)
    ctx.fillStyle = color
    else
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
    ctx.fill();
  }
}

function offspecks (color) {
 // console.log("offspecks", color )
  let canvas = document.getElementById("offscreen");
  let ctx = canvas.getContext("2d");
  let cx = ctx.canvas.width/2;
  let cy = ctx.canvas.height/2;
  let x = 0, y = 0
  ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height)
  ctx.globalAlpha = 0.0025
  let maxradius = 2 + document.getElementById("featuresize").value /10
  if (color)
    ctx.fillStyle = color
  else
    ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let d = 51 + Math.random() * 41
  let count = 5
  for (let j = 0; j < 17; j++) {
    ctx.beginPath();
    x = cx + pet(d)*Math.cos(Math.random()*6.28)
    y = cy +pet(d)*Math.sin(Math.random()*6.28)
    ctx.arc(x, y, Math.random()*maxradius, 0, 2*Math.PI);
    ctx.fill();
  }
}

function specksRadial (color) {
  let canvas = document.getElementById("myCanvas");
  let dist = "rect"//document.getElementById("distro").value
  let cx = canvas.width/2, cy = canvas.height/2
  let ctx = canvas.getContext("2d");
  let grunge = document.getElementById("grungy").checked
  let num = document.getElementById("number").value
  let area = canvas.width * canvas.height
  let shapemultiplier = area/(1024*1024)
  num *= shapemultiplier
  let featuresize = 0.2+ document.getElementById("featuresize").value/200
  let r0 = featuresize
  let opacity = document.getElementById("opacity").value/100
  let flatness = false//document.getElementById("flatten").value
  let canvas_w = canvas.width
  let canvas_h = canvas.height
  let x = 0, y = 0
  let f = flatness/100 * canvas.height/2
  ctx.globalAlpha = opacity
  let alpha0 = ctx.globalAlpha
 // let maxY = canvas.height/2
  if (color)
    ctx.fillStyle = color
  else
    ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  if (dist != "gaussian")
    ;//clip()
  for (let j = 0; j < num; j++) {
    ctx.beginPath();
    if (dist == "gaussian") {
      x = randn_bm(0, canvas_w, 1)
      y = randn_bm(0, canvas_h, 1)
      if (flatness > 1) {
        x = randn_bm(f, canvas_size - f, 1)
      }
    } else {
      x = Math.random() * canvas_w
      y = Math.random() * canvas_h
    }
    ctx.arc(x, y, featuresize, 0, 2*Math.PI);
    ctx.closePath();
    if (grunge) {
      featuresize = r0 + Math.random() * r0 * 3
      ctx.globalAlpha = alpha0 + (Math.random() - 0.5) * alpha0
    }
    ctx.fill()
  }
  ctx.restore()
}

function caption () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext('2d');
  let cx = canvas.width/2, cy = canvas.height/2
  let face = document.getElementById("fontface").value
  let text = document.getElementById("caption").value
  let size = document.getElementById("featuresize").value
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.font = size+"pt " + face
  let x = canvas.width/2, y = canvas.height/2+size/2
  w = ctx.measureText(text).width
  ctx.fillText(text, x-w/2, y)
}

function character () {
  let grunge = document.getElementById("grungy").checked
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext('2d');
  ctx.globalAlpha = (document.getElementById("opacity").value)/100

  let styles = ["normal", "100", "500", "900", "bold", "italic", "lighter", "oblique"]
  let faces = ["monospaced", "sans-serif", "serif", "courier", "ariel", "times"]

  let x = -32, y = -32, x0 = x, y0 = y, off = 0;
  let numlines = 0;
  let x_inc = 16, y_inc = 16
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  let alpha0 = ctx.globalAlpha
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  let text = "+"//document.getElementById("atext").value
  let radius = document.getElementById("featuresize").value/6.25
  let rad0 = radius
  let rows = 24//Math.pow(2, 9-document.getElementById("rows").value)
  let inc = rows
  let maxy = canvas.height/2
  numlines = 0;
  x_inc = inc, y_inc = inc
  clip()
  ctx.font = radius+"px sans-serif"
  ctx.font = randomPick(styles)+" "+radius+"pt " + randomPick(faces)
  for (var i = 0; i < 24000; i++) {
    if (grunge) {
      ctx.globalAlpha = alpha0 + (Math.random() - 0.5) * alpha0
      radius = rad0 + Math.random() * rad0/3
      ctx.font = radius+"px"
      text = String.fromCharCode(32 + Math.floor(Math.random() * 96)) // 32 - 127 = ascii
    }
    if (grunge && Math.random() < 0.1)
      ctx.strokeText(text, x, y)
    else
      ctx.fillText(text, x, y)
    x += x_inc;
    if (i % (160) === 0) {
      numlines++;
      if (numlines % 2 === 0)
        off = x_inc/2;
      else
        off = 0;
      x = off - (radius/2);
      y += inc;
    }
  }
  ctx.restore()
}


function straightLines (cross) { // vertical lines
  let grunge = document.getElementById("grungy").checked
 // clearCanvas()
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext('2d');
  let x = -50, y = -50;
  let x_inc = 20, y_inc = 20
  ctx.globalAlpha = (document.getElementById("opacity").value) /100
  alpha0 = ctx.globalAlpha
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineWidth = document.getElementById("featuresize").value/(5*6.25)
  linewidth0 = ctx.lineWidth
  let radius = document.getElementById("featuresize").value/12.5
  let rows = document.getElementById("rows").value*8
  let inc = 512/rows
  numlines = 0;
  x = -20, y = 0 + ctx.lineWidth/2 // should try different initial offset
  x_inc = inc, y_inc = inc
  let maxy = canvas.height/2
  clip()
  let i = 0
  for (; i < 1000; i++) {
    if (grunge) {
      ctx.globalAlpha = alpha0 + (Math.random() - 0.5) * alpha0/1.3
      ctx.lineWidth = linewidth0 + Math.random() * linewidth0/4
    }
    ctx.beginPath();
    ctx.moveTo(-20, y)
    ctx.lineTo(canvas.width+20, y)
    ctx.stroke();
    y += y_inc
  }
  if (cross) {
    i = 0, x = -20, y = -20
    for (; i < 1000; i++) {
      if (grunge) {
        ctx.globalAlpha = alpha0 + (Math.random() - 0.5) * alpha0/1.3
        ctx.lineWidth = linewidth0 + Math.random() * linewidth0/4
      }
      ctx.beginPath();
      ctx.moveTo(x, y)
      ctx.lineTo(x, canvas.height+20)
      ctx.stroke();
      x += x_inc
      y = -20
    }
  }
  ctx.restore()
}

function slantedLines (cross) {
  let grunge = document.getElementById("grungy").checked
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext('2d');
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  alpha0 = ctx.globalAlpha
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineWidth = 1+document.getElementById("featuresize").value/10
  linewidth0 = ctx.lineWidth
  let inc = ctx.lineWidth * 3
  let x = inc, y = inc
  let x_inc = inc, y_inc = inc
  for (var i = 0; i < 1000; i++) {
    ctx.beginPath();
    ctx.moveTo(-20, y)
    ctx.lineTo(x, -20)
    ctx.stroke();
    x += x_inc
    y += y_inc
  }
  if (cross) {
    i = 0, x = -50, y = canvas.height + 50
    for (var i = 0; i < 1000; i++) {
      ctx.beginPath();
      ctx.moveTo(-20, y)
      ctx.lineTo(x, canvas.height+20)
      ctx.stroke();
      x += x_inc
      y -= y_inc
    }
  }
}

function linearSpiral () { // make like skinny Rings
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width, H = canvas.height
  var numpoints = Math.random() * 200 + 250;
  ctx.lineWidth = 1 + Math.floor(document.getElementById("featuresize").value/10)
  let ab = ctx.lineWidth/20
  let inc = 3 * ctx.lineWidth
  ctx.lineCap = 'round'
  ctx.lineJoin = 'round'
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.beginPath();
  let x = LASTCLICK[0], y = LASTCLICK[1], a = ab, b = ab
  ctx.moveTo(x, y);
  let angle = Math.random() * Math.PI * 2;
  let increase = 0.1
  while (x < W*2 && y < H*2) {
    ctx.lineTo(x, y);
    x = x + (a + b * angle) * Math.cos(angle);
    y = y + (a + b * angle) * Math.sin(angle);
    angle += increase;
  }
  ctx.stroke();
}

function skinnyRings () {
  let grunge = document.getElementById("grungy").checked
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext('2d');
  let x = -50, y = -50;
  let x_inc = 20, y_inc = 20
  ctx.globalAlpha = (document.getElementById("opacity").value) /100
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineWidth = 1 + Math.floor(document.getElementById("featuresize").value/10)
  let inc = 3 * ctx.lineWidth
  ctx.lineCap = 'round'
  ctx.lineJoin = 'round'
  linewidth0 = ctx.lineWidth
  let radius = 1
  numlines = 0;
  x = LASTCLICK[0], y = LASTCLICK[1]
  let i = canvas.height/2
  let maxD = Math.max(canvas.width, canvas.height)*2
  let start = 0, end = Math.PI*2
  while (radius < maxD) {
    ctx.beginPath();
    ctx.arc(x,y,radius,start,end)
    ctx.stroke();
    radius += inc
  }
}


function vanishingpoint () { // vertical lines
  let alt = document.getElementById("grungy").checked
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext('2d');
  let x = -canvas.height-10, y = -canvas.height/2;
  let vpx = canvas.width * 2 + pet (200)
  let vpy = canvas.height * Math.random()
  ctx.globalAlpha = (document.getElementById("opacity").value) /100
  alpha0 = ctx.globalAlpha
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineWidth = 5
  ctx.lineCap = 'round'
  ctx.lineJoin = 'round'
  ctx.lineWidth = 1 + Math.floor(document.getElementById("featuresize").value/10)
  let inc = 6
  numlines = 0;
  let maxy = canvas.height/2
  let W = canvas.width, H = canvas.height
  //if (grunge)
  maxy *= 3
  vpx = W + LASTCLICK[0]*2, vpy = LASTCLICK[1]
  let cpx = 0, cpy = 0
  while (y < maxy) {
    ctx.lineWidth = randomPick([1,1,1,2,3,4,1,1,1,1,2,2])
    if (Math.random() > 0.98) {
      ctx.beginPath();
      ctx.moveTo(x, y)
      cpx = (vpx-x)/1.9 + pet(520)
      cpy = Math.max(vpy,y) +Math.random() * 300
      if (alt)
        ctx.lineTo(vpx,vpy)
      else
        ctx.quadraticCurveTo(cpx,cpy,vpx,vpy)
      ctx.stroke();
    }
    y += inc
  }
}

function skinnyLines () { // vertical lines
  let grunge = document.getElementById("grungy").checked
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext('2d');
  let x = -50, y = -50;
  let x_inc = 20, y_inc = 20
  ctx.globalAlpha = (document.getElementById("opacity").value) /100
  alpha0 = ctx.globalAlpha
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineWidth = 5//1
  ctx.lineCap = 'round'
  ctx.lineJoin = 'round'
  ctx.lineWidth = 1 + Math.floor(document.getElementById("featuresize").value/10)
  let inc = ctx.lineWidth*3//512/rows
  numlines = 0;
  x = -20, y = 0 + ctx.lineWidth/2 // should try different initial offset
 // x_inc = inc, y_inc = inc
  let maxy = canvas.height * 2
  let i = canvas.height/2
  for (; i < maxy; i++) {
    if (grunge) {
      //ctx.globalAlpha = alpha0 + (Math.random() - 0.5) * alpha0/1.3
      //ctx.lineWidth = linewidth0 + Math.random() * linewidth0/4
    }
    ctx.beginPath();
    ctx.moveTo(-20, y)
    ctx.lineTo(canvas.width+20, y)
    ctx.stroke();
    y += inc
  }
}

function bezRandom () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width
  let H = canvas.height
  ctx.lineCap = 'round'
  ctx.lineJoin = 'round'
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  let x = 0, y = 0, x0, y0;
  let edges = 8 + 4 * Math.floor(document.getElementById("number").value/1000)
  if (Math.random() > 0.5)
   ;// edges += 8
  let points = [];
  for (let i = 0; i < edges; i++) {
    x = Math.floor(Math.random() * W)
    y = Math.floor(Math.random() * H)
    points.push([x, y]);
    if (i === 0) {
      x0 = x, y0 = y
    }
  }
  drawBezline(points, 0, 0)
}

function fillPoints (pts, offsetX, offsetY, color) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let x = 0, y = 0, x0 = 0, y0 = 0,  r = 6
  ctx.fillStyle = 'blue'
  ctx.beginPath()
  let i = 0;
  for (; i < pts.length; i++) {
    x = pts[i][0]
    y = pts[i][1]
    if (i == 0) {
      ctx.moveTo(x, y);
    } else
    if (i > 0 && i % 3 == 0)
      ctx.bezierCurveTo(pts[i-2][0], pts[i-2][1], pts[i-1][0], pts[i-1][1], pts[i][0], pts[i][1]);
    
    ctx.fillStyle = 'red'
    if (i % 3 == 0)
      ctx.fillStyle = 'black'
   // ctx.beginPath()
   // ctx.arc(x,y,r,0,Math.PI*2)
   // ctx.closePath();
   // ctx.fill();
  }
  ctx.closePath();
  ctx.fillStyle = color
  ctx.fill();
}


function blobOutline () {
  let grunge = document.getElementById("grungy").checked
  let increase = Math.PI * 2 / 40;
  let x = 350, y = 270, angle = 4.7;
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let W = canvas.width
  let centx = canvas.width/2
  let centy = canvas.height/2
  let area = canvas.width * canvas.height
  let cx = centx, cy = centy
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  let alpha0 = ctx.globalAlpha
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/4
  x = 0;
  y = 0;
  let x0 = x;
  let y0 = y;
  angle = Math.floor(Math.random() * 6.42)
  centx = ctx.canvas.width/2
  centy = ctx.canvas.height/2
  let edges = 8 + Math.floor(Math.random() * 18)
  let rmax = W/2.67
  let maxradius = 1 + rmax * Math.random();
  let r0 = maxradius
  increase = Math.PI * 2/edges*0.98;
  points = [];
  bez = [];
  let radius = W/2.5
  for (let i = 0; i < edges; i++) {
    //radius = (Math.random() * maxradius) + maxradius * 0.9;
    radius += pet(maxradius/1.4)
    x = radius * Math.cos(angle)+centx;
    y = radius * Math.sin(angle)+centy;
    points.push([x, y]);
    angle += increase;
  }
  //points.push(x0,y0)
  drawOutline(points, 0, 0)
}

function blobs () {
  let grunge = document.getElementById("grungy").checked
  let increase = Math.PI * 2 / 40;
  let x = 350, y = 270, angle = 4.7;
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let centx = canvas.width/2;
  let centy = canvas.height/2;
  let area = canvas.width * canvas.height
  let shapemultiplier = area/(1024*1024)
  let cx = centx, cy = centy
  ctx.globalAlpha = (document.getElementById("opacity").value)/200
  let alpha0 = ctx.globalAlpha
  let numshapes = 25
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  numshapes = 1 + document.getElementById("number").value/10
  numshapes *= shapemultiplier
  let radius = 1
  for (let t = 0; t < numshapes; t++) {
    x = 0;
    y = 0;
    let x0 = x;
    let y0 = y;
    angle = Math.floor(Math.random() * 6.42);
    centx = Math.random()*ctx.canvas.width+5;
    centy = Math.random()*ctx.canvas.height+5
    let edges = 19 * Math.random() + 9;
    let rmax = document.getElementById("featuresize").value/20 // max = 500
    let maxradius = 1 + rmax * Math.random();
    let r0 = maxradius
    increase = Math.PI * 2/edges*0.98;
    points = [];
    bez = [];
    radius = (Math.random() * maxradius) + maxradius * 0.9;
    for (let i = 0; i < edges; i++) {
      if (grunge) {
        maxradius = r0 + (Math.random()) * r0 * 2
      }
      //radius = (Math.random() * maxradius) + maxradius * 0.9;
      radius += pet(maxradius/1)
      x = radius * Math.cos(angle)+centx;
      y = radius * Math.sin(angle)+centy;
      points.push([x, y]);
      angle += increase;
    }
    let W = canvas.width
    drawPath(points, 0, 0)
    /*
    drawPath(points, -W, -W)
    drawPath(points, 0, -W)
    drawPath(points, W, -W)

    drawPath(points, -W, +W)
    drawPath(points, 0, +W)
    drawPath(points, W, +W)

    drawPath(points, -W, 0)
    drawPath(points, +W, 0)*/
  }
}


function scratch () { // based on blobs
  let grunge = document.getElementById("grungy").checked
  let increase = Math.PI * 2 / 40;
  let x = 0, y = 0, angle = 4.7;
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let centx = LASTCLICK[0] //20 + Math.random() * canvas.width - 40
  let centy = ctx.canvas.height/2;
  let cx = centx, cy = centy
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  let alpha0 = ctx.globalAlpha
  let numshapes = 1 + document.getElementById("number").value/20
  let area = canvas.width * canvas.height
  let shapemultiplier = area/(1024*1024)
  numshapes *= shapemultiplier
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let radius = 1
  for (let t = 0; t < numshapes; t++) {
    x = 0;
    y = 0;
    angle = Math.floor(Math.random() * 6.42);
    centy = Math.random()*ctx.canvas.height+5
    let edges = 19 * Math.random() + 9;
    let rmax = document.getElementById("featuresize").value/20 // max = 500
    let maxradius = 1 + rmax * Math.random();
    let r0 = maxradius
    increase = Math.PI * 2/edges*0.98;
    points = [];
    radius = (Math.random() * maxradius) + maxradius * 0.9;
    for (let i = 0; i < edges; i++) {
      if (grunge) {
        maxradius = r0 + (Math.random()) * r0 * 2
      }
      radius += pet(maxradius)
      x = radius * Math.cos(angle)+centx;
      y = radius * Math.sin(angle)+centy;
      points.push([x, y]);
      angle += increase;
    }
    drawPath(points, 0, 0)
  }
}

function drawBlobAt (ctx, x, y, r) {
  let x0 = x;
  let y0 = y;
  angle = Math.floor(Math.random() * 6.42);
  let edges = 7 * Math.random() + 3;
  let rmax = r
  let maxradius = 1 + rmax/1.5 * Math.random();

  let r0 = r
  increase = Math.PI * 2/edges*0.98;
  points = [];
  points.push([x,y])
  radius = (Math.random() * maxradius) + maxradius * 0.9;
  for (let i = 0; i < edges-1; i++) {
    radius += pet(maxradius)
    x += radius * Math.cos(angle);
    y += radius * Math.sin(angle);
    points.push([x, y]);
    angle += increase;
  }
  drawPath(points, 0, 0, ctx)
}

function threeCircles () {
  let canvas = document.getElementById("myCanvas");
  let mult = 1+ document.getElementById("featuresize").value/300
  let ctx = canvas.getContext("2d");
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let cy = ctx.canvas.height/2;
  let x = canvas.width/5, i = 0
  let r = canvas.width/6 * mult
  let colors = shuffle(getCurrentPalette())
  let offset = [canvas.width/5, canvas.width/2, 4*canvas.width/5
  ]
  for (; i < 3; i++) {
    ctx.fillStyle = colors[i]
    drawCircleAt(ctx,offset[i]+pet(41),cy+pet(4),r+pet(3))
  }
}

function drawCircleAt(ctx,x,y,r) {
  ctx.beginPath()
  ctx.moveTo(x, y)
  ctx.arc(x,y,r,0,Math.PI*2)
  ctx.closePath()
  ctx.fill()
}

function drawHouseAt(ctx,x,y,r) {
  ctx.beginPath()
  x += pet(Math.random() * r)
  y -= r
  r *= 2
  ctx.moveTo(x, y)  //top
  x += r/2 + pet(20)
  y += r/2
  ctx.lineTo(x, y) //right tip
  x -= (18)+pet(11)
  ctx.lineTo(x, y+pet(14)) // x in
  y += r/2
  ctx.lineTo(x+pet(11), y+pet(34))// right bottom
  y += r/7
  x -= r/2 + pet (r/2)
  ctx.lineTo(x+pet(4), y+pet(11))// bottom minpoint
  y -= r/7
  x -= r/3
  ctx.lineTo(x+pet(14), y+pet(34)) //left bottom
  y -= r/2
  ctx.lineTo(x+pet(14), y+pet(11)) // x in left
  x -= 17
  ctx.lineTo(x+pet(11), y+pet(14)) // left tip
  
  ctx.closePath()
  ctx.fill()
}

function drawRectAt(ctx,x,y,r,LINE) {
  ctx.beginPath()
  if (!LINE) {
    x -= r
    y -= r
    r *= 2
  }
  ctx.moveTo(x, y)
  ctx.lineTo(x+r, y)
  ctx.lineTo(x+r, y+r)
  ctx.lineTo(x, y+r)
  if (LINE) {
    ctx.lineTo(x, y)
    ctx.stroke()
  } else {
    ctx.closePath()
    ctx.fill()
  }
}

function drawXAt(ctx,x,y,r) {
  ctx.beginPath()
  x -= r
  y -= r
  let h = r*2
  ctx.moveTo(x+h/4, y)
  ctx.lineTo(x+h/2, y+h/4)
  ctx.lineTo(x+h*3/4, y)
  ctx.lineTo(x+h, y+h/4)
  
  ctx.lineTo(x+h*3/4, y+h/2)
  ctx.lineTo(x+h, y+h*3/4)

  ctx.lineTo(x+h*3/4, y+h)
  ctx.lineTo(x+h/2, y+h*3/4)
  ctx.lineTo(x+h/4, y+h)
  
  ctx.lineTo(x, y+h*3/4)
  ctx.lineTo(x+h/4, y+h/2)
  ctx.lineTo(x, y+h/4)

  ctx.closePath()
  ctx.fill()
}

function drawDiamondAt(ctx,x,y,r) {
  ctx.beginPath()
  x -= r
  y -= r
  let h = r*2
  ctx.moveTo(x+h/2, y)
  ctx.lineTo(x+h, y+h/2)
  
  ctx.lineTo(x+h/2, y+h)

  ctx.lineTo(x, y+h/2)

  ctx.closePath()
  ctx.fill()
}


function drawTriangleAt(ctx,x,y,r) {
  ctx.beginPath()
  x -= r
  y -= r
  ctx.moveTo(x+r, y)
  r*=2
  ctx.lineTo(x+r, y+r)
  ctx.lineTo(x, y+r)
  ctx.closePath()
  ctx.fill()
}

function card () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let h = canvas.height;
  let w = canvas.width;
  let centerx = ctx.canvas.width / 2;
  let centery = ctx.canvas.height / 2;
  let x = centerx/2
  let y = centery/2
  let r = h/5
  let colors = []
  let i = 0
  for (; i < 2; i++)
    colors.push(randomColor())
  ctx.fillStyle = randomGradient(canvas);
  //ctx.save()
  clip()
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  let grunge = document.getElementById("grungy").checked
  if (grunge) {
    colors = ["red", "blue", "yellow", "green"]
  }

  ctx.fillStyle = randomPick(colors)
  let f = (Math.floor(Math.random() * 4))
  if (f == 0)
    drawCircleAt(ctx,x,y,r)
  else
  if (f == 1)
    drawTriangleAt(ctx,x,y,r)
  else
  if (f == 2)
    drawRectAt(ctx,x,y,r)
  else
    drawXAt(ctx,x,y,r)
  
  y = h * 0.75
  ctx.fillStyle = randomPick(colors)
  f = (Math.floor(Math.random() * 4))
  if (f == 0)
    drawCircleAt(ctx,x,y,r)
  else
  if (f == 1)
    drawTriangleAt(ctx,x,y,r)
  else
  if (f == 2)
    drawRectAt(ctx,x,y,r)
  else
    drawXAt(ctx,x,y,r)
    
  x = h * 0.75
  ctx.fillStyle = randomPick(colors)
  f = (Math.floor(Math.random() * 4))
  if (f == 0)
    drawCircleAt(ctx,x,y,r)
  else
  if (f == 1)
    drawTriangleAt(ctx,x,y,r)
  else
  if (f == 2)
    drawRectAt(ctx,x,y,r)
  else
    drawXAt(ctx,x,y,r)
  
  y = h * 0.25
  ctx.fillStyle = randomPick(colors)
  f = (Math.floor(Math.random() * 4))
  if (f == 0)
    drawCircleAt(ctx,x,y,r)
  else
  if (f == 1)
    drawTriangleAt(ctx,x,y,r)
  else
  if (f == 2)
    drawRectAt(ctx,x,y,r)
  else
    drawXAt(ctx,x,y,r)
  //pushColor(randomPick(colors))
  ctx.restore()
}

function card2 () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let h = canvas.height;
  let w = canvas.width;
  let centerx = ctx.canvas.width / 2;
  let centery = ctx.canvas.height / 2;
  let x = centerx/3
  let y = centery/3
  let r = h/6 - 12
  let colors = []
  let i = 0
  for (; i < 3; i++)
    colors.push(randomColor())
  ctx.fillStyle = "#ffffff"
  ctx.fillRect(0,0,canvas.width, canvas.height)

  ctx.fillStyle = randomGradient(canvas);
  ctx.fillRect(0,0,canvas.width, canvas.height)
  //ctx.save()
  clip()
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  let grunge = document.getElementById("grungy").checked
  if (grunge) {
    colors = ["red", "blue", "yellow", "green", "orange"]
  }

  ctx.fillStyle = randomPick(colors)
  let f = (Math.floor(Math.random() * 4))
  if (f == 0)
    drawCircleAt(ctx,x,y,r)
  else
  if (f == 1)
    drawTriangleAt(ctx,x,y,r)
  else
  if (f == 2)
    drawRectAt(ctx,x,y,r)
  else
    drawXAt(ctx,x,y,r)
  
  x += h * 1/3
  ctx.fillStyle = randomPick(colors)
  f = (Math.floor(Math.random() * 4))
  if (f == 0)
    drawCircleAt(ctx,x,y,r)
  else
  if (f == 1)
    drawTriangleAt(ctx,x,y,r)
  else
  if (f == 2)
    drawRectAt(ctx,x,y,r)
  else
    drawXAt(ctx,x,y,r)
  
   x += h * 1/3
  ctx.fillStyle = randomPick(colors)
  f = (Math.floor(Math.random() * 4))
  if (f == 0)
    drawCircleAt(ctx,x,y,r)
  else
  if (f == 1)
    drawTriangleAt(ctx,x,y,r)
  else
  if (f == 2)
    drawRectAt(ctx,x,y,r)
  else
    drawXAt(ctx,x,y,r)
    
  x = centerx/3, y =  centery/3 + h * 1/3
  ctx.fillStyle = randomPick(colors)
  f = (Math.floor(Math.random() * 4))
  if (f == 0)
    drawCircleAt(ctx,x,y,r)
  else
  if (f == 1)
    drawTriangleAt(ctx,x,y,r)
  else
  if (f == 2)
    drawRectAt(ctx,x,y,r)
  else
    drawXAt(ctx,x,y,r)
  
  x += h * 1/3
  ctx.fillStyle = randomPick(colors)
  f = (Math.floor(Math.random() * 4))
  if (f == 0)
    drawCircleAt(ctx,x,y,r)
  else
  if (f == 1)
    drawTriangleAt(ctx,x,y,r)
  else
  if (f == 2)
    drawRectAt(ctx,x,y,r)
  else
    drawXAt(ctx,x,y,r)
    
  x += h * 1/3
  ctx.fillStyle = randomPick(colors)
  f = (Math.floor(Math.random() * 4))
  if (f == 0)
    drawCircleAt(ctx,x,y,r)
  else
  if (f == 1)
    drawTriangleAt(ctx,x,y,r)
  else
  if (f == 2)
    drawRectAt(ctx,x,y,r)
  else
    drawXAt(ctx,x,y,r)
    
  // botton row
  x = centerx/3, y =  centery/3 + h * 2/3
  ctx.fillStyle = randomPick(colors)
  f = (Math.floor(Math.random() * 4))
  if (f == 0)
    drawCircleAt(ctx,x,y,r)
  else
  if (f == 1)
    drawTriangleAt(ctx,x,y,r)
  else
  if (f == 2)
    drawRectAt(ctx,x,y,r)
  else
    drawXAt(ctx,x,y,r)
  
  x += h * 1/3
  ctx.fillStyle = randomPick(colors)
  f = (Math.floor(Math.random() * 4))
  if (f == 0)
    drawCircleAt(ctx,x,y,r)
  else
  if (f == 1)
    drawTriangleAt(ctx,x,y,r)
  else
  if (f == 2)
    drawRectAt(ctx,x,y,r)
  else
    drawXAt(ctx,x,y,r)
    
  x += h * 1/3
  ctx.fillStyle = randomPick(colors)
  f = (Math.floor(Math.random() * 4))
  if (f == 0)
    drawCircleAt(ctx,x,y,r)
  else
  if (f == 1)
    drawTriangleAt(ctx,x,y,r)
  else
  if (f == 2)
    drawRectAt(ctx,x,y,r)
  else
    drawXAt(ctx,x,y,r)
  ctx.restore()
}

function randomWord (PT) {
  if (PT)
    return randomPick(ptwords)
  else
    return randomPick(words.split("\n"))
}

function randomWordPT () {
  return randomPick(ptwords)
}

function diagonal () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let h = canvas.height;
  let w = canvas.width;
  let centerx = ctx.canvas.width / 2;
  let centery = ctx.canvas.height / 2;
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let baseline = h * 4/5
  let x =-10
  let y = Math.random() * h/3
  ctx.beginPath()
  ctx.moveTo(x, y)
  let slope = 2 * Math.random()
  let i = 0
  while (y < baseline && x < w) {
    y += slope + pet (13)//+ (Math.random() - 0.5) * 0.5
    x += 5 * Math.random()
    ctx.lineTo(x, y)
    if (Math.random() > 0.8) {
      y += 6 * Math.random()
      x += 7 * Math.random()
    }
    if (Math.random() > 0.9) {
      y -= 5 * Math.random()
      x += 4 * Math.random()
    }
  }
  y = baseline
  while (x > 0) {
    y += 0.25+pet(6)
    x -= 2 * Math.random()
    ctx.lineTo(x,y)
  }
  ctx.closePath()
  ctx.fill()
  flipH()
}

function drawShape (line) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.globalCompositeOperation = document.getElementById("mode").valu2
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + Math.floor(document.getElementById("featuresize").value/2)
  fs = 1 + Math.floor(document.getElementById("featuresize").value/2)
  ctx.lineCap = "butt"
  ctx.lineJoin = "round"
  let pm = Math.floor(document.getElementById("number").value/2000)
  ctx.fillStyle=randomPick(getCurrentPalette())
  let s = canvas.width/1200
  let x = 0, y = 0
  let points = document.getElementById('points').value
  let smooth = +document.getElementById("smooth").value
  ctx.strokeStyle = randomPick(getCurrentPalette())

  let k = 0
  if (points.length > 1) {
    let pointsP = JSON.parse(points)
    let i = 0
    offpaintbrush(ctx.fillStyle, fs)
    for (; k < pointsP.length; k++) {
      let pk = pointsP[k]
      pk = pk.filter(function(_, i) {
      return ((i + 1) % smooth === 0);
      })
      i = 0
      let j = 0
      let buff = []
      for (; i < pk.length; i++) {
        j = 0
        for (; j < 2; j++) {
          pk[i][j] = pk[i][j] * s
          buff.push(pk[i][j])
        }
        crayAt(pk[i][0], pk[i][1], ctx,fs*2)
        //paintbrushAt(pk[i][0], pk[i][1], ctx,fs*2)
        
       if (buff.length === 8) {
          bez_pts_cray(buff[0],buff[1],buff[2],buff[3],buff[4],buff[5],buff[6],buff[7], ctx, fs)
          buffx = []
          buffx.push(buff[6],buff[7])
          buff = buffx
        }
        if (Math.random() > 0.6)
          offpaintbrush(ctx.fillStyle, fs)
      }
    }
  }
  LATESTFUNCTION = "drawShape"
}

function drawShapeOG (line) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  ctx.globalAlpha = document.getElementById("opacity").value/100
  ctx.globalCompositeOperation = document.getElementById("mode").valu2
  let alt = document.getElementById("grungy").checked
  ctx.lineWidth = 1 + Math.floor(document.getElementById("featuresize").value/2)
  ctx.lineCap = "butt"
  ctx.lineJoin = "round"
  let pm = Math.floor(document.getElementById("number").value/2000)
  ctx.fillStyle=randomPick(getCurrentPalette())
  let s = canvas.width/1200
  let x = 0, y = 0
  let points = document.getElementById('points').value
  let smooth = +document.getElementById("smooth").value
  let k = 0
  if (points.length > 1) {
    let pointsP = JSON.parse(points)
    let i = 0
    for (; k < pointsP.length; k++) {
      let pk = pointsP[k]
      pk = pk.filter(function(_, i) {
      return ((i + 1) % smooth === 0);
      })
      i = 0
      let j = 0
      for (; i < pk.length; i++) {
        j = 0
        for (; j < 2; j++) {
          pk[i][j] = pk[i][j] * s //+ pet(p)
        }
      }
      ctx.strokeStyle = randomPick(getCurrentPalette())
      ctx.fillStyle = randomPick(getCurrentPalette())
      drawBezline(pk, 0, 0, !alt)
    }
  }
  LATESTFUNCTION = "drawShape"
}

function rotatePoint (x, y, centerx, centery, degrees) {
  let newx = (x - centerx) * Math.cos(degrees * Math.PI / 180) - (y - centery) * Math.sin(degrees * Math.PI / 180) + centerx;
  let newy = (x - centerx) * Math.sin(degrees * Math.PI / 180) + (y - centery) * Math.cos(degrees * Math.PI / 180) + centery;
  return [newx, newy];
}

function updatetxtsize () {
  let v = document.getElementById("textsize").value
  document.getElementById("txtsize").innerHTML = v
}

function placeSquareAt () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let h = canvas.height;
  let w = canvas.width;
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let x = LASTCLICK[0]
  let y = LASTCLICK[1]
  let r = 18// + +document.getElementById("textsize").value
  r += pet(r/3)
  x -= r/2, y += r/2 // offset to place center aligned
  let angle = 24//+document.getElementById("angle").value
 // if (document.getElementById("randomangle").checked)
    angle += pet(45)
  let p = rotatePoint(x,y,LASTCLICK[0], LASTCLICK[1], angle)
  ctx.moveTo(p[0], p[1])
  ctx.beginPath()
  p = rotatePoint(x+r,y,LASTCLICK[0], LASTCLICK[1], angle)
  ctx.lineTo(p[0], p[1])
  p = rotatePoint(x+r,y-r,LASTCLICK[0], LASTCLICK[1], angle)
  ctx.lineTo(p[0], p[1])
  p = rotatePoint(x,y-r,LASTCLICK[0], LASTCLICK[1], angle)
  ctx.lineTo(p[0], p[1])
  p = rotatePoint(x,y,LASTCLICK[0], LASTCLICK[1], angle)
  ctx.lineTo(p[0], p[1])
  ctx.closePath()
  ctx.fill()
}

function flareAt (x, y, r, c, a, ctx, offsets) {
  ctx.globalAlpha = a
  ctx.fillStyle = c
  ctx.strokeStyle = c
  let color = c
  let grd = ctx.createRadialGradient(x, y, 0.1, x, y, r*2);
  grd.addColorStop(0,c);
  a = 0.1
  grd.addColorStop(0.5, "rgba("+hexToR(color)+", "+hexToG(color)+", "+hexToB(color)+", "+a+")");
  a = 0
  grd.addColorStop(0.75, "rgba("+hexToR(color)+", "+hexToG(color)+", "+hexToB(color)+", "+a+")");
  ctx.fillStyle = grd
  ctx.beginPath()
  ctx.arc(x, y, r, 0, Math.PI*2);
  ctx.closePath()
  ctx.fill()
  
  let i = 0
  if (document.getElementById("grungy").checked)
  for (; i < offsets.length; i += 2) {
    ctx.lineWidth = 1 + r/44
    ctx.strokeStyle = grd
    ctx.beginPath()
    ctx.moveTo(x+offsets[i]*r, y+offsets[i+1]*r)
    ctx.lineTo(x-offsets[i]*r, y-offsets[i+1]*r)
    ctx.closePath()
    ctx.stroke()
  }
}

function bokehAt (x, y, r, c, a, ctx) {
  ctx.globalAlpha = a
  ctx.fillStyle = c
  ctx.strokeStyle = c
  let color = c
  
  let grd = ctx.createRadialGradient(x+pet(r*1.2), y+pet(r*1.2), 0, x+pet(r*1.2), y+pet(r*1.1), r*1.5);
  grd.addColorStop(0, "rgba("+hexToR(color)+", "+hexToG(color)+", "+hexToB(color)+", "+a+")");
  grd.addColorStop(1,c);
  
  ctx.fillStyle = grd
  ctx.beginPath()
  ctx.arc(x, y, r, 0, Math.PI*2);
  ctx.closePath()
  ctx.fill()
  
  let i = 0
  ctx.globalAlpha /= 10
  for (; i < 5; i++) {
    ctx.beginPath()
    ctx.arc(x+pet(r/2), y+pet(r/2), r, 0, Math.PI*2);
    ctx.closePath()
    ctx.fill()
  }
  ctx.globalAlpha *= 5
  ctx.lineCap = "round"
  i = 0, start = 0
  for (; i < 9; i++) {
    ctx.beginPath()
    start = Math.random() * 2 * Math.PI
    ctx.arc(x, y, r * 0.97, start, start + Math.PI * Math.random()/6);
    ctx.lineWidth = r/50 + Math.random() * 1
    ctx.stroke()
  }
}

function placeBokehAt () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.strokeStyle = randomPick(getCurrentPalette()) // was paintcolor
  
  let x = LASTCLICK[0]
  let y = LASTCLICK[1]
  let r = 1 + +document.getElementById("textsize").value
  r /= 2
  r += pet(r/3)
  
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let a = 0.4 + Math.random() * 0.3
  let grd = ctx.createRadialGradient(x+pet(r*1.2), y+pet(r*1.2), 0, x+pet(r*1.2), y+pet(r*1.1), r*1.5);
  grd.addColorStop(0, "rgba("+hexToR(color)+", "+hexToG(color)+", "+hexToB(color)+", "+a+")");
  grd.addColorStop(1, randomPick(getCurrentPalette())) // was paintcolor);
  
  ctx.fillStyle = grd
  ctx.beginPath()
  ctx.arc(x, y, r, 0, Math.PI*2);
  ctx.closePath()
  ctx.fill()
  
  let i = 0
  ctx.globalAlpha /= 10
  for (; i < 5; i++) {
    ctx.beginPath()
    ctx.arc(x+pet(r/2), y+pet(r/2), r, 0, Math.PI*2);
    ctx.closePath()
    ctx.fill()
  }
  ctx.globalAlpha *= 4
  //ctx.globalAlpha *= 0.4
  ctx.lineCap = "round"
  i = 0, start = 0
  for (; i < 9; i++) {
    ctx.beginPath()
    start = Math.random() * 2 * Math.PI
    ctx.arc(x, y, r * 0.97, start, start + Math.PI * Math.random()/6);
    ctx.lineWidth = r/50 + Math.random() * 1
    ctx.stroke()
  }
}

function placeDotAt () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let h = canvas.height;
  let w = canvas.width;
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let x = LASTCLICK[0]
  let y = LASTCLICK[1]
  let r = 1 + +document.getElementById("textsize").value
  r /= 2
  r += pet(r/3)
  ctx.beginPath()
  ctx.arc(x, y, r, 0, Math.PI*2);
  ctx.closePath()
  ctx.fill()
  if (document.getElementById("grungy").checked) {
    ctx.globalAlpha = 0.15
    r *= 1.1
    ctx.beginPath()
    ctx.arc(x+pet(2), y, r, 0, Math.PI*2);
    ctx.closePath()
    ctx.fill()
    r*= 1.1
    ctx.beginPath()
    ctx.arc(x, y+pet(2), r, 0, Math.PI*2);
    ctx.closePath()
    ctx.fill()
  }
}

function clearCaption () {
  document.getElementById("caption").value = ""
}
function clearFace () {
  document.getElementById("face").value = ""
}

function placeRectAt () { // word-shaped rect
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  W = canvas.width
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let fs = 2.6*(4 + document.getElementById("featuresize").value/10)
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle'
  
  
  if (document.getElementById("grungy").checked) {
   // ctx.fillStyle = randomPick(getCurrentPalette())
    ctx.shadowBlur = fs/4 + Math.random() * fs/4
    ctx.shadowColor = ctx.fillStyle
    ctx.shadowOffsetX = (Math.random()-0.5) * 4
    ctx.shadowOffsetY  = (Math.random()-0.5) * 4
  }
  let text = randomPick(["a","aa","aaa","aaaa","aaaaa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa", "aaaaaaaa", "aaaaaaaaa"])
  let x = LASTCLICK[0]
  let y = LASTCLICK[1]

  ctx.font = "100 "+(fs)+"pt AmericanTypewriter,Courier"
  let w = ctx.measureText(text).width
 // ctx.fillText(text, x, y)
  ctx.fillRect(x,y-fs/2,w,fs)
  LASTCLICK[0] += w + fs
  if (x+w > W) {
    LASTCLICK[1] += fs*2
    LASTCLICK[0] = 0
  }
  
  ctx.shadowBlur = 0
  ctx.shadowOffsetX = 0
  ctx.shadowOffsetY = 0
}

function placeTextAt (t,canvas) {
  let text = document.getElementById("points").value
  if (t)
    text = t
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  W = canvas.width
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let fs = 2.6*(4 + document.getElementById("featuresize").value/5)
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle'
  if (text.length < 1)
    text = randomWord()
  let x = LASTCLICK[0]
  let y = LASTCLICK[1]
 
  ctx.font = "100 "+(fs)+"pt AmericanTypewriter,Courier"
  let w = ctx.measureText(" "+text).width
  ctx.fillText(text, x, y)
  LASTCLICK[0] += w
  if (x+w > W) {
    LASTCLICK[1] += fs*2
    LASTCLICK[0] = 0
  }
  if (document.getElementById("grungy").checked) {
    // add grit
    w = ctx.measureText(text).width
    let i = 0
    for (; i < 4*text.length; i++) {
      let r = (fs*fs/9)/111 * Math.random()
      drawBlobAt(ctx, x + Math.random()*w, y-fs/2 + Math.random()*fs, r)
    }
  }
}
/*
function stem (x,y,r, m) {
  this.x = x
  this.y = y
  this.r = r
  this.bias = (Math.random() - 0.5) * 0.3
  this.xdelta = (5+Math.random()*5) * (Math.random() - 0.5)
  this.max = m //+ Math.random() * 100
  this.count = 0
}

function branching () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  let h = canvas.height;
  let w = canvas.width;
  let branches = []
  let m = 2150, yf = 1
  let x = w/2 + pet(w/2), y = h, r = w/130 + pet(w/120)
  let s = new stem (x,y,r, m)
  branches.push(s)
  let i = 0
  let n = 0
  for (; n < 1700; n++) {
    i = 0
    for (; i < branches.length; i++) {
      if (branches[i].count < branches[i].max) {
        drawCircleAt(ctx, branches[i].x+pet(branches[i].r/4), branches[i].y, branches[i].r +pet(branches[i].r/7))
        branches[i].x += 1.2*(branches[i].xdelta*branches[i].r) * branches[i].bias
        branches[i].y -= branches[i].r/2 + pet(3) * yf
        
        branches[i].r *= 0.991
        branches[i].count++
        branches[i].xdelta *= 1.002
        if (Math.random() > 0.997)
          branches[i].bias *= 0.9
        m *= 0.995
        if (Math.random() > 0.95 && branches.length < 90) {
          branches.push(new stem(branches[i].x, branches[i].y, branches[i].r, m))
        }
      }
    }
  }
}
*/
function land () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let h = canvas.height;
  let w = canvas.width;
  let centerx = ctx.canvas.width / 2;
  let centery = ctx.canvas.height / 2;
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  //randomPick(getCurrentPalette()) // was paintcolor = randomColor()
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor
  let baseline = h - h/7 * Math.random() - 10
  let x =-10
  let y = baseline - h/3 * Math.random() - 30
  ctx.beginPath()
  ctx.moveTo(x, y)
  let slope = 0.01 * Math.random()
  let i = 0
  while (y < baseline && x < w) {
    y += slope + pet (3)//+ (Math.random() - 0.5) * 0.5
    x += 5 * Math.random()
    ctx.lineTo(x, y)
    if (Math.random() > 0.8) {
      y += 6 * Math.random()
      x += 7 * Math.random()
    }
    if (Math.random() > 0.9) {
      y -= 5 * Math.random()
      x += 4 * Math.random()
    }
  }
  y = baseline
  while (x > 0) {
    y += pet(6)
    x -= 5 * Math.random()
    ctx.lineTo(x,y)
  }
  ctx.closePath()
  ctx.fill()
  flipH()
}

function shape2 () {// right side only
  var radvar = 0;
  var increase = Math.PI * 2 / 40;
  var x = 0, y = 0, angle = 4.7;
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  var h = canvas.height;
  var w = canvas.width;
  var centerx = ctx.canvas.width / 2;
  var centery = ctx.canvas.height / 2;
  ctx.fillStyle = randomGradient(canvas);
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  let grunge = document.getElementById("grungy").checked
  let numshapes = 1
  let ia = 0
  ctx.save()
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor;
  if (grunge)
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
  for (var t = 0; t < numshapes; t++) {
    let radius = 10
    x = 0;
    y = 0;
    var x0 = x;
    var y0 = y;
    let turn = 0
    angle = Math.PI/2
    let angle2 = angle
    ctx.beginPath();
    var centx = canvas.width + 20 + canvas.width/3
    var centy = canvas.height/2 + pet(canvas.height);
    var edges = Math.random()*31+Math.random()*31;
    var maxradius = canvas.height/1.7 + Math.random() * canvas.height/5;
    increase = Math.PI * 2/edges;
    ctx.beginPath();
    let rfactor = 2
    let mfactor = maxradius
    for (var i = 0; i < edges-1; i++) {
      angle2 = angle + Math.PI / edges
      rfactor =  maxradius/40 + Math.random() *11
      if (Math.random()> 0.63)
        mfactor += (Math.random() - 0.5) * maxradius/9
      radius = Math.random() * rfactor + mfactor;
      radius += pet(radius/7)
      centx = centx+pet(23)
      centy = centy+pet(23)
      ctx.arc(centx, centy, radius, angle, angle2)
      angle = angle2
      ia = increase + Math.PI/180 * pet(2);
      angle += ia
      turn += ia
      if(turn >= 6.28)
        break;
    }
    ctx.closePath();
    ctx.fill();
    ctx.clip()
    randomColor()
    document.getElementById("opacity").value = 77
    strokes2()
  }
  ctx.restore()
}

function shape () {// right side only
  var radvar = 0;
  var increase = Math.PI * 2 / 40;
  var x = 0, y = 0, angle = 4.7;
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  var h = canvas.height;
  var w = canvas.width;
  var centerx = ctx.canvas.width / 2;
  var centery = ctx.canvas.height / 2;
  ctx.fillStyle = randomGradient(canvas);
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  let grunge = document.getElementById("grungy").checked
  let numshapes = 1;//Math.random() * max_shapes() + 2;
  let ia = 0
  ctx.fillStyle = randomPick(getCurrentPalette()) // was paintcolor;
  if (grunge)
    ctx.fillStyle = randomGradient(canvas, randomPick(getCurrentPalette())) // was paintcolor)
  for (var t = 0; t < numshapes; t++) {
    let radius = 10
    x = 0;
    y = 0;
    var x0 = x;
    var y0 = y;
    let turn = 0
    angle = Math.floor(Math.random() * 6.42);
    ctx.beginPath();
    var centx = canvas.width + 260
    var centy = canvas.height/2 + pet(canvas.height/2);
    var edges = Math.random()*121+Math.random()*121;
    var maxradius = canvas.height/2 + Math.random() * canvas.height/3;
    increase = Math.PI * 2/edges;
    ctx.beginPath();
    let rfactor = 2
    let mfactor = maxradius
    for (var i = 0; i < edges-1; i++) {
      rfactor =  maxradius/40 + Math.random() *11
      if (Math.random()> 0.63)
        mfactor += (Math.random() - 0.5) * maxradius/9
      radius = Math.random() * rfactor + mfactor;
      x = radius * Math.cos(angle)+centx;
      y = radius * Math.sin(angle)+centy;
      centx = centx+pet(23)
      centy = centy+pet(23)
      if (i == 0) {
        x0 = x;
        y0 = y;
      }
      ctx.lineTo(x, y);
      ia = increase + Math.PI/180 * pet(9);
      angle += ia
      turn += ia
      if(turn >= 6.28)
        break;
    }
    ctx.lineTo(x0, y0);
    ctx.closePath();
    ctx.fill();
  }
}

function drawBezline (pts, offsetX, offsetY, fill) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let x = 0, y = 0, x0 = 0, y0 = 0
  ctx.beginPath()
  let i = 0;
  for (; i < pts.length; i++) {
    x = pts[i][0]
    y = pts[i][1]
    if (i == 0) {
      x0 = x;
      y0 = y;
      ctx.moveTo(x, y);
    } else
    if (i % 3 == 0)
      ctx.bezierCurveTo(pts[i-2][0], pts[i-2][1], pts[i-1][0], pts[i-1][1], pts[i][0], pts[i][1]);
  }
  if (fill) {
    ctx.closePath()
    ctx.fill()
  } else
    ctx.stroke();
}

function drawLines (pts, offsetX, offsetY, fill) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let x = 0, y = 0, x0 = 0, y0 = 0
  ctx.beginPath()
  let i = 0;
  for (; i < pts.length; i++) {
    x = pts[i][0]
    y = pts[i][1]
    if (i == 0) {
      x0 = x;
      y0 = y;
      ctx.moveTo(x, y);
    } else
      ctx.lineTo(pts[i][0], pts[i][1]);
  }
  if (fill) {
    ctx.closePath()
    ctx.fill()
  } else
    ctx.stroke();
}

function drawOutline (pts, offsetX, offsetY) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let x = 0, y = 0, x0 = 0, y0 = 0
  ctx.beginPath()
  let i = 0;
  for (; i < pts.length; i++) {
    x = pts[i][0]
    y = pts[i][1]
    if (i == 0) {
      x0 = x;
      y0 = y;
      ctx.moveTo(x, y);
    } else
    if (i % 3 == 0)
      ctx.bezierCurveTo(pts[i-2][0], pts[i-2][1], pts[i-1][0], pts[i-1][1], pts[i][0], pts[i][1]);
  }
  ctx.closePath();
  ctx.stroke();
}

function strokePath (points) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  ctx.lineWidth = 1 + document.getElementById("featuresize").value/50
  let x = 0, y = 0, x0 = 0, y0 = 0
  ctx.beginPath()
  let i = 0;
  for (; i < points.length; i++) {
    x = points[i][0];
    y = points[i][1];
    if (i === 0) {
      x0 = x;
      y0 = y;
      ctx.moveTo(x, y);
    } else
    ctx.lineTo(x,y)
  }
  ctx.stroke();
}


function drawPath (points, offsetX, offsetY, c) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  if (c)
    ctx = c
  let x = 0, y = 0, x0 = 0, y0 = 0
  ctx.beginPath()
  let i = 0;
  for (; i < points.length; i++) {
    x = points[i][0] + offsetX;
    y = points[i][1] + offsetY;
    if (i == 0) {
      x0 = x;
      y0 = y;
      ctx.moveTo(x, y);
    } else
    ctx.lineTo(x,y)
  }
  ctx.closePath();
  ctx.fill();
}

function infrared () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let cx = ctx.canvas.width/2
  let cy = ctx.canvas.height/2
  let w = canvas.width, h = canvas.height
  let maxdist = 101 + Math.random() * w/2
  maxdist = Math.pow(Math.pow(cx, 2) + Math.pow(cy, 2), 0.5)
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  let d = 1000
  let data = ctx.getImageData(0,0,canvas.width,canvas.height)
  let i = 0, x = 0, y = 0
  let len = w * h
  for (;i < len; i++) {
    x = i % w
    if (x === 0)
      y += 1
    //d = Math.random() * w
    let px = data.data.slice(i*4, i*4+4)
   // brightness = (px[0]+px[1]+px[2])/(255*3)
   // if (px[1] > (px[0] + px[2])/2.5) {
    if (px[1] > px[0] || px[1] > px[2]) {
      px[1] *= 1.2
      px[0] += px[1]*0.7
      px[2] += px[1]*0.7
      data.data.set(px, i*4)
    } else {
      px[1] *= 0.9
      px[0] *= 0.8
      px[2] *= 0.8
      data.data.set(px, i*4)
    }
  }
  ctx.putImageData(data, 0, 0);
}

function fade () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let cx = ctx.canvas.width/2
  let cy = ctx.canvas.height/2
  let w = canvas.width, h = canvas.height
  let maxdist = 101 + Math.random() * w/2
  maxdist = Math.pow(Math.pow(cx, 2) + Math.pow(cy, 2), 0.5)
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  let d = 1000
  let data = ctx.getImageData(0,0,canvas.width,canvas.height)
  let i = 0, x = 0, y = 0
  let len = w * h
  for (;i < len; i++) {
    x = i % w
    if (x === 0)
      y += 1
    d = Math.random() * w
    let px = data.data.slice(i*4, i*4+4)
    brightness = (px[0]+px[1]+px[2])/(255*3)
    if (brightness >= lowest && brightness <= highest) {
      px[3] *= d/maxdist
      data.data.set(px, i*4)
    }
  }
  ctx.putImageData(data, 0, 0);
}

function edgeDistance (x,W) {
  return ((x < W/2)? x: W-x)
}

async function contraEdges () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let w = canvas.width, h = canvas.height
  let maxdist = canvas.width
  let data = ctx.getImageData(0,0,canvas.width,canvas.height)
  let divisor = Math.floor(document.getElementById("featuresize").value/25) + 4
  //invert range of divisor [3- 25] => [25 - 3]
  divisor = 25 - divisor + 4
  let margin = w/divisor + pet(w/divisor/2)
  let i = 0, x = 0, y = 0, dx = 0, dy = 0
  let len = w * h
  for (;i < len; i++) {
    x = i % w
    if (i > 0 && i % w === 0) {
      x = 0
      y += 1
    }
    if (Math.random() > 0.25)
      margin = w/divisor + pet(w/divisor/2)
    dx = edgeDistance(x,w)
    dy = edgeDistance(y,h)
    if (x > margin && dx < margin && dx > 0) {
      dx += 10 // prevent 100% dark at very close to edge
      let px = data.data.slice(i*4, i*4+4)
      px[0] -= margin/dx * Math.random()*4
      px[1] -= margin/dx * Math.random()*4
      px[2] -= margin/dx * Math.random()*4
      data.data.set(px, i*4)
    }
    if (y > margin && dy < margin && dy > 0) {
      dy+= 10
      let px = data.data.slice(i*4, i*4+4)
      px[0] -= margin/dy * Math.random()*4
      px[1] -= margin/dy * Math.random()*4
      px[2] -= margin/dy * Math.random()*4
      data.data.set(px, i*4)
    }
    // lighten top & left
    if (x < w - margin && dx < margin && dx > 0) {
      dx += 10 // prevent 100% dark at very close to edge
      let px = data.data.slice(i*4, i*4+4)
      px[0] += margin/dx * Math.random()*4
      px[1] += margin/dx * Math.random()*4
      px[2] += margin/dx * Math.random()*4
      data.data.set(px, i*4)
    }
    if (y < h - margin && dy < margin && dy > 0) {
      dy+= 10
      let px = data.data.slice(i*4, i*4+4)
      px[0] += margin/dy * Math.random()*4
      px[1] += margin/dy * Math.random()*4
      px[2] += margin/dy * Math.random()*4
      data.data.set(px, i*4)
    }
  }
  await ctx.putImageData(data, 0, 0);
  return true
}
 
async function fadeEdges () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let w = canvas.width, h = canvas.height
  let maxdist = canvas.width
  let data = ctx.getImageData(0,0,canvas.width,canvas.height)
  let divisor = Math.floor(document.getElementById("featuresize").value/25) + 4
  //invert range of divisor [3- 25] => [25 - 3]
  divisor = 25 - divisor + 4
  let margin = w/divisor + pet(w/divisor/2)
  let i = 0, x = 0, y = 0, dx = 0, dy = 0
  let len = w * h
  for (;i < len; i++) {
    x = i % w
    if (i > 0 && i % w === 0) {
      x = 0
      y += 1
    }
   // if (Math.random() > 0.1)
    margin = w/divisor + pet(w/divisor/2)
    dx = edgeDistance(x,w)
    dy = edgeDistance(y,h)
    if (dx < margin && dx > 0) {
      dx += 10 // prevent 100% dark at very close to edge
      let px = data.data.slice(i*4, i*4+4)
      px[3] -= margin/dx * Math.random()*10
      data.data.set(px, i*4)
    }
    if (dy < margin && dy > 0) {
      dy+= 10
      let px = data.data.slice(i*4, i*4+4)
      px[3] -= margin/dy * Math.random()*10
      data.data.set(px, i*4)
    }
  }
  await ctx.putImageData(data, 0, 0);
  return true
}


async function darkenEdges () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let w = canvas.width, h = canvas.height
  let maxdist = canvas.width
  let data = ctx.getImageData(0,0,canvas.width,canvas.height)
  let divisor = Math.floor(document.getElementById("featuresize").value/25) + 4
  //invert range of divisor [3- 25] => [25 - 3]
  divisor = 25 - divisor + 4
  let margin = w/divisor + pet(w/divisor/2)
  let i = 0, x = 0, y = 0, dx = 0, dy = 0
  let cnt = 0
  let len = w * h
  for (;i < len; i++) {
    x = i % w
    if (i > 0 && i % w === 0) {
      x = 0
      y += 1
    }
    if (Math.random() > 0.25)
      margin = w/divisor + pet(w/divisor/2)
    dx = edgeDistance(x,w)
    dy = edgeDistance(y,h)
    if (dx < margin && dx > 0 || dy < margin && dy > 0) {
      //dx += 10 // prevent 100% dark at very close to edge
      let px = data.data.slice(i*4, i*4+4)
      px[0] -= margin/dx * Math.random()*4
      px[1] -= margin/dx * Math.random()*4
      px[2] -= margin/dx * Math.random()*4
      
      px[0] -= margin/dy * Math.random()*4
      px[1] -= margin/dy * Math.random()*4
      px[2] -= margin/dy * Math.random()*4
      data.data.set(px, i*4)
    }
    cnt++
  }
  await ctx.putImageData(data, 0, 0);
  return true
}

async function lightenEdges () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let w = canvas.width, h = canvas.height
  let maxdist = canvas.width
  let data = ctx.getImageData(0,0,canvas.width,canvas.height)
  let divisor = Math.floor(document.getElementById("featuresize").value/25) + 4
  //invert range of divisor [3- 25] => [25 - 3]
  divisor = 25 - divisor + 4
  let margin = w/divisor + pet(w/divisor/2)
  let i = 0, x = 0, y = 0, dx = 0, dy = 0
  let len = w * h
  for (;i < len; i++) {
    x = i % w
    if (i > 0 && i % w === 0) {
      x = 0
      y += 1
    }
    if (Math.random() > 0.25)
      margin = w/divisor + pet(w/divisor/2)
    dx = edgeDistance(x,w)
    dy = edgeDistance(y,h)
    if (dx < margin && dx > 0 || dy < margin && dy > 0) {
      dx += 10 // prevent 100% dark at very close to edge
      let px = data.data.slice(i*4, i*4+4)
      px[0] += margin/dx * Math.random()*4
      px[1] += margin/dx * Math.random()*4
      px[2] += margin/dx * Math.random()*4
      px[0] += margin/dy * Math.random()*4
      px[1] += margin/dy * Math.random()*4
      px[2] += margin/dy * Math.random()*4
      data.data.set(px, i*4)
    }
  }
  await ctx.putImageData(data, 0, 0);
  return true
}

async function yellowedEdges () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let w = canvas.width, h = canvas.height
  let maxdist = canvas.width
  let data = ctx.getImageData(0,0,canvas.width,canvas.height)
  let divisor = Math.floor(document.getElementById("featuresize").value/25) + 4
  //invert range of divisor [3- 25] => [25 - 3]
  divisor = 25 - divisor + 4
  let margin = w/divisor + pet(w/divisor/2)
  let i = 0, x = 0, y = 0, dx = 0, dy = 0
  let len = w * h
  for (;i < len; i++) {
    x = i % w
    if (i > 0 && i % w === 0) {
      x = 0
      y += 1
    }
    if (Math.random() > 0.25)
      margin = w/divisor + pet(w/divisor/2)
    dx = edgeDistance(x,w)
    dy = edgeDistance(y,h)
    if (dx < margin && dx > 0) {
      dx += 10 // prevent 100% dark at very close to edge
      let px = data.data.slice(i*4, i*4+4)
      px[0] -= margin/dx * Math.random()*3
      px[1] -= margin/dx * Math.random()*4
      px[2] -= margin/dx * Math.random()*6
      data.data.set(px, i*4)
    }
    if (dy < margin && dy > 0) {
      dy+= 10
      let px = data.data.slice(i*4, i*4+4)
      px[0] -= margin/dy * Math.random()*3
      px[1] -= margin/dy * Math.random()*4
      px[2] -= margin/dy * Math.random()*6
      data.data.set(px, i*4)
    }
  }
  await ctx.putImageData(data, 0, 0);
  return true
}

async function fr () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  if (LASTCLICK[0] > canvas.width)
    LASTCLICK[0] = canvas.width/2
  let touch = Math.floor(LASTCLICK[0]) //- canvas.height/5000*spread
  let w = canvas.width, h = canvas.height
  let maxdist = canvas.width - touch
  let d = 0
  let data = ctx.getImageData(0,0,canvas.width,canvas.height)
  let i = 0, x = 0, y = 0
  let len = w * h
  for (;i < len; i++) {
    x = i % w
    if (i > 0 && i % w === 0) {
      x = 0
      y += 1
    }
    if (x > touch) {
      d = (x-touch)
      let px = data.data.slice(i*4, i*4+4)
      px[3] -= px[3] * d/maxdist
      data.data.set(px, i*4)
    }
  }
  await ctx.putImageData(data, 0, 0);
  return true
}

async function fd () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  if (LASTCLICK[1] > canvas.height)
    LASTCLICK[1] = canvas.height/2
  let touch = Math.floor(LASTCLICK[1]) //- canvas.height/5000*spread
  let w = canvas.width, h = canvas.height
  let maxdist = canvas.height - touch
  let d = 0
  let data = ctx.getImageData(0,0,canvas.width,canvas.height)
  let i = 0, x = 0, y = 0
  let len = w * h
  for (;i < len; i++) {
    x = i % w
    if (i > 0 && i % w === 0) {
      x = 0
      y += 1
    }
    if (y > touch) {
      d = (y-touch)
      let px = data.data.slice(i*4, i*4+4)
      px[3] -= px[3] * d/maxdist
      data.data.set(px, i*4)
    }
  }
  await ctx.putImageData(data, 0, 0);
  return true
}

async function fadeDown () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  if (LASTCLICK[1] > canvas.height)
    LASTCLICK[1] = canvas.height/2
  let spread = Math.floor(1 + document.getElementById("number").value/2000)
  // tie spread to canvas.height?
  let touchy = LASTCLICK[1] //- canvas.height/5000*spread
  let w = canvas.width, h = canvas.height
  let maxdist = touchy
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  let d = 1000, brightness = 0
  let data = ctx.getImageData(0,0,canvas.width,canvas.height)
  let i = 0, x = 0, y = 0
  let len = w * h
  let dmin = 1000, dmax = 0
  for (;i < len; i++) {
    y = i % w
    if (y === 0)
      x += 1
    d = (touchy - x)
    if (x > touchy)
      d = 0
    let px = data.data.slice(i*4, i*4+4)
    brightness = (px[0]+px[1]+px[2])/(255*3)
    if (brightness >= lowest && brightness <= highest) {
      px[3] *= d/maxdist
      data.data.set(px, i*4)
    }
  }
  await ctx.putImageData(data, 0, 0);
  return true
}

function downFade () {
  rc()
  leftFade()
  rcc()
}


function leftFade () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let cx = LASTCLICK[0]//ctx.canvas.width/2 + pet(150)
  transparenter(0,0,cx,canvas.height)
}

function pop () {
  saturationScale(1.5)
  contrastImage(15)
  //sharpenCanvas()
}

function pale () {
  saturationScale(0.75)
  contrastImage(-15)
  //sharpenCanvas()
}

function edgeGrey () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let ocanvas = document.createElement("CANVAS")
  let octx = ocanvas.getContext('2d')
  ocanvas.width = canvas.width
  ocanvas.height = canvas.height
  octx.drawImage(canvas,0,0)
  greyScale(ocanvas)
  vig(ocanvas)
  ctx.drawImage(ocanvas,0,0)
}

function edgeDarken () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let ocanvas = document.createElement("CANVAS")
  let octx = ocanvas.getContext('2d')
  ocanvas.width = canvas.width
  ocanvas.height = canvas.height
  octx.drawImage(canvas,0,0)
  adjustBrightness(-30, ocanvas, false)
  vig(ocanvas)
  ctx.drawImage(ocanvas,0,0)
}

function edgeLighten () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let ocanvas = document.createElement("CANVAS")
  let octx = ocanvas.getContext('2d')
  ocanvas.width = canvas.width
  ocanvas.height = canvas.height
  octx.drawImage(canvas,0,0)
  adjustBrightness(30, ocanvas, false)
  vig(ocanvas)
  ctx.drawImage(ocanvas,0,0)
}

function edgeBlur () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let ocanvas = document.createElement("CANVAS")
  let octx = ocanvas.getContext('2d')
  ocanvas.width = canvas.width
  ocanvas.height = canvas.height
  octx.drawImage(canvas,0,0)
  smearrandom(ocanvas)
  vig(ocanvas)
  ctx.drawImage(ocanvas,0,0)
}

// distace of (x,y) to closest edge
function frameDistance (x, y, w, h) {
  let w2 = w/2, h2 = h/2
  let d1 = (x < w2)? x: w-x;
  let d2 = (y < h2)? y: h-y;
  return Math.min(d1,d2)
}

function fadeCenter() {
  vig(null, true)
}

function vig_rect (canvas, FADE) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let cx = ctx.canvas.width/2 + pet(150)
  let cy = ctx.canvas.height/2 + pet(150)
  cx = LASTCLICK[0]
  cy = LASTCLICK[1]
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  let s = 2+document.getElementById("featuresize").value/5 // up to 500
  let s5 = s/7
  // decrease d as s increases?
  let w = canvas.width, h = canvas.height
  let w_wide = w * 0.6
  let weight = 0
  
  let maxdist = frameDistance(cx,cy,w,h)//Math.pow(Math.pow(cx, 2) + Math.pow(cy, 2), 0.5)
 // maxdist *= 1.2
  let d = 1000, brightness = 0
  let data = ctx.getImageData(0,0,canvas.width,canvas.height)
  let i = 0, x = 0, y = 0
  let len = w * h
  for (;i < len; i++) {
    x = i % w
    if (x === 0)
      y += 1
    d = frameDistance(x, y, w, h)
    let px = data.data.slice(i*4, i*4+4)
    brightness = (px[0]+px[1]+px[2])/(255*3)
    if (brightness >= lowest && brightness <= highest) {
      
      if (FADE && d + pet(s/2) < s) {
        px[3] *= 0.5//maxdist/d
        data.data.set(px, i*4)
      } else
      if (d + pet(s*5) > s) {
        px[3] *= 0.0//maxdist/d
        data.data.set(px, i*4)
      }
    }
  }
  ctx.putImageData(data, 0, 0);
  //vig_OG (canvas, FADE)
}


function vig (canvas, FADE) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let cx = ctx.canvas.width/2 + pet(150)
  let cy = ctx.canvas.height/2 + pet(150)
  cx = LASTCLICK[0]
  cy = LASTCLICK[1]
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  let s = 25+document.getElementById("featuresize").value // up to 500
  let s5 = s/10
  // decrease d as s increases?
  let w = canvas.width, h = canvas.height
  let weight = 0.33
  let maxdist = Math.min(w,h)/2
  maxdist *= 1.2
  let w_wide = maxdist * 0.9
  let d = 1000, brightness = 0
  let data = ctx.getImageData(0,0,canvas.width,canvas.height)
  let i = 0, x = 0, y = 0
  let len = w * h
  for (;i < len; i++) {
    x = i % w
    if (x === 0)
      y += 1
    d = distance(x, y, cx+pet(29), cy+pet(29), w, h)
    let px = data.data.slice(i*4, i*4+4)
    brightness = (px[0]+px[1]+px[2])/(255*3)
    if (brightness >= lowest && brightness <= highest) {
      if (!FADE && d < w_wide + pet(s5)) {
        px[3] *= weight
        data.data.set(px, i*4)
      } else
      if (FADE) {
        px[3] *= d/maxdist
        data.data.set(px, i*4)
      }
    }
  }
  ctx.putImageData(data, 0, 0);
}

function pasteFromOff () {
  let OC = document.getElementById('OC')
  if (OC && OC.width > 0) {
    let canvas = document.getElementById('myCanvas')
    let ctx = canvas.getContext('2d')
    let OCctx = OC.getContext('2d')
    OCctx.globalCompositeOperation = document.getElementById("mode").value
    ctx.globalCompositeOperation = document.getElementById("mode").value
    OCctx.globalAlpha = ctx.globalAlpha//document.getElementById("opacity").value/100
    ctx.drawImage(OC, 0, 0)
    return true
  }
  return true
}

function smearrandom (c, d) {
  if (c)
    canvas = c
  else
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let off = document.createElement('CANVAS')
  let offctx = off.getContext("2d")
  off.width = canvas.width
  off.height = canvas.height
  offctx.drawImage(canvas, 0, 0)
  let jump = 1 + document.getElementById("featuresize").value/2
  let jump2 = jump
  if (d) {
    jump = d[0]
    jump2 = d[1]
  }
  ctx.globalAlpha = (document.getElementById("opacity").value)/400
  let i = 0
  let n = 2
  ctx.save()
  for (; i < n; i++) {
    if (Math.random() > 0.5)
      jump2 *= -1
    if (Math.random() > 0.5)
      jump *= -1
    ctx.drawImage(off, jump/2 + pet(jump/2),  jump2/2 + pet(jump2/2))
  }
  ctx.restore()
}

function smearrandomoc () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let off = document.getElementById('OC')
  if (off && off.width > 0) {
    let x = off.width/2
    let y = off.height/2
    let angle = 2
    let offctx = off.getContext("2d")
    let c = canvas.width/3
    let jump = 1 + document.getElementById("featuresize").value/2
    let jump2 = jump
    ctx.globalAlpha = (document.getElementById("opacity").value)/400
    let i = 0
    let n = 2
    ctx.save()
    for (; i < n; i++) {
      if (Math.random() > 0.5)
        jump2 *= -1
      if (Math.random() > 0.5)
        jump *= -1
      ctx.drawImage(off, jump/2 + pet(jump/2),  jump2/2 + pet(jump2/2))
    }
    ctx.restore()
  }
}

function smearzoom () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let off = document.createElement('CANVAS')
  off.height = canvas.height*1.05
  off.width = canvas.width*1.05
  let x = LASTCLICK[0]//off.width/2
  let y = LASTCLICK[1]//off.height/2
  let xoffset = (canvas.width - off.width)/2
  let yoffset = (canvas.height - off.height)/2
  xoffset += (canvas.width/2 - x)/2
  yoffset += (canvas.height/2 - y)/2
  let angle = 2
  offctx = off.getContext("2d")
  offctx.drawImage(canvas, xoffset, yoffset, off.width, off.height)
  let c = canvas.width/3
  let jump = 1 + document.getElementById("featuresize").value/10
  let jump2 = jump
  ctx.globalAlpha = (document.getElementById("opacity").value)/200
  let i = 0
  let n = 2 //+ Math.random() * 17
  ctx.save()
  for (; i < n; i++) {
    if (Math.random() > 0.5)
      jump2 *= -1
    if (Math.random() > 0.5)
      jump *= -1
    ctx.drawImage(off, jump/2 + pet(jump/2),  jump2/2 + pet(jump2/2))
  }
  ctx.restore()
}

function smeardown2 () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let off = document.createElement('CANVAS')
  off.height = canvas.height
  off.width = canvas.width
  offctx = off.getContext("2d")
  offctx.drawImage(canvas, 0, 0)
  let jump = 1 + document.getElementById("featuresize").value/5
  ctx.globalAlpha = (document.getElementById("opacity").value)/200
  let i = 0
  let n = 2
  for (; i < n; i++) {
    ctx.drawImage(off, 0, -jump/2 + pet(jump/2))
    jump += pet(33)
  }
  return true
}

function smearside () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let alpha = document.getElementById("opacity").value
  let off = document.createElement('CANVAS')
  off.height = canvas.height
  off.width = canvas.width
  offctx = off.getContext("2d")
  offctx.drawImage(canvas, 0, 0)
  let jump = 1 + document.getElementById("featuresize").value/5
  let i = 0
  let n = 2
  ctx.save()
  ctx.globalAlpha = (document.getElementById("opacity").value)/200
  for (; i < n; i++) {
    ctx.drawImage(off, jump/2 + pet(jump/2), 0)
  }
  ctx.restore()
  ctx.globalAlpha = alpha/100

}

function smeardown () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let c = canvas.width/3
  ctx.globalAlpha = (document.getElementById("opacity").value)/400
  let i = 0
  let n = 5 + Math.random() * 17
  ctx.save()
  for (; i < n; i++) {
    ctx.translate(c+pet(3), c+3+pet(3))
    ctx.translate(-c, -c);
    ctx.drawImage(ctx.canvas, 0, 0)
  }
  ctx.restore()
}

function smear (micro) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let c = canvas.width/2
  ctx.globalAlpha = (document.getElementById("opacity").value)/100
  let i = 0
  let m = 7
  if (micro)
    m = 2
  let p = 20, rotation = 0.01
  
  ctx.save()
  for (; i < 5; i++) {
    ctx.translate(c+pet(m), c+pet(m));
    ctx.translate(-c+pet(m), -c+pet(m));
    ctx.drawImage(ctx.canvas, pet(p), pet(p))
  }
  ctx.restore()
}

function edgeSmear (small) {
  let ocanvas = document.createElement("CANVAS")
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let numshapes = 2 + Math.log(document.getElementById("number").value)/2
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let cx = canvas.height/2, cy = canvas.width/2
  ocanvas.height = (canvas.height > canvas.width)? canvas.height: canvas.width
  ocanvas.width = (canvas.height > canvas.width)? canvas.height: canvas.width
  ocanvas.height += 50
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  
  octx.fillStyle = randomGradient(ocanvas, randomPick(getCurrentPalette())) // was paintcolor)
  octx.globalAlpha = 1//(document.getElementById("opacity").value)/100
  let c = ocanvas.height * 0.5
  let x = 1//canvas.width/100 * Math.random()
  let y = 21
  let r = 17
  let i = 0
  let p = 61
  if (document.getElementById("grungy").checked)
    p *= 3
  if (small) {
    p = canvas.width/200
    r /= 2
  }
  for (; i < numshapes; i++) {
    octx.fillStyle = randomGradient(ocanvas, randomPick(getCurrentPalette())) // was paintcolor)
    octx.globalAlpha = Math.random()
    let xo = x+pet(p)
    drawBlobAt (octx, xo/2, y, r+pet(2))
  }
  i = 0
  let N = (Math.log(canvas.height+1) * 11.3) - 46

  for (; i < N; i++) {
    octx.globalAlpha = Math.random()
    let co = c+3+pet(1)
    octx.translate(c, co)
    octx.translate(-c, -c)
    octx.drawImage(octx.canvas, 0, 0)
  }
  ctx.drawImage(ocanvas, -5, 0)
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
}

function smeardownOff () {
  let ocanvas = document.createElement("CANVAS")
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let numshapes = 2 + Math.log(document.getElementById("number").value)/2
  ctx.globalAlpha = document.getElementById("opacity").value/100
  let cx = canvas.height/2, cy = canvas.width/2
  ocanvas.height = (canvas.height > canvas.width)? canvas.height: canvas.width
  ocanvas.width = (canvas.height > canvas.width)? canvas.height: canvas.width
  ocanvas.height += 50
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
  let c = ocanvas.height * 0.5
  octx.fillStyle = randomGradient(ocanvas, randomPick(getCurrentPalette())) // was paintcolor)
  octx.globalAlpha = (document.getElementById("opacity").value)/100
  let x = canvas.width * Math.random()
  let y = 4
  let r = 17
  let i = 0
  let p = 61
  if (document.getElementById("grungy").checked)
    p *= 3
  for (; i < numshapes; i++) {
    octx.fillStyle = randomGradient(ocanvas, randomPick(getCurrentPalette())) // was paintcolor)
    octx.globalAlpha = Math.random()
    drawBlobAt (octx, x+pet(p), y+pet(p), r+pet(17))
  }
  i = 0
  let N = (Math.log(canvas.height+1) * 11.3) - 46
  for (; i < N; i++) {
    octx.globalAlpha = Math.random()
    octx.translate(c, c+3+pet(1))
    octx.translate(-c, -c)
    octx.drawImage(octx.canvas, 0, 0)
  }
  ctx.drawImage(ocanvas, 0, -50)
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
}

function smearsideways () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let c = canvas.height/2
  ctx.globalAlpha = (document.getElementById("opacity").value)/400
  let i = 0
  let p = 5
  if (document.getElementById("grungy").checked) {
    p = 11
  }
  ctx.save()
  for (; i < 33; i++) {
    ctx.translate(c+3+pet(1), c+pet(1))
    ctx.rotate(0 * Math.PI);
    ctx.translate(-c, -c);
    ctx.drawImage(ctx.canvas,3, pet(p))
  }
  ctx.restore()
}

function refreshMode () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let selectElement = document.getElementById("mode");
  ctx.globalCompositeOperation = selectElement.value
  return true
}

function syncBackground (canvas) {
  let bkg = document.getElementById("background");
  bkg.style.height = canvas.height +"px"
  bkg.style.width = canvas.width +"px"
 // displayRatio()
  //syncMarker()
}

function resizeCanvas () {
  let canvas_size = 1080//256 * document.getElementById("canvas_size").value
  let ocanvas = document.getElementById('off')
  let octx = ocanvas.getContext('2d')
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d")
  let mode = ctx.globalCompositeOperation
  let a = ctx.globalAlpha
  ctx.globalAlpha = 1.0
  ocanvas.height = canvas.height
  ocanvas.width = canvas.width
  //ctx.imageSmoothingEnabled = false
  octx.drawImage(canvas, 0, 0)
  canvas.height = canvas_size
  canvas.width = canvas_size
  
  let selection = document.getElementById("canvassizes").value
  if (selection == "portrait") {
    canvas.width = 1080
    canvas.height = 1350
  } else
  if (selection == "landscape") {
    canvas.width = 1080
    canvas.height = 608
  } else
  if (selection == "1:0.75") {
    canvas.width = 2224
    canvas.height = 1667
  }

  document.getElementById("canvassizes").setAttribute('title', "W:"+canvas.width+" H:"+canvas.height)
  syncBackground(canvas)
 // document.getElementById("canvaswidth").value = canvas.width
 // document.getElementById("canvasheight").value = canvas.height
 // ctx.imageSmoothingEnabled = false
  syncBackground(canvas)
  ctx.drawImage(ocanvas,0,0,canvas.width,canvas.height)
  octx.clearRect(0,0,ocanvas.width,ocanvas.height)
 // document.getElementById("canvaswidth").value = canvas.width
 // document.getElementById("canvasheight").value = canvas.height
  ctx.globalCompositeOperation = mode
  //syncMarker()
  //displayRatio()
  showTip ("WxH: "+canvas.width+" x "+canvas.height, "marker")
}


function stack_drawD () {
  drawD()
  pushFunction('drawD', 0)
}

function stack_fill () {
  fill()
  pushFunction('fill', 0)
}

function stack_clearCanvas () {
  clearCanvas()
  pushFunction('clearCanvas', 0)
}

function clearCanvas () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width, canvas.height)
}

function saveAs () {
  document.getElementById("downloader").download = "image.png";
  document.getElementById("downloader").href = document.getElementById("myCanvas").toDataURL("image/png").replace(/^data:image\/[^;]/, 'data:application/octet-stream');
}

function inBounds(x,y,minx,miny,maxx,maxy) {
  return (x >= minx && x <= maxx && y >= miny && y <= maxy)
}

function pet (v) {
  return (Math.random() -0.5) * v;
}

function distance (x1, y1, x2, y2) {
  return Math.pow(Math.pow(x1-x2, 2) + Math.pow(y1-y2, 2), 0.5)
}

function lindistance (x1,x2) {
  return Math.abs(x1,x2)
}

function updateDist () {
  let d = document.getElementById("distribution").value
  let el = document.getElementById("dist")
  if (d == 0)
    el.innerHTML = "gaussian"
  else
    el.innerHTML = "square"
}

function transparenter (x,y,w,h) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let imageData = null
  if (!w)
    imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  else {
    imgData = ctx.getImageData(x,y,w,h);
  }
  let pixels = imgData.data;
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  let i = 0, brightness = 0
  for (; i < pixels.length; i += 4) {
    brightness = (pixels[i]+pixels[i+1]+pixels[i+2])/(255*3)
    if (brightness >= lowest && brightness <= highest) {
      pixels[i + 3] *= 0.9;
    }
  }
  ctx.putImageData(imgData, 0, 0);
}

function opaqueer () {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let pixels = imgData.data;
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  let i = 0
  for (; i < pixels.length; i += 4) {
    brightness = (pixels[i]+pixels[i+1]+pixels[i+2])/(255*3)
    if (brightness >= lowest && brightness <= highest) {
      pixels[i + 3] *= 1.1;
    }
  }
  ctx.putImageData(imgData, 0, 0);
}

function decolorSky () {
  let sv = 0.9
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let touch = LASTCLICK[1], x = 0, y = 0, w = canvas.width*4
  let dA = imageData.data; // raw pixel data in array
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  let brightness = 0
  //var sv = 1.25; // saturation value. 0 = grayscale, 1 = original
  var luR = 0.3086; // constant to determine luminance of red. Similarly, for green and blue
  var luG = 0.6094;
  var luB = 0.0820;
  var az = (1 - sv)*luR + sv;
  var bz = (1 - sv)*luG;
  var cz = (1 - sv)*luB;
  var dz = (1 - sv)*luR;
  var ez = (1 - sv)*luG + sv;
  var fz = (1 - sv)*luB;
  var gz = (1 - sv)*luR;
  var hz = (1 - sv)*luG;
  var iz = (1 - sv)*luB + sv;
  let i = 0
  for(; i < dA.length; i += 4) {
    x = i % w
    if (i > 0 && i % w === 0) {
      x = 0
      y += 1
    }
    if (y < touch - (Math.random() * 70)) {
      var red = dA[i]; // Extract original red color [0 to 255]. Similarly for green and blue below
      var green = dA[i + 1];
      var blue = dA[i + 2];
      brightness = (dA[i]+dA[i+1]+dA[i+2])/(255*3)
      if (brightness >= lowest && brightness <= highest) {
        var saturatedRed = (az*red + bz*green + cz*blue);
        var saturatedGreen = (dz*red + ez*green + fz*blue);
        var saturateddBlue = (gz*red + hz*green + iz*blue);
        dA[i] = saturatedRed;
        dA[i + 1] = saturatedGreen;
        dA[i + 2] = saturateddBlue;
      }
    }
  }
  ctx.putImageData(imageData, 0, 0);
}

function tintSky (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  let offcanvas = document.createElement('CANVAS')
  offcanvas.width = canvas.width
  offcanvas.height = canvas.height
  let offctx = offcanvas.getContext("2d");
  let touch = LASTCLICK[1], x = 0, y = 0, w = canvas.width*4
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let r = hexToR(color)
  let g = hexToG(color)
  let b = hexToB(color)
  let ctx = canvas.getContext("2d");
  ctx.willReadFrequently = true
  let mode = ctx.globalCompositeOperation
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let pixels = imgData.data;
  let i = 0
  let brightness = 0
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  for (; i < pixels.length; i += 4) {
    x = i % w
    if (i > 0 && i % w === 0) {
      x = 0
      y += 1
    }
    if (y < touch - (Math.random() * 70)) {
      brightness = (pixels[i]+pixels[i+1]+pixels[i+2])/(255*3)
      if (brightness >= lowest && brightness <= highest) {
        pixels[i] =     Math.min(pixels[i] * 0.9 + r * 0.1, 255);
        pixels[i + 1] = Math.min(pixels[i+1] * 0.9+ g * 0.1, 255);
        pixels[i + 2] = Math.min(pixels[i+2] * 0.9 + b * 0.1, 255);
      }
    }
  }
  offctx.putImageData(imgData, 0, 0);
  ctx.globalCompositeOperation = "color"
  ctx.drawImage(offcanvas,0,0)
  ctx.globalCompositeOperation = mode
}
/*
function edgeDistance (x,y,W,H) {
  let dx = (x < W/2)? x: W-x;
  let dy = (y < H/2)? y: H-y
  return Math.min(dx,dy)
}*/

function darkenSky (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let n = -5
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  let brightness = 0
  let touch = LASTCLICK[1], x = 0, y = 0
  let ctx = canvas.getContext("2d");
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let pixels = imgData.data;
  let i = 0, w = canvas.width*4
  for (; i < pixels.length; i += 4) {
    x = i % w
    if (i > 0 && i % w === 0) {
      x = 0
      y += 1
    }
    if (y < touch - (Math.random() * 70)) {
      brightness = (pixels[i]+pixels[i+1]+pixels[i+2])/(255*3)
      if (brightness >= lowest && brightness <= highest) {
        pixels[i] += n;
        pixels[i + 1] += n;
        pixels[i + 2] += n;
      }
    }
  }
  ctx.putImageData(imgData, 0, 0, 0,0,canvas.width,y);
}
    
function increaseGrain (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let n = document.getElementById("number").value/200
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  let brightness = 0
  let ctx = canvas.getContext("2d");
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let pixels = imgData.data;
  let flip = 0.5
  if (document.getElementById("grungy").checked)
    flip = 0.87
  
  let i = 0
  for (; i < pixels.length; i += 4) {
    if (Math.random() > 0.5) {
    brightness = (pixels[i]+pixels[i+1]+pixels[i+2])/(255*3)
    if (brightness >= lowest && brightness <= highest) {
      pixels[i] += n;
      pixels[i + 1] += n;
      pixels[i + 2] += n;
      if (Math.random() > flip)
        n *= -1
    }
  }
  }
  ctx.putImageData(imgData, 0, 0);
}

function adjustBrightness (n, canvas, PUSH) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  let brightness = 0
  let ctx = canvas.getContext("2d");
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let pixels = imgData.data;
  let i = 0
  for (; i < pixels.length; i += 4) {
    brightness = (pixels[i]+pixels[i+1]+pixels[i+2])/(255*3)
    if (brightness >= lowest && brightness <= highest) {
      pixels[i] += n;
      pixels[i + 1] += n;
      pixels[i + 2] += n;
    }
  }
  ctx.putImageData(imgData, 0, 0);
  if (PUSH)
    pushFunction("adjustBrightness", n, canvas)
}

function rotateBrightness (canvas, n) {
  if (!n)
    n = 16
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  let brightness = 0
  let ctx = canvas.getContext("2d");
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let pixels = imgData.data;
  let i = 0
  for (; i < pixels.length; i += 4) {
    brightness = (pixels[i]+pixels[i+1]+pixels[i+2])/(255*3)
    if (brightness >= lowest && brightness <= highest) {
      pixels[i] = (pixels[i] + n) % 256;
      pixels[i + 1] = (pixels[i+1] + n) % 256;
      pixels[i + 2] = (pixels[i+2] + n) % 256;
    }
  }
   ctx.putImageData(imgData, 0, 0);
  return true
}

async function randomizeColors (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d");
  let n1 = Math.floor(Math.random() * 256)
  let n2 = Math.floor(Math.random() * 256)
  let n3 = Math.floor(Math.random() * 256)
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  let brightness = 0
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let pixels = imgData.data;
  let i = 0
  for (; i < pixels.length; i += 4) {
    brightness = (pixels[i]+pixels[i+1]+pixels[i+2])/(255*3)
    if (brightness >= lowest && brightness <= highest) {
      pixels[i] =     (pixels[i] + n1) % 256;
      pixels[i + 1] = (pixels[i+1] + n2) % 256;
      pixels[i + 2] = (pixels[i+2] + n3) % 256;
    }
  }
  await ctx.putImageData(imgData, 0, 0);
  return true
}

async function rotateColors (canvas, D) {
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d");
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let pixels = imgData.data;
  let i = 0
  for (; i < pixels.length; i += 4) {
    pixels[i] =     (pixels[i] + D) % 256;
    pixels[i + 1] = (pixels[i+1] + D) % 256;
    pixels[i + 2] = (pixels[i+2] + D) % 256;
  }
  await ctx.putImageData(imgData, 0, 0);
  return true
}

function tint (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  let offcanvas = document.createElement('CANVAS')
  offcanvas.width = canvas.width
  offcanvas.height = canvas.height
  let offctx = offcanvas.getContext("2d");
  offctx.willReadFrequently = true
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alpha = document.getElementById("opacity").value
  let r = hexToR(color)
  let g = hexToG(color)
  let b = hexToB(color)
  let ctx = canvas.getContext("2d");
  ctx.willReadFrequently = true
  let mode = ctx.globalCompositeOperation
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let pixels = imgData.data;
  let i = 0
  let brightness = 0, ct = 0
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  i = 0
  for (; i < pixels.length; i += 4) {
    brightness = (pixels[i]+pixels[i+1]+pixels[i+2])/(255*3)
    if (brightness >= lowest && brightness <= highest) {
      pixels[i] =     Math.min(pixels[i] * 0.7 + r * 0.3, 255);
      pixels[i + 1] = Math.min(pixels[i+1] * 0.7 + g * 0.3, 255);
      pixels[i + 2] = Math.min(pixels[i+2] * 0.7 + b * 0.3, 255);
    }
    ct++
  }
  offctx.putImageData(imgData, 0, 0);
  //ctx.globalCompositeOperation = "color"
 // ctx.clearRect(0,0,canvas.width,canvas.height)
 // ctx.globalAlpha = 1
  ctx.drawImage(offcanvas,0,0)
  ctx.globalCompositeOperation = mode
  ctx.globalAlpha = alpha/100
}

function tintlow (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  let offcanvas = document.createElement('CANVAS')
  offcanvas.width = canvas.width
  offcanvas.height = canvas.height
  let offctx = offcanvas.getContext("2d");
  offctx.willReadFrequently = true
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alpha = document.getElementById("opacity").value
  let r = hexToR(color)
  let g = hexToG(color)
  let b = hexToB(color)
  let ctx = canvas.getContext("2d");
  ctx.willReadFrequently = true
  let mode = ctx.globalCompositeOperation
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let pixels = imgData.data;
  let i = 0
  let brightness = 0, ct = 0
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  i = 0
  for (; i < pixels.length; i += 4) {
    brightness = (pixels[i]+pixels[i+1]+pixels[i+2])/(255*3)
    let L = (-brightness + 1)/3
    pixels[i] =     Math.min(pixels[i] * 0.7 + r * L, 255);
    pixels[i + 1] = Math.min(pixels[i+1] * 0.7 + g * L, 255);
    pixels[i + 2] = Math.min(pixels[i+2] * 0.7 + b * L, 255);
    ct++
  }
  offctx.putImageData(imgData, 0, 0);
  //ctx.globalCompositeOperation = "color"
 // ctx.clearRect(0,0,canvas.width,canvas.height)
 // ctx.globalAlpha = 1
  ctx.drawImage(offcanvas,0,0)
  ctx.globalCompositeOperation = mode
  ctx.globalAlpha = alpha/100
}

function tinthigh (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  let offcanvas = document.createElement('CANVAS')
  offcanvas.width = canvas.width
  offcanvas.height = canvas.height
  let offctx = offcanvas.getContext("2d");
  offctx.willReadFrequently = true
  let color = randomPick(getCurrentPalette()) // was paintcolor
  let alpha = document.getElementById("opacity").value
  let r = hexToR(color)
  let g = hexToG(color)
  let b = hexToB(color)
  let ctx = canvas.getContext("2d");
  ctx.willReadFrequently = true
  let mode = ctx.globalCompositeOperation
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let pixels = imgData.data;
  let i = 0
  let brightness = 0, ct = 0
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  i = 0
  for (; i < pixels.length; i += 4) {
    brightness = (pixels[i]+pixels[i+1]+pixels[i+2])/(255*3)
    let L = (brightness)/3
    pixels[i] =     Math.min(pixels[i] * 0.7 + r * L, 255);
    pixels[i + 1] = Math.min(pixels[i+1] * 0.7 + g * L, 255);
    pixels[i + 2] = Math.min(pixels[i+2] * 0.7 + b * L, 255);
    ct++
  }
  offctx.putImageData(imgData, 0, 0);
  //ctx.globalCompositeOperation = "color"
 // ctx.clearRect(0,0,canvas.width,canvas.height)
//  ctx.globalAlpha = 1
  ctx.drawImage(offcanvas,0,0)
  ctx.globalCompositeOperation = mode
  ctx.globalAlpha = alpha/100
}

function adjustWarmth (n, canvas, PUSH) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let g = n/2
  let ctx = canvas.getContext("2d");
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let pixels = imgData.data;
  let i = 0
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  let brightness = 0
  
  for (; i < pixels.length; i += 4) {
    brightness = (pixels[i]+pixels[i+1]+pixels[i+2])/(255*3)
    if (brightness >= lowest && brightness <= highest) {
      pixels[i] += n;
     // pixels[i + 1] += g;
      pixels[i + 2] -= n;
    }
  }
  ctx.putImageData(imgData, 0, 0)
  if (PUSH)
    pushFunction("adjustWarmth", n)
}

function saturationScale (sv, canvas, PUSH) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let dA = imageData.data; // raw pixel data in array
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  let brightness = 0
  //var sv = 1.25; // saturation value. 0 = grayscale, 1 = original
  var luR = 0.3086; // constant to determine luminance of red. Similarly, for green and blue
  var luG = 0.6094;
  var luB = 0.0820;
  var az = (1 - sv)*luR + sv;
  var bz = (1 - sv)*luG;
  var cz = (1 - sv)*luB;
  var dz = (1 - sv)*luR;
  var ez = (1 - sv)*luG + sv;
  var fz = (1 - sv)*luB;
  var gz = (1 - sv)*luR;
  var hz = (1 - sv)*luG;
  var iz = (1 - sv)*luB + sv;
  let i = 0
  for(; i < dA.length; i += 4) {
      var red = dA[i]; // Extract original red color [0 to 255]. Similarly for green and blue below
      var green = dA[i + 1];
      var blue = dA[i + 2];
      brightness = (dA[i]+dA[i+1]+dA[i+2])/(255*3)
    if (brightness >= lowest && brightness <= highest) {
        var saturatedRed = (az*red + bz*green + cz*blue);
        var saturatedGreen = (dz*red + ez*green + fz*blue);
        var saturateddBlue = (gz*red + hz*green + iz*blue);
        dA[i] = saturatedRed;
        dA[i + 1] = saturatedGreen;
        dA[i + 2] = saturateddBlue;
    }
  }
  ctx.putImageData(imageData, 0, 0)
  if (PUSH)
    pushFunction("saturationScale", sv)
}

function rgb_lrgb1(v) {
  return (v /= 255) <= 0.04045 ? v / 12.92 : ((v + 0.055) / 1.055) ** 2.4;
}

function lrgb_rgb1(v) {
  return (v <= 0.0031308 ? 12.92 * v : 1.055 * (v ** (1 / 2.4)) - 0.055) * 255;
}

function gray (r, g, b) {
  const kr = 0.2126
  const kg = 0.7152
  const kb = 0.0722
  return lrgb_rgb1(kr * rgb_lrgb1(r) + kg * rgb_lrgb1(g) + kb * rgb_lrgb1(b));
}

function greyScale (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
  let pixels = imgData.data;
  let lh = rangecheck()
  let lowest = lh[0], highest = lh[1]
  let i = 0, brightness = 0
  for (; i < pixels.length; i += 4) {
    let lightness = parseInt((pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3);
    brightness = (pixels[i]+pixels[i+1]+pixels[i+2])/(255*3)
    if (brightness >= lowest && brightness <= highest) {
      pixels[i] = lightness;
      pixels[i + 1] = lightness;
      pixels[i + 2] = lightness;
    }
  }
  ctx.putImageData(imgData, 0, 0);
}

function greyScaleSpot (x,y,w,h) {
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let imgData = ctx.getImageData(x, y, w, h);
  let pixels = imgData.data;
  let i = 0
  for (; i < pixels.length; i += 4) {
    let lightness = parseInt((pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3);
    pixels[i] = lightness;
    pixels[i + 1] = lightness;
    pixels[i + 2] = lightness;
  }
  ctx.putImageData(imgData, x,y);
}

function lum () {
  let c = randomPick(getCurrentPalette()) // was paintcolor
  let r = hexToR(c) / 255
  let g = hexToG(c) / 255
  let b = hexToB(c) / 255

  // Find greatest and smallest channel values
  let cmin = Math.min(r,g,b),
      cmax = Math.max(r,g,b),
      delta = cmax - cmin,
      h = 0,
      s = 0,
      l = 0;
  return ((cmax + cmin) / 2)
}

function threshold_soft () {
  //let threshold = lum() * 255
  let threshold = document.getElementById("opacity").value *2.55
  let low = threshold - threshold/2
  let high = threshold + threshold/2
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  let d = imageData.data; // raw pixel data in array
  let v = 0, l = 0, r, b, g
  for (var i=0; i<d.length; i+=4) {
    r = d[i];
    g = d[i+1];
    b = d[i+2];
    l = 0.2126*r + 0.7152*g + 0.0722*b
    v = 0
    if (l >= high)
      v = 255
    else
    if (l < low)
      v = 0
    else
      v = l
    d[i] = d[i+1] = d[i+2] = v
  }
  ctx.putImageData(imageData, 0, 0);
}

function threshold (L) {
  if (document.getElementById("opacity").value == 100) {
    alert("Opacity is set to 100%.")
  }
  let threshold = document.getElementById("opacity").value *2.55
  if (L)
    threshold = L
  let canvas = document.getElementById("myCanvas");
  let ctx = canvas.getContext("2d");
  let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  let d = imageData.data; // raw pixel data in array
  for (var i=0; i<d.length; i+=4) {
    var r = d[i];
    var g = d[i+1];
    var b = d[i+2];
    var v = (0.2126*r + 0.7152*g + 0.0722*b >= threshold) ? 255 : 0;
    d[i] = d[i+1] = d[i+2] = v
  }
  ctx.putImageData(imageData, 0, 0);
}

function randomKernel () {
  let wts = [0,1,2,3,4,5,1/2]
  let sum = 0, i = 0
  let k = []
  for (; i < 9; i++) {
    k.push(randomPick(wts) * Math.floor(2*(Math.random() - 0.5)))
    sum += k[i]
  }
  if (sum != 0) {
    let sum2 = 0
    i = 0
    for (; i < 9; i++) {
      k[i] /= sum
      sum2 += k[i]
    }
  }
  return k
}

function randomConvolution () {
  let k = randomKernel()
  convolutionMatrix(k, 0)
}

function gaussianBlur () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let data = ctx.getImageData(0,0,canvas.width,canvas.height)
  let px = data.data
  let tmpPx = new Uint8ClampedArray(px.length)
  tmpPx.set(px)
  let i = 0, len= px.length
  for (; i < len; i++) {
     if (i % 4 === 3) {continue;}
     px[i] = ( tmpPx[i]
        + (tmpPx[i - 4] || tmpPx[i])
        + (tmpPx[i + 4] || tmpPx[i])
        + (tmpPx[i - 4 * data.width] || tmpPx[i])
        + (tmpPx[i + 4 * data.width] || tmpPx[i])
        + (tmpPx[i - 4 * data.width - 4] || tmpPx[i])
        + (tmpPx[i + 4 * data.width + 4] || tmpPx[i])
        + (tmpPx[i + 4 * data.width - 4] || tmpPx[i])
        + (tmpPx[i - 4 * data.width + 4] || tmpPx[i])
        )/9
  };
  ctx.putImageData(data,0,0)
  delete tmpPx
  
}

function shiftRightCanvas () {
  let canvas = document.getElementById("myCanvas")
  let k = [1,0,0,
           1,0,0,
           1,0,0]
  convolutionMatrix(k, 0, canvas, 3)
}

function blurCanvas (canvas) {
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  let k = [1,1,1,1,1,1,1,1,1]
  convolutionMatrix(k, 0, canvas, 9)
}

function embossCanvas () {
  let k = [[-1,-1,-1,
           -1,1,1,
            1,1,1],
          
          [1,1,1,
           1,1,-1,
         - 1,-1,-1],
           
          [-1,-1,1,
           -1,1,1,
           -1,1,1],
          
          [1,1,-1,
           1,1,-1,
           1,-1,-1]
        ]
            
    convolutionMatrix(randomPick(k), 0)
}

function sharpen2 (PUSH) {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let mode = document.getElementById("mode").value
  let opacity = document.getElementById("opacity").value
  ctx.globalAlpha = 1.0
  document.getElementById("mode").value = "source-over"
  clearOff()
  copyToOff()
  shrinkBlur()
  document.getElementById("mode").value = "difference"
  ctx.globalCompositeOperation = "difference"
  //document.getElementById("opacity").value = 100
  pasteFromOff()
  // unsharp mask ready
//return
  //swapWithOff()
  pasteFromOff()
  document.getElementById("mode").value = mode
  document.getElementById("opacity").value = opacity
  ctx.globalAlpha = opacity/100
  if (PUSH)
    pushFunction("sharpen2", )
}

function sharpenCanvas () {
  let k = [0,-1, 0,
          -1, 5,-1,
           0,-1, 0]
    if (Math.random() > 0.5)
      k = [-1,0,-1,
            0,5, 0,
           -1,0,-1]
  convolutionMatrix(k, 0)
}

function edgeCanvas () {
  let k = [0,1,0,
           1,-4,1,
           0,1,0]
    convolutionMatrix(k, 0)
    invertColors()
    return true
}

function blur2Canvas () {
  let canvas = document.getElementById("myCanvas");
  let k = [1, 2, 1,
           2, 4, 2,
           1, 2, 1]
    convolutionMatrix(k, 0, canvas, 16)
}

function identityCanvas () {
  let k = [0,0,0,
           0,1,0,
           0,0,0]
    convolutionMatrix(k, 0)
}

function convolutionMatrix (kernel, offset, canvas, div) {
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  if (!div)
    div = 1
  let i = 0
  let ctx = canvas.getContext("2d")
  let input = ctx.getImageData(0, 0, canvas.width, canvas.height)
  let output = ctx.createImageData(input)
  let w = input.width, h = input.height
  let iD = input.data, oD = output.data
  for (let y = 1; y < h - 1; y += 1) {
    for (let x = 1; x < w - 1; x += 1) {
      for (let c = 0; c < 3; c += 1) {
        i = (y * w + x) * 4 + c
        oD[i] = offset +
        (kernel[0] * iD[i - w * 4 - 4] +
          kernel[1] * iD[i - w * 4] +
          kernel[2] * iD[i - w * 4 + 4] +
          kernel[3] * iD[i - 4] +
          kernel[4] * iD[i] +
          kernel[5] * iD[i + 4] +
          kernel[6] * iD[i + w * 4 - 4] +
          kernel[7] * iD[i + w * 4] +
          kernel[8] * iD[i + w * 4 + 4])/div
      }
      oD[(y * w + x) * 4 + 3] = 255
    }
  }
  ctx.putImageData(output, 0, 0)
}

function blurAlpha () {
  canvas = document.getElementById("myCanvas")
  let k = [1,1,1,1,1,1,1,1,1]
  convolutionMatrixA(k, 0, canvas, 9)
}

function convolutionMatrixA (kernel, offset, canvas, div) {
  if (!canvas)
    canvas = document.getElementById("myCanvas")
  if (!div)
    div = 1
  let i = 0
  let ctx = canvas.getContext("2d")
  let input = ctx.getImageData(0, 0, canvas.width, canvas.height)
  let output = ctx.createImageData(input)
  let w = input.width, h = input.height
  let iD = input.data, oD = output.data
  for (let y = 1; y < h - 1; y += 1) {
    for (let x = 1; x < w - 1; x += 1) {
      for (let c = 0; c < 4; c += 1) {
        i = (y * w + x) * 4 + c
        if (c === 3)
          oD[i] = offset +
          (kernel[0] * iD[i - w * 4 - 4] +
          kernel[1] * iD[i - w * 4] +
          kernel[2] * iD[i - w * 4 + 4] +
          kernel[3] * iD[i - 4] +
          kernel[4] * iD[i] +
          kernel[5] * iD[i + 4] +
          kernel[6] * iD[i + w * 4 - 4] +
          kernel[7] * iD[i + w * 4] +
          kernel[8] * iD[i + w * 4 + 4])/div
        else
          oD[i] = offset + kernel[4] * iD[i]
      }
    }
  }
  ctx.putImageData(output, 0, 0)
}

function sobel () {
  let canvas = document.getElementById("myCanvas")
  let ctx = canvas.getContext("2d")
  let imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height)
  let pixels = imageData.data
  let i = 0
  let data = imageData.data
  let width = imageData.width;
  let height = imageData.height;
   const kernelX = [
    [-1,0,1],
    [-2,0,2],
    [-1,0,1]
  ];
  const kernelY = [
    [-1,-2,-1],
    [0,0,0],
    [1,2,1]
  ];
  let sobelData = [];
  let grayscaleData = [];
  function bindPixelAt(data) {
    return function(x, y, i) {
      i = i || 0;
      return data[((width * y) + x) * 4 + i];
    };
  }
  let pixelAt = bindPixelAt(data);
  let x, y;
  for (y = 0; y < height; y++) {
    for (x = 0; x < width; x++) {
      var r = pixelAt(x, y, 0);
      var g = pixelAt(x, y, 1);
      var b = pixelAt(x, y, 2);
      var avg = (r + g + b) / 3;
      grayscaleData.push(avg, avg, avg, 255);
    }
  }
  pixelAt = bindPixelAt(grayscaleData);
  for (y = 0; y < height; y++) {
    for (x = 0; x < width; x++) {
      let pixelX = (
        (kernelX[0][0] * pixelAt(x - 1, y - 1)) +
        (kernelX[0][1] * pixelAt(x, y - 1)) +
        (kernelX[0][2] * pixelAt(x + 1, y - 1)) +
        (kernelX[1][0] * pixelAt(x - 1, y)) +
        (kernelX[1][1] * pixelAt(x, y)) +
        (kernelX[1][2] * pixelAt(x + 1, y)) +
        (kernelX[2][0] * pixelAt(x - 1, y + 1)) +
        (kernelX[2][1] * pixelAt(x, y + 1)) +
        (kernelX[2][2] * pixelAt(x + 1, y + 1))
      );
      let pixelY = (
        (kernelY[0][0] * pixelAt(x - 1, y - 1)) +
        (kernelY[0][1] * pixelAt(x, y - 1)) +
        (kernelY[0][2] * pixelAt(x + 1, y - 1)) +
        (kernelY[1][0] * pixelAt(x - 1, y)) +
        (kernelY[1][1] * pixelAt(x, y)) +
        (kernelY[1][2] * pixelAt(x + 1, y)) +
        (kernelY[2][0] * pixelAt(x - 1, y + 1)) +
        (kernelY[2][1] * pixelAt(x, y + 1)) +
        (kernelY[2][2] * pixelAt(x + 1, y + 1))
      );
      let magnitude = Math.sqrt((pixelX * pixelX) + (pixelY * pixelY))>>>0;
      sobelData.push(magnitude, magnitude, magnitude, 255);
    }
  }
  let clampedArray = sobelData;
  clampedArray = new Uint8ClampedArray(sobelData);
  ctx.putImageData(toImageData(clampedArray,width,height), 0, 0)
  invertColors()
  return true
}

function toImageData(data, width, height) {
  if (typeof ImageData === 'function' && Object.prototype.toString.call(data) === '[object Uint16Array]') {
    return new ImageData(data, width, height);
  } else {
    if (typeof window === 'object' && typeof window.document === 'object') {
      var canvas = document.createElement('canvas');
      if (typeof canvas.getContext === 'function') {
        var context = canvas.getContext('2d');
        var imageData = context.createImageData(width, height);
        imageData.data.set(data);
        return imageData;
      } else {
        return new FakeImageData(data, width, height);
      }
    } else {
      return new FakeImageData(data, width, height);
    }
  }
};

function FakeImageData(data, width, height) {
  return {
    width: width,
    height: height,
    data: data
  };
}

let placenames_stars = ["XO-5", "θ1 Eridani A", "α Eridani A", "η Cassiopeiae A", "β1 Scorpii Aa", "α Crucis Aa", "α Cancri Aa", "ζ Leonis Aa", "ε Canis Majoris A", "ξ Andromedae", "ε Tauri Aa1", "ν1 Sagittarii A", "η Lyrae Aa", "γ Andromedae", "HD 168746", "μ Lyrae", "π Sagittarii A", "ε Aquarii", "β1 Cygni Aa", "α Corvi", "80 Ursae Majoris Ca", "η Tauri A", "α Tauri", "α Cephei", "γ Gruis", "ζ Draconis A", "ε Delphini", "β Cephei Aa", "α2 Capricorni", "γ Pegasi", "γ1 Leonis", "β Persei Aa1", "δ Corvi A", "γ Geminorum Aa", "ε Ursae Majoris A", "ε Cygni Aa", "η Ursae Majoris", "ρ2 Cephei", "μ1 Boötis Aa", "κ Ursae Majoris A", "υ Pegasi", "α Crateris", "ε Aurigae", "γ Andromedae A", "κ Leonis", "α Gruis", "γ2 Sagittarii", "ε Orionis", "ζ Orionis Aa", "σ Scorpii Aa1", "α Hydrae", "α Coronae Borealis", "α Andromedae Aa", "η Piscium A", "μ Draconis A", "α Piscium A", "HD 161693", "σ Draconis", "31 Lyncis", "δ Velorum Aa", "β Aquilae A", "ν Capricorni A", "α Aquilae", "δ Draconis", "λ Leonis", "η Canis Majoris", "ξ Ursae Majoris Aa", "ν Ursae Majoris", "θ1 Serpentis A", "ξ Geminorum", "HD 43197", "WASP-34", "WASP-52", "θ Aquarii", "τ2 Eridani", "HD 102956", "α Phoenicis", "α Vulpeculae", "α Scorpii A", "HD 131496", "α Boötis", "β2 Sagittarii", "β1 Sagittarii", "α Leporis A", "ζ Sagittarii A", "δ Cancri Aa", "γ Cancri Aa", "ε Hydrae A", "θ Boötis", "ι Boötis", "κ Boötis", "ι Carinae", "21 Tauri A", "WASP-64", "η Draconis A", "ο Persei A", "27 Tauri Aa1", "α Trianguli Australis", "ε Carinae A", "HD 224693", "HD 18742", "π1 Cygni", "η Eridani", "ξ Puppis", "8 Ursae Minoris", "V2500 Ophiuchi", "ζ Ceti Aa", "υ3 Eridani", "ο1 Eridani", "HD 181342", "HD 8574", "γ Orionis", "HAT-P-15", "α Orionis Aa", "41 Arietis Aa", "HD 86081", "θ Pegasi", "HD 206610", "δ Arietis", "σ Librae A", "HD 38283", "HD 16175", "ξ Aquarii A", "α Carinae A", "α Aurigae Aa", "β Cassiopeiae A", "α Geminorum Aa", "υ2 Cassiopeiae", "β Ophiuchi", "HD 63454", "16 Tauri", "μ Arae", "47 Ursae Majoris", "θ2 Tauri Aa", "WASP-50", "β Canum Venaticorum Aa", "HAT-P-5", "HD 192699", "θ Leonis", "HD 1502", "HD 52265", "HD 4208", "55 Cancri A", "α2 Canum Venaticorum Aa", "ω Herculis A", "β Eridani", "β1 Capricorni Aa", "α Fornacis A", "α Cygni", "δ Capricorni Aa", "β Leonis", "α Comae Berenices A", "HD 96063", "β Ceti", "WASP-17", "WASP-72", "HD 117618", "HAT-P-3", "δ Scorpii A", "α Ursae Majoris A", "ψ1 Draconis A", "HD 218566", "ι Draconis", "17 Tauri", "φ Virginis A", "θ Columbae", "β Tauri Aa", "γ Draconis", "HD 7199", "ε Pegasi", "γ Cephei Aa", "42 Draconis A", "π Scorpii Aa", "δ Cygni A", "HD 85951", "BD−17 63", "HD 102195", "α Piscis Austrini A", "HD 100655", "HAT-P-14", "ζ Cassiopeiae", "HD 109246", "β Piscium", "ζ Canis Majoris Aa", "G Scorpii", "γ Crucis", "HD 73534", "μ Cephei", "λ Draconis", "γ Corvi A", "ε Crucis", "WASP-13", "β Canis Minoris A", "ξ Scorpii", "ξ Draconis A", "κ Serpentis", "HD 179949", "36 Ophiuchi A", "β Centauri Aa", "η Aurigae", "α Arietis", "ι Aurigae", "ι Orionis Aa", "51 Pegasi", "ζ Virginis A", "HD 28678", "ζ Pegasi A", "HAT-P-38", "HD 98219", "HAT-P-2", "ρ Scorpii Aa", "HD 82886", "δ Crucis", "41 Lyncis", "HD 156411", "HD 20868", "WASP-38", "HD 208487", "ε Boötis A", "ν Scorpii Aa", "ο Geminorum", "γ Ceti A", "α Lupi", "HD 83443", "HD 145457", "κ Virginis", "HD 137388", "ε Sagittarii A", "λ Sagittarii", "δ Sagittarii", "HD 175541", "β Lupi", "ο2 Eridani A", "λ Virginis A", "α Equulei A", "β Ursae Minoris", "HIP 12961", "XO-4", "β Herculis Aa", "β Corvi", "ν Draconis", "ξ Cephei Aa", "Y Canum Venaticorum", "ε Scorpii", "HAT-P-42", "υ Scorpii", "ξ Aquilae A", "PSR B1257+12", "HD 118203", "39 Arietis", "HD 212771", "HD 45350", "HD 45652", "λ Herculis", "HD 93083", "HD 32518", "θ Aurigae A", "HD 152581", "20 Tauri", "WASP-39", "θ Cassiopeiae", "λ Ophiuchi A", "α Pegasi", "κ Velorum", "WASP-6", "κ Herculis A", "η Pegasi Aa", "HAT-P-21", "ε Geminorum", "δ Ursae Majoris", "λ Orionis A", "ζ Geminorum Aa", "ε Cancri Aa", "β Aurigae Aa", "α Ceti", "θ Centauri", "ξ Persei", "β Ursae Majoris", "38 Boötis", "α Coronae Australis", "23 Tauri Aa", "γ1 Arietis A", "β Carinae", "β Crucis", "σ Hydrae", "δ Virginis", "δ Orionis Aa", "ο Ceti Aa", "β Andromedae", "η Persei A", "α Persei", "β Canis Majoris", "κ Persei Aa", "ζ Ursae Majoris Aa", "XO-1", "HD 130322", "WASP-79", "WASP-60", "HAT-P-23", "α Trianguli", "HD 30856", "WASP-71", "γ Canis Majoris", "η Boötis Aa", "ο Ursae Majoris A", "18 Delphini", "HAT-P-29", "ξ Cancri A", "WASP-62", "ζ Puppis", "γ1 Sagittarii A", "γ Capricorni A", "HD 68988", "HD 85390", "γ Cassiopeiae", "β Boötis", "51 Andromedae", "HD 6434", "HD 49674", "β Leporis A", "HD 136418", "HD 48265", "σ Sagittarii Aa", "β Coronae Borealis A", "HD 17156", "WASP-15", "HD 149026", "ζ Aquilae A", "τ Scorpii A", "WASP-32", "α Pavonis Aa", "WASP-80", "α Columbae", "γ Ursae Majoris Aa", "γ Ursae Minoris", "HD 192263", "λ Cancri", "HD 164604", "TrES-3", "μ2 Scorpii A", "28 Tauri Aa", "HD 221287", "α Ursae Minoris", "σ Octantis", "μ Sagittarii Aa", "β Geminorum", "γ Virginis A", "46 Leonis Minoris", "γ Tauri A", "α Canis Minoris A", "η Geminorum A", "α Centauri C", "ε Eridani", "HD 153950", "μ Leonis", "α1 Herculis Aa", "α Ophiuchi A", "β Draconis A", "γ Velorum", "α Leonis A", "ζ Piscium A", "β Orionis A", "α Centauri A", "HD 149143", "β Delphini A", "δ Cassiopeiae Aa", "α Sagittarii", "η Ophiuchi A", "ζ Aurigae A", "γ Aquarii Aa", "μ Pegasi", "α Aquarii A", "β Aquarii A", "γ Cygni A", "HD 100777", "κ Orionis", "τ Pegasi", "HD 205739", "HAT-P-34", "θ Scorpii A", "δ Herculis Aa", "θ Ursae Majoris", "53 Eridani A", "β Pegasi", "α Cassiopeiae", "δ Tauri Aa", "ε Cassiopeiae", "γ Boötis Aa", "α Sagittae", "HD 99109", "HIP 79431", "λ Scorpii Aa", "β Lyrae Aa1", "β Arietis A", "HD 181720", "α Canis Majoris A", "κ Aquarii A", "δ Aquarii A", "BD+14 4559", "α Virginis Aa", "HAT-P-6", "HD 75898", "α Delphini Aa", "ο Leonis Aa", "λ Velorum", "γ Lyrae", "ι Virginis", "π3 Orionis", "HAT-P-40", "χ Ursae Majoris", "8 Draconis", "ι Ursae Majoris Aa", "WASP-21", "μ Ursae Majoris A", "λ Ursae Majoris A", "HD 63765", "γ Aquilae", "β Cancri A", "19 Tauri Aa", "ζ1 Cancri A", "μ Geminorum Aa", "ω Sagittarii A", "HAT-P-9", "υ Orionis", "υ2 Eridani", "α Draconis A", "β Gruis", "ζ Tauri A", "7 Draconis", "HD 148427", "WASP-161", "υ Andromedae A", "WASP-22", "α Centauri B", "HD 104985", "ο Piscium A", "HAT-P-36", "HD 108147", "HD 23079", "ρ Puppis A", "ι Hydrae", "HD 102117", "α Serpentis", "σ Canis Majoris", "HD 231701", "α Lyrae", "14 Andromedae A", "ε Virginis", "δ Geminorum Aa", "β Columbae", "δ Canis Majoris Aa", "ζ Phoenicis Aa", "μ1 Scorpii Aa", "HD 173416", "λ Boötis", "ε Ophiuchi", "δ Ophiuchi", "δ Ursae Minoris", "η Virginis Aa", "γ Eridani", "β Virginis", "υ1 Hydrae A", "ζ Eridani Aa", "δ Leonis", "α2 Librae Aa", "γ Librae A", "β Librae", "Phalacrocorax carbo", "Phalacrocorax urile", "Phalacrocorax pelagicus", "Egretta rufescens", "Egretta tricolor", "Egretta caerulea", "Egretta garzetta", "Egretta gularis", "Egretta thula", "Egretta eulophotes", "Ardea cinerea", "Ardea herodias", "Bubulcus ibis", "Ardeola bacchus", "Butorides striatus", "Butorides virescens", "Nyctanassa violacea", "Nycticorax nycticorax", "Ixobrychus sinensis", "Ixobrychus exilis", "Botaurus lentiginosus", "Phoenicopterus ruber", "Eudocimus albus", "Eudocimus ruber", "Plegadis falcinellus", "Plegadis chihi", "Ajaia ajaja", "Pelecanus erythrorhynchos", "Pelecanus occidentalis", "Coragyps atratus", "Cathartes aura", "Gymnogyps californianus", "Mycteria americana", "Jabiru mycteria", "Fregata magnificens", "Fregata minor", "Gavia stellata", "Gavia arctica", "Gavia pacifica", "Gavia immer", "Gavia adamsii", "Fulmarus glacialis", "Daption capense", "Pterodroma inexpectata", "Pterodroma cookii", "Pterodroma longirostris", "Pterodroma ultima", "Pterodroma macroptera", "Pterodroma feae", "Pterodroma hasitata", "Bulweria bulwerii", "Procellaria aequinoctialis", "Calonectris diomedea", "Puffinus pacificus", "Puffinus bulleri", "Puffinus carneipes", "Puffinus creatopus", "Puffinus gravis", "Puffinus griseus", "Puffinus tenuirostris", "Puffinus puffinus", "Puffinus opisthomelas", "Puffinus lherminieri", "Puffinus assimilis", "Diomedea exulans", "Oceanites oceanicus", "Pelagodroma marina", "Fregetta tropica", "Oceanodroma microsoma", "Oceanodroma tethys", "Oceanodroma castro", "Oceanodroma leucorhoa", "Oceanodroma melania", "Oceanodroma homochroa", "Oceanodroma hornbyi", "Oceanodroma furcata", "Camptostoma imberbe", "Myiopagis viridicata", "Mitrephanes phaeocercus", "Contopus pertinax", "Contopus sordidulus", "Contopus virens", "Contopus caribaeus", "Empidonax flaviventris", "Empidonax virescens", "Empidonax alnorum", "Empidonax traillii", "Empidonax minimus", "Empidonax hammondii", "Empidonax wrightii", "Empidonax oberholseri", "Empidonax difficilis", "Empidonax occidentalis", "Empidonax fulvifrons", "Sayornis phoebe", "Sayornis saya", "Sayornis nigricans", "Pyrocephalus rubinus", "Myiarchus tuberculifer", "Myiarchus cinerascens", "Myiarchus nuttingi", "Myiarchus crinitus", "Myiarchus tyrannulus", "Myiarchus sagrae", "Tyrannus melancholicus", "Tyrannus couchii", "Tyrannus vociferans", "Tyrannus crassirostris", "Tyrannus verticalis", "Tyrannus forficatus", "Tyrannus savana", "Tyrannus tyrannus", "Tyrannus dominicensis", "Empidonomus varius", "Myiodynastes luteiventris", "Myiozetetes similis", "Legatus leucophaius", "Pitangus sulphuratus", "Pachyramphus aglaiae", "Tityra semifasciata", "Lanius cristatus", "Lanius ludovicianus", "Lanius excubitor", "Vireo bellii", "Vireo atricapillus", "Vireo huttoni", "Vireo griseus", "Vireo crassirostris", "Vireo vicinior", "Vireo cassinii", "Vireo plumbeus", "Vireo solitarius", "Vireo flavifrons", "Vireo philadelphicus", "Vireo olivaceus", "Vireo flavoviridis", "Vireo altiloquus", "Vireo magister", "Vireo gilvus", "Gymnorhinus cyanocephalus", "Cyanocitta cristata", "Cyanocitta stelleri", "Aphelocoma insularis", "Aphelocoma californica", "Aphelocoma coerulescens", "Aphelocoma ultramarina", "Cyanocorax yncas", "Psilorhinus morio", "Perisoreus canadensis", "Pica pica", "Pica nuttalli", "Nucifraga columbiana", "Corvus monedula", "Corvus caurinus", "Corvus brachyrhynchos", "Corvus ossifragus", "Corvus imparatus", "Corvus cryptoleucus", "Corvus corax", "Lalage leucomela", "Ptilogonys cinereus", "Phainopepla nitens", "Bombycilla garrulus", "Bombycilla cedrorum", "Cinclus mexicanus", "Zoothera naevia", "Zoothera pinicola", "Sialia sialis", "Sialia mexicana", "Sialia currucoides", "Myadestes townsendi", "Myadestes occidentalis", "Catharus gracilirostris", "Catharus aurantiirostris", "Catharus fuscescens", "Catharus minimus", "Catharus ustulatus", "Catharus guttatus", "Hylocichla mustelina", "Turdus obscurus", "Turdus naumanni", "Turdus pilaris", "Turdus iliacus", "Turdus grayi", "Turdus rufopalliatus", "Turdus migratorius", "Muscicapa striata", "Muscicapa griseisticta", "Muscicapa sibirica", "Muscicapa dauurica", "Ficedula narcissina", "Ficedula mugimaki", "Ficedula parva", "Luscinia sibilans", "Luscinia calliope", "Luscinia svecica", "Luscinia cyane", "Tarsiger cyanurus", "Irania gutturalis", "Saxicola torquata", "Oenanthe oenanthe", "Sturnus vulgaris", "Acridotheres tristis", "Acridotheres grandis", "Dumetella carolinensis", "Melanoptila glabrirostris", "Melanotis caerulescens", "Mimus polyglottos", "Mimus gundlachii", "Oreoscoptes montanus", "Toxostoma rufum", "Toxostoma longirostre", "Toxostoma bendirei", "Toxostoma curvirostre", "Toxostoma lecontei", "Toxostoma redivivum", "Toxostoma crissale", "Sitta pygmaea", "Sitta pusilla", "Sitta canadensis", "Sitta carolinensis", "Certhia americana", "Campylorhynchus brunneicapillus", "Salpinctes obsoletus", "Catherpes mexicanus", "Cistothorus platensis", "Cistothorus palustris", "Thryomanes bewickii", "Thryothorus ludovicianus", "Troglodytes troglodytes", "Troglodytes aedon", "Auriparus flaviceps", "Polioptila caerulea", "Polioptila californica", "Polioptila melanura", "Polioptila nigriceps", "Poecile carolinensis", "Poecile atricapillus", "Poecile gambeli", "Poecile sclateri", "Poecile cinctus", "Poecile hudsonicus", "Poecile rufescens", "Parus major", "Baeolophus wollweberi", "Baeolophus inornatus", "Baeolophus bicolor", "Baeolophus atricristatus", "Psaltriparus minimus", "Tachycineta bicolor", "Tachycineta albilinea", "Tachycineta thalassina", "Tachycineta cyaneoviridis", "Progne subis", "Progne cryptoleuca", "Progne chalybea", "Progne modesta", "Stelgidopteryx serripennis", "Riparia riparia", "Hirundo rustica", "Petrochelidon pyrrhonota", "Petrochelidon fulva", "Delichon urbica", "Regulus calendula", "Regulus satrapa", "Pycnonotus jocosus", "Locustella lanceolata", "Locustella ochotensis", "Phylloscopus trochilus", "Phylloscopus sibilatrix", "Phylloscopus fuscatus", "Phylloscopus proregulus", "Phylloscopus inornatus", "Phylloscopus borealis", "Chamaea fasciata", "Sylvia curruca", "Alauda arvensis", "Eremophila alpestris", "Passer domesticus", "Passer montanus", "Motacilla alba", "Motacilla lugens", "Motacilla citreola", "Motacilla flava", "Motacilla cinerea", "Anthus trivialis", "Anthus hodgsoni", "Anthus gustavi", "Anthus cervinus", "Anthus spinoletta", "Anthus rubescens", "Anthus spragueii", "Prunella montanella", "Ploceus golandi", "Peucedramus taeniatus", "Fringilla coelebs", "Fringilla montifringilla", "Carduelis sinica", "Carduelis spinus", "Carduelis pinus", "Carduelis tristis", "Carduelis psaltria", "Carduelis lawrencei", "Carduelis carduelis", "Carduelis hornemanni", "Carduelis flammea", "Leucosticte tephrocotis", "Leucosticte atrata", "Leucosticte australis", "Carpodacus purpureus", "Carpodacus erythrinus", "Carpodacus cassinii", "Carpodacus mexicanus", "Pinicola enucleator", "Loxia curvirostra", "Loxia leucoptera", "Pyrrhula pyrrhula", "Coccothraustes coccothraustes", "Hesperiphona vespertina", "Emberiza leucocephalos", "Emberiza pusilla", "Emberiza rustica", "Emberiza elegans", "Emberiza aureola", "Emberiza variabilis", "Emberiza pallasi", "Emberiza schoeniclus", "Calcarius mccownii", "Calcarius lapponicus", "Calcarius pictus", "Calcarius ornatus", "Plectrophenax nivalis", "Plectrophenax hyperboreus", "Calamospiza melanocorys", "Passerella iliaca", "Melospiza melodia", "Melospiza lincolnii", "Melospiza georgiana", "Zonotrichia querula", "Zonotrichia albicollis", "Zonotrichia leucophrys", "Zonotrichia atricapilla", "Junco hyemalis", "Junco phaeonotus", "Passerculus sandwichensis", "Ammodramus maritimus", "Ammodramus caudacutus", "Ammodramus leconteii", "Ammodramus henslowii", "Ammodramus bairdii", "Ammodramus savannarum", "Spizella arborea", "Spizella passerina", "Spizella pallida", "Spizella breweri", "Spizella pusilla", "Spizella wortheni", "Spizella atrogularis", "Pooecetes gramineus", "Chondestes grammacus", "Amphispiza bilineata", "Amphispiza belli", "Aimophila quinquestriata", "Aimophila aestivalis", "Aimophila botterii", "Aimophila cassinii", "Aimophila carpalis", "Aimophila ruficeps", "Pipilo chlorurus", "Pipilo erythrophthalmus", "Pipilo aberti", "Pipilo crissalis", "Pipilo fuscus", "Arremonops rufivirgatus", "Vermivora bachmanii", "Vermivora pinus", "Vermivora chrysoptera", "Vermivora peregrina", "Vermivora celata", "Vermivora ruficapilla", "Vermivora virginiae", "Vermivora crissalis", "Vermivora luciae", "Parula americana", "Parula pitiayumi", "Parula superciliosa", "Dendroica petechia", "Dendroica pensylvanica", "Dendroica magnolia", "Dendroica tigrina", "Dendroica caerulescens", "Dendroica coronata", "Dendroica nigrescens", "Dendroica townsendi", "Dendroica occidentalis", "Dendroica virens", "Dendroica chrysoparia", "Dendroica fusca", "Dendroica dominica", "Dendroica graciae", "Dendroica pinus", "Dendroica kirtlandii", "Dendroica discolor", "Dendroica palmarum", "Dendroica castanea", "Dendroica striata", "Dendroica cerulea", "Mniotilta varia", "Setophaga ruticilla", "Protonotaria citrea", "Helmitheros vermivorus", "Limnothlypis swainsonii", "Seiurus aurocapillus", "Seiurus noveboracensis", "Seiurus motacilla", "Oporornis formosus", "Oporornis agilis", "Oporornis philadelphia", "Oporornis tolmiei", "Geothlypis trichas", "Geothlypis nelsoni", "Geothlypis poliocephala", "Wilsonia citrina", "Wilsonia pusilla", "Wilsonia canadensis", "Cardellina rubrifrons", "Myioborus pictus", "Myioborus miniatus", "Euthlypis lachrymosa", "Basileuterus culicivorus", "Basileuterus rufifrons", "Icteria virens", "Coereba flaveola", "Piranga bidentata", "Piranga flava", "Piranga rubra", "Piranga olivacea", "Piranga ludoviciana", "Spindalis zena", "Poospiza lateralis", "Sporophila torqueola", "Tiaris olivacea", "Tiaris bicolor", "Spiza americana", "Pheucticus chrysopeplus", "Pheucticus ludovicianus", "Pheucticus melanocephalus", "Cardinalis cardinalis", "Cardinalis sinuatus", "Rhodothraupis celaeno", "Cyanocompsa parellina", "Guiraca caerulea", "Passerina amoena", "Passerina cyanea", "Passerina versicolor", "Passerina ciris", "Passerina rositae", "Icterus graduacauda", "Icterus pectoralis", "Icterus gularis", "Icterus pustulatus", "Icterus galbula", "Icterus cucullatus", "Icterus spurius", "Icterus wagleri", "Icterus parisorum", "Xanthocephalus xanthocephalus", "Agelaius cyanopus", "Agelaius phoeniceus", "Agelaius tricolor", "Agelaius humeralis", "Sturnella magna", "Sturnella neglecta", "Quiscalus mexicanus", "Quiscalus major", "Quiscalus quiscula", "Euphagus carolinus", "Euphagus cyanocephalus", "Molothrus bonariensis", "Molothrus aeneus", "Molothrus ater", "Dolichonyx oryzivorus", "Falcipennis canadensis", "Nomonyx dominica", "Branta hutchinsii", "Picoides dorsalis", "Tyto detorta", "Otus sunia", "Phalaropus tricolor", "Catharacta skua", "Catharacta maccormicki", "Larus brachyrhynchus", "Brachyramphus perdix", "Buteo nitidus", "Caracara plancus", "Caracara cheriway", "Sula granti", "Ardea alba", "Ardea intermedia", "Pterodroma heraldica", "Phoebastria albatrus", "Phoebastria nigripes", "Phoebastria immutabilis", "Thalassarche melanophris", "Thalassarche cauta", "Thalassarche chlororhynchos", "Contopus cooperi", "Cyanocorax luxuosus", "Catharus bicknelli", "Parus ridgwayi", "Progne tapera", "Ammodramus nelsoni", "Pipilo maculatus", "Icterus bullockii", "Icterus abeillei"]


let placenames = ["Elegant Crested-Tinamou", "Plain Chachalaca", "Himalayan Snowcock", "Rock Partridge", "Chukar", "Grey Partridge", "Common Quail", "Common Pheasant", "Indian Peafowl", "Dusky Grouse", "Sooty Grouse", "Willow Ptarmigan", "Rock Ptarmigan", "White-tailed Ptarmigan", "Ruffed Grouse", "Sage Grouse", "Gunnison Sage-Grouse", "Sharp-tailed Grouse", "Greater Prairie-chicken", "Lesser Prairie-chicken", "Wild Turkey", "Mountain Quail", "Scaled Quail", "California Quail", "Gambel's Quail", "Northern Bobwhite", "Montezuma Quail", "Fulvous Whistling-Duck", "Black-bellied Whistling-Duck", "Ruddy Duck", "Mute Swan", "Whooper Swan", "Trumpeter Swan", "Tundra Swan", "Pink-footed Goose", "Bean Goose", "Greater White-fronted Goose", "Lesser White-fronted Goose", "Snow Goose", "Ross's Goose", "Emperor Goose", "Canada Goose", "Barnacle Goose", "Brent Goose", "Muscovy Duck", "Wood Duck", "Gadwall", "Falcated Teal", "Eurasian Wigeon", "American Wigeon", "American Black Duck", "Mottled Duck", "Mallard", "Spot-billed Duck", "Blue-winged Teal", "Cinnamon Teal", "Red Shoveler", "Northern Shoveler", "White-cheeked Pintail", "Northern Pintail", "Garganey", "Baikal Teal", "Common Teal", "Common Pochard", "Canvasback", "Redhead", "Ring-necked Duck", "Tufted Duck", "Greater Scaup", "Lesser Scaup", "Common Eider", "King Eider", "Spectacled Eider", "Steller's Eider", "Labrador Duck", "Harlequin Duck", "Long-tailed Duck", "Black Scoter", "Surf Scoter", "White-winged Scoter", "Common Goldeneye", "Barrow's Goldeneye", "Bufflehead", "Smew", "Hooded Merganser", "Red-breasted Merganser", "Common Merganser", "Lark Buttonquail", "Eurasian Wryneck", "Lewis's Woodpecker", "Red-headed Woodpecker", "Acorn Woodpecker", "Gila Woodpecker", "Red-bellied Woodpecker", "Golden-fronted Woodpecker", "Yellow-bellied Sapsucker", "Red-naped Sapsucker", "Red-breasted Sapsucker", "Williamson's Sapsucker", "Great Spotted Woodpecker", "Nuttall's Woodpecker", "Ladder-backed Woodpecker", "Downy Woodpecker", "Red-cockaded Woodpecker", "Strickland's Woodpecker", "Hairy Woodpecker", "White-headed Woodpecker", "Three-toed Woodpecker", "Black-backed Woodpecker", "Northern Flicker", "Gilded Flicker", "Pileated Woodpecker", "Ivory-billed Woodpecker", "Eurasian Hoopoe", "Eared Trogon", "Elegant Trogon", "Belted Kingfisher", "Ringed Kingfisher", "Green Kingfisher", "Common Cuckoo", "Oriental Cuckoo", "Black-billed Cuckoo", "Yellow-billed Cuckoo", "Mangrove Cuckoo", "Dark-billed Cuckoo", "Smooth-billed Ani", "Groove-billed Ani", "Greater Roadrunner", "Budgerigar", "Green Parakeet", "Nanday Parakeet", "Thick-billed Parrot", "Carolina Parakeet", "Monk Parakeet", "Canary-winged Parakeet", "Red-crowned Parrot", "Black Swift", "White-collared Swift", "White-throated Needletail", "Chimney Swift", "Vaux's Swift", "White-throated Swift", "Antillean Palm-Swift", "Common Swift", "Fork-tailed Swift", "Green Violet-ear", "Green-breasted Mango", "Broad-billed Hummingbird", "Xantus's Hummingbird", "White-eared Hummingbird", "Berylline Hummingbird", "Cinnamon Hummingbird", "Buff-bellied Hummingbird", "Violet-crowned Hummingbird", "Blue-throated Hummingbird", "Magnificent Hummingbird", "Green-tailed Trainbearer", "Plain-capped Starthroat", "Lucifer Hummingbird", "Ruby-throated Hummingbird", "Black-chinned Hummingbird", "Anna's Hummingbird", "Costa's Hummingbird", "Calliope Hummingbird", "Bumblebee Hummingbird", "Broad-tailed Hummingbird", "Rufous Hummingbird", "Allen's Hummingbird", "Barn Owl", "Flammulated Owl", "Western Screech-Owl", "Eastern Screech-Owl", "Whiskered Screech-Owl", "Great Horned Owl", "Snowy Owl", "Spotted Owl", "Barred Owl", "Great Grey Owl", "Mottled Owl", "Northern Hawk Owl", "Northern Pygmy-Owl", "Mountain Pygmy-Owl", "Ferruginous Pygmy-Owl", "Elf Owl", "Spotted Owlet", "Burrowing Owl", "Boreal Owl", "Saw-whet Owl", "Stygian Owl", "Long-eared Owl", "Short-eared Owl", "Barred Owlet-Nightjar", "Lesser Nighthawk", "Common Nighthawk", "Antillean Nighthawk", "Pauraque", "Common Poorwill", "Chuck-will's-widow", "Buff-collared Nightjar", "Whip-poor-will", "Grey Nightjar", "Rock Dove", "White-crowned Pigeon", "Scaly-naped Pigeon", "Band-tailed Pigeon", "Red-billed Pigeon", "European Turtle-Dove", "Oriental Turtle-Dove", "Spotted Dove", "Eurasian Collared-Dove", "White-winged Collared-Dove", "Passenger Pigeon", "Mourning Dove", "Zenaida Dove", "White-winged Dove", "Inca Dove", "Common Ground-Dove", "Ruddy Ground-Dove", "White-tipped Dove", "Key West Quail-Dove", "Ruddy Quail-Dove", "Sandhill Crane", "Demoiselle Crane", "Common Crane", "Whooping Crane", "Limpkin", "Yellow Rail", "Black Rail", "Clapper Rail", "King Rail", "Virginia Rail", "Corn Crake", "Baillon's Crake", "Sora", "Hawaiian Crake", "Paint-billed Crake", "Spotted Rail", "Purple Swamphen", "Purple Gallinule", "Azure Gallinule", "Common Moorhen", "American Coot", "Eurasian Woodcock", "American Woodcock", "Pintail Snipe", "Common Snipe", "Jack Snipe", "Black-tailed Godwit", "Hudsonian Godwit", "Bar-tailed Godwit", "Marbled Godwit", "Little Curlew", "Eskimo Curlew", "Whimbrel", "Bristle-thighed Curlew", "Slender-billed Curlew", "Eurasian Curlew", "Long-billed Curlew", "Far Eastern Curlew", "Upland Sandpiper", "Spotted Redshank", "Common Redshank", "Marsh Sandpiper", "Common Greenshank", "Greater Yellowlegs", "Lesser Yellowlegs", "Solitary Sandpiper", "Green Sandpiper", "Wood Sandpiper", "Terek Sandpiper", "Common Sandpiper", "Spotted Sandpiper", "Grey-tailed Tattler", "Wandering Tattler", "Willet", "Ruddy Turnstone", "Black Turnstone", "Short-billed Dowitcher", "Long-billed Dowitcher", "Surfbird", "Great Knot", "Red Knot", "Sanderling", "Semipalmated Sandpiper", "Western Sandpiper", "Little Stint", "Red-necked Stint", "Temminck's Stint", "Long-toed Stint", "Least Sandpiper", "White-rumped Sandpiper", "Baird's Sandpiper", "Pectoral Sandpiper", "Sharp-tailed Sandpiper", "Purple Sandpiper", "Rock Sandpiper", "Dunlin", "Curlew Sandpiper", "Stilt Sandpiper", "Buff-breasted Sandpiper", "Spoonbill Sandpiper", "Broad-billed Sandpiper", "Ruff", "Red-necked Phalarope", "Red Phalarope", "Northern Jacana", "Double-striped Thick-knee", "Black Oystercatcher", "American Oystercatcher", "Black-winged Stilt", "Black Stilt", "Black-necked Stilt", "American Avocet", "European Golden-Plover", "Pacific Golden-Plover", "American Golden-Plover", "Grey Plover", "Common Ringed Plover", "Semipalmated Plover", "Little Ringed Plover", "Wilson's Plover", "Killdeer", "Piping Plover", "Kentish Plover", "Collared Plover", "Mongolian Plover", "Greater Sand Plover", "Mountain Plover", "Eurasian Dotterel", "Northern Lapwing", "Oriental Pratincole", "Rock Pratincole", "Pomarine Jaeger", "Parasitic Jaeger", "Long-tailed Jaeger", "Black Skimmer", "Band-tailed Gull", "Black-tailed Gull", "Heermann's Gull", "Common Gull", "Ring-billed Gull", "California Gull", "Great Black-backed Gull", "Kelp Gull", "Glaucous-winged Gull", "Western Gull", "Yellow-footed Gull", "Glaucous Gull", "Iceland Gull", "Herring Gull", "Slaty-backed Gull", "Yellow-legged Gull", "Lesser Black-backed Gull", "Great Black-headed Gull", "Grey-headed Gull", "Black-headed Gull", "Bonaparte's Gull", "Thayer's Gull", "Laughing Gull", "Franklin's Gull", "Little Gull", "Ivory Gull", "Ross's Gull", "Sabine's Gull", "Swallow-tailed Gull", "Black-legged Kittiwake", "Red-legged Kittiwake", "Gull-billed Tern", "Caspian Tern", "Royal Tern", "Elegant Tern", "Sandwich Tern", "Roseate Tern", "Common Tern", "Arctic Tern", "Forster's Tern", "Least Tern", "Aleutian Tern", "Bridled Tern", "Sooty Tern", "White-winged Tern", "Black Tern", "Large-billed Tern", "Brown Noddy", "Black Noddy", "Dovekie", "Common Murre", "Thick-billed Murre", "Razorbill", "Great Auk", "Black Guillemot", "Pigeon Guillemot", "Marbled Murrelet", "Kittlitz's Murrelet", "Xantus's Murrelet", "Craveri's Murrelet", "Ancient Murrelet", "Cassin's Auklet", "Parakeet Auklet", "Crested Auklet", "Whiskered Auklet", "Least Auklet", "Rhinoceros Auklet", "Atlantic Puffin", "Horned Puffin", "Tufted Puffin", "Osprey", "Hook-billed Kite", "Swallow-tailed Kite", "Black-shouldered Kite", "White-tailed Kite", "Snail Kite", "Rufous-thighed Kite", "Mississippi Kite", "White-tailed Eagle", "Bald Eagle", "Steller's Sea-Eagle", "Western Marsh-Harrier", "Northern Harrier", "Chinese Goshawk", "Sharp-shinned Hawk", "Cooper's Hawk", "Northern Goshawk", "Crane Hawk", "Common Black-Hawk", "Harris's Hawk", "Roadside Hawk", "Red-shouldered Hawk", "Broad-winged Hawk", "Short-tailed Hawk", "Swainson's Hawk", "White-tailed Hawk", "Zone-tailed Hawk", "Red-tailed Hawk", "Common Buzzard", "Ferruginous Hawk", "Rough-legged Hawk", "Golden Eagle", "Collared Forest-Falcon", "Common Kestrel", "American Kestrel", "Aplomado Falcon", "Merlin", "Eurasian Hobby", "Gyrfalcon", "Prairie Falcon", "Peregrine Falcon", "Least Grebe", "Pied-billed Grebe", "Red-necked Grebe", "Horned Grebe", "Black-necked Grebe", "Western Grebe", "Clark's Grebe", "Red-billed Tropicbird", "Red-tailed Tropicbird", "White-tailed Tropicbird", "Northern Gannet", "Blue-footed Booby", "Masked Booby", "Red-footed Booby", "Brown Booby", "Anhinga", "Brandt's Cormorant", "Neotropic Cormorant", "Double-crested Cormorant", "Great Cormorant", "Red-faced Cormorant", "Pelagic Cormorant", "Reddish Egret", "Tricolored Heron", "Little Blue Heron", "Little Egret", "Western Reef-Egret", "Snowy Egret", "Chinese Egret", "Grey Heron", "Great Blue Heron", "Cattle Egret", "Chinese Pond-Heron", "Striated Heron", "Green Heron", "Yellow-crowned Night-Heron", "Black-crowned Night-Heron", "Yellow Bittern", "Least Bittern", "American Bittern", "Greater Flamingo", "White Ibis", "Scarlet Ibis", "Glossy Ibis", "White-faced Ibis", "Roseate Spoonbill", "American White Pelican", "Brown Pelican", "Black Vulture", "Turkey Vulture", "California Condor", "Wood Stork", "Jabiru", "Magnificent Frigatebird", "Great Frigatebird", "Red-throated Loon", "Arctic Loon", "Pacific Loon", "Common Loon", "Yellow-billed Loon", "Northern Fulmar", "Cape Petrel", "Mottled Petrel", "Cook's Petrel", "Stejneger's Petrel", "Murphy's Petrel", "Great-winged Petrel", "Fea's Petrel", "Black-capped Petrel", "Bulwer's Petrel", "White-chinned Petrel", "Cory's Shearwater", "Wedge-tailed Shearwater", "Buller's Shearwater", "Flesh-footed Shearwater", "Pink-footed Shearwater", "Great Shearwater", "Sooty Shearwater", "Short-tailed Shearwater", "Manx Shearwater", "Black-vented Shearwater", "Audubon's Shearwater", "Little Shearwater", "Wandering Albatross", "Wilson's Storm-Petrel", "White-faced Storm-Petrel", "Black-bellied Storm-Petrel", "Least Storm-Petrel", "Wedge-rumped Storm-Petrel", "Band-rumped Storm-Petrel", "Leach's Storm-Petrel", "Black Storm-Petrel", "Ashy Storm-Petrel", "Ringed Storm-Petrel", "Fork-tailed Storm-Petrel", "Northern Beardless-Tyrannulet", "Greenish Elaenia", "Tufted Flycatcher", "Greater Pewee", "Western Wood-Pewee", "Eastern Wood-Pewee", "Cuban Pewee", "Yellow-bellied Flycatcher", "Acadian Flycatcher", "Alder Flycatcher", "Willow Flycatcher", "Least Flycatcher", "Hammond's Flycatcher", "Grey Flycatcher", "Dusky Flycatcher", "Pacific-slope Flycatcher", "Cordilleran Flycatcher", "Buff-breasted Flycatcher", "Eastern Phoebe", "Say's Phoebe", "Black Phoebe", "Vermilion Flycatcher", "Dusky-capped Flycatcher", "Ash-throated Flycatcher", "Nutting's Flycatcher", "Great Crested Flycatcher", "Brown-crested Flycatcher", "La Sagra's Flycatcher", "Tropical Kingbird", "Couch's Kingbird", "Cassin's Kingbird", "Thick-billed Kingbird", "Western Kingbird", "Scissor-tailed Flycatcher", "Fork-tailed Flycatcher", "Eastern Kingbird", "Grey Kingbird", "Variegated Flycatcher", "Sulphur-bellied Flycatcher", "Social Flycatcher", "Piratic Flycatcher", "Great Kiskadee", "Rose-throated Becard", "Masked Tityra", "Brown Shrike", "Loggerhead Shrike", "Northern Shrike", "Bell's Vireo", "Black-capped Vireo", "Hutton's Vireo", "White-eyed Vireo", "Thick-billed Vireo", "Grey Vireo", "Cassin's Vireo", "Plumbeous Vireo", "Blue-headed Vireo", "Yellow-throated Vireo", "Philadelphia Vireo", "Red-eyed Vireo", "Yellow-green Vireo", "Black-whiskered Vireo", "Yucatan Vireo", "Eastern Warbling-Vireo", "Pinyon Jay", "Blue Jay", "Steller's Jay", "Island Scrub-Jay", "Western Scrub-Jay", "Florida Scrub-Jay", "Mexican Jay", "Inca Jay", "Brown Jay", "Grey Jay", "Black-billed Magpie", "Yellow-billed Magpie", "Clark's Nutcracker", "Eurasian Jackdaw", "Northwestern Crow", "American Crow", "Fish Crow", "Tamaulipas Crow", "Chihuahuan Raven", "Common Raven", "Varied Triller", "Grey Silky-flycatcher", "Phainopepla", "Bohemian Waxwing", "Cedar Waxwing", "American Dipper", "Varied Thrush", "Aztec Thrush", "Eastern Bluebird", "Western Bluebird", "Mountain Bluebird", "Townsend's Solitaire", "Brown-backed Solitaire", "Black-billed Nightingale-Thrush", "Orange-billed Nightingale-Thrush", "Veery", "Grey-cheeked Thrush", "Swainson's Thrush", "Hermit Thrush", "Wood Thrush", "Eyebrowed Thrush", "Dusky Thrush", "Fieldfare", "Redwing", "Clay-colored Thrush", "Rufous-backed Thrush", "American Robin", "Spotted Flycatcher", "Grey-streaked Flycatcher", "Dark-sided Flycatcher", "Asian Brown Flycatcher", "Narcissus Flycatcher", "Mugimaki Flycatcher", "Red-breasted Flycatcher", "Rufous-tailed Robin", "Siberian Rubythroat", "Bluethroat", "Siberian Blue Robin", "Red-flanked Bluetail", "White-throated Robin", "Common Stonechat", "Northern Wheatear", "Common Starling", "Common Myna", "White-vented Myna", "Grey Catbird", "Black Catbird", "Blue Mockingbird", "Northern Mockingbird", "Bahama Mockingbird", "Sage Thrasher", "Brown Thrasher", "Long-billed Thrasher", "Bendire's Thrasher", "Curve-billed Thrasher", "Le Conte's Thrasher", "California Thrasher", "Crissal Thrasher", "Pygmy Nuthatch", "Brown-headed Nuthatch", "Red-breasted Nuthatch", "White-breasted Nuthatch", "Brown Creeper", "Cactus Wren", "Rock Wren", "Canyon Wren", "Sedge Wren", "Marsh Wren", "Bewick's Wren", "Carolina Wren", "Winter Wren", "House Wren", "Verdin", "Blue-grey Gnatcatcher", "California Gnatcatcher", "Black-tailed Gnatcatcher", "Black-capped Gnatcatcher", "Carolina Chickadee", "Black-capped Chickadee", "Mountain Chickadee", "Mexican Chickadee", "Siberian Tit", "Boreal Chickadee", "Chestnut-backed Chickadee", "Great Tit", "Bridled Titmouse", "Plain Titmouse", "Tufted Titmouse", "Black-crested Titmouse", "Bushtit", "Tree Swallow", "Mangrove Swallow", "Violet-green Swallow", "Bahama Swallow", "Purple Martin", "Cuban Martin", "Grey-breasted Martin", "Southern Martin", "Northern Rough-winged Swallow", "Sand Martin", "Barn Swallow", "Cliff Swallow", "Cave Swallow", "Northern House-Martin", "Ruby-crowned Kinglet", "Golden-crowned Kinglet", "Red-whiskered Bulbul", "Lanceolated Warbler", "Middendorff's Grasshopper-Warbler", "Willow Warbler", "Wood Warbler", "Dusky Warbler", "Pallas's Leaf-Warbler", "Inornate Warbler", "Arctic Warbler", "Wrentit", "Lesser Whitethroat", "Sky Lark", "Horned Lark", "House Sparrow", "Eurasian Tree Sparrow", "White Wagtail", "Black-backed Wagtail", "Citrine Wagtail", "Yellow Wagtail", "Grey Wagtail", "Tree Pipit", "Olive-backed Pipit", "Pechora Pipit", "Red-throated Pipit", "Water Pipit", "American Pipit", "Sprague's Pipit", "Siberian Accentor", "Clarke's Weaver", "Olive Warbler", "Chaffinch", "Brambling", "Grey-capped Greenfinch", "Eurasian Siskin", "Pine Siskin", "American Goldfinch", "Lesser Goldfinch", "Lawrence's Goldfinch", "European Goldfinch", "Hoary Redpoll", "Common Redpoll", "Grey-crowned Rosy-Finch", "Black Rosy-Finch", "Brown-capped Rosy-Finch", "Purple Finch", "Common Rosefinch", "Cassin's Finch", "House Finch", "Pine Grosbeak", "Red Crossbill", "White-winged Crossbill", "Eurasian Bullfinch", "Hawfinch", "Evening Grosbeak", "Pine Bunting", "Little Bunting", "Rustic Bunting", "Yellow-throated Bunting", "Yellow-breasted Bunting", "Grey Bunting", "Pallas's Bunting", "Reed Bunting", "McCown's Longspur", "Lapland Longspur", "Smith's Longspur", "Chestnut-collared Longspur", "Snow Bunting", "McKay's Bunting", "Lark Bunting", "Fox Sparrow", "Song Sparrow", "Lincoln's Sparrow", "Swamp Sparrow", "Harris's Sparrow", "White-throated Sparrow", "White-crowned Sparrow", "Golden-crowned Sparrow", "Dark-eyed Junco", "Yellow-eyed Junco", "Savannah Sparrow", "Seaside Sparrow", "Saltmarsh Sharp-tailed Sparrow", "Le Conte's Sparrow", "Henslow's Sparrow", "Baird's Sparrow", "Grasshopper Sparrow", "American Tree Sparrow", "Chipping Sparrow", "Clay-colored Sparrow", "Brewer's Sparrow", "Field Sparrow", "Worthen's Sparrow", "Black-chinned Sparrow", "Vesper Sparrow", "Lark Sparrow", "Black-throated Sparrow", "Sage Sparrow", "Five-striped Sparrow", "Bachman's Sparrow", "Botteri's Sparrow", "Cassin's Sparrow", "Rufous-winged Sparrow", "Rufous-crowned Sparrow", "Green-tailed Towhee", "Eastern Towhee", "Abert's Towhee", "California Towhee", "Canyon Towhee", "Olive Sparrow", "Bachman's Warbler", "Blue-winged Warbler", "Golden-winged Warbler", "Tennessee Warbler", "Orange-crowned Warbler", "Nashville Warbler", "Virginia's Warbler", "Colima Warbler", "Lucy's Warbler", "Northern Parula", "Tropical Parula", "Crescent-chested Warbler", "Yellow Warbler", "Chestnut-sided Warbler", "Magnolia Warbler", "Cape May Warbler", "Black-throated Blue Warbler", "Yellow-rumped Warbler", "Black-throated Grey Warbler", "Townsend's Warbler", "Hermit Warbler", "Black-throated Green Warbler", "Golden-cheeked Warbler", "Blackburnian Warbler", "Yellow-throated Warbler", "Grace's Warbler", "Pine Warbler", "Kirtland's Warbler", "Prairie Warbler", "Palm Warbler", "Bay-breasted Warbler", "Blackpoll Warbler", "Cerulean Warbler", "Black-and-white Warbler", "American Redstart", "Prothonotary Warbler", "Worm-eating Warbler", "Swainson's Warbler", "Ovenbird", "Northern Waterthrush", "Louisiana Waterthrush", "Kentucky Warbler", "Connecticut Warbler", "Mourning Warbler", "MacGillivray's Warbler", "Common Yellowthroat", "Hooded Yellowthroat", "Grey-crowned Yellowthroat", "Hooded Warbler", "Wilson's Warbler", "Canada Warbler", "Red-faced Warbler", "Painted Redstart", "Slate-throated Redstart", "Fan-tailed Warbler", "Golden-crowned Warbler", "Rufous-capped Warbler", "Yellow-breasted Chat", "Bananaquit", "Flame-colored Tanager", "Hepatic Tanager", "Summer Tanager", "Scarlet Tanager", "Westfern Tanager", "Stripe-headed Tanager", "Red-rumped Warbling-Finch", "White-collared Seedeater", "Yellow-faced Grassquit", "Black-faced Grassquit", "Dickcissel", "Yellow Grosbeak", "Rose-breasted Grosbeak", "Black-headed Grosbeak", "Northern Cardinal", "Pyrrhuloxia", "Crimson-collared Grosbeak", "Blue Bunting", "Blue Grosbeak", "Lazuli Bunting", "Indigo Bunting", "Varied Bunting", "Painted Bunting", "Rose-bellied Bunting", "Audubon's Oriole", "Spot-breasted Oriole", "Altamira Oriole", "Streak-backed Oriole", "Baltimore Oriole", "Hooded Oriole", "Orchard Oriole", "Black-vented Oriole", "Scott's Oriole", "Yellow-headed Blackbird", "Unicolored Blackbird", "Red-winged Blackbird", "Tricolored Blackbird", "Tawny-shouldered Blackbird", "Eastern Meadowlark", "Western Meadowlark", "Great-tailed Grackle", "Boat-tailed Grackle", "Common Grackle", "Rusty Blackbird", "Brewer's Blackbird", "Shiny Cowbird", "Bronzed Cowbird", "Brown-headed Cowbird", "Bobolink", "Spruce Grouse", "Masked Duck", "Tundra Goose", "American Three-toed Woodpecker", "Cape Verde Barn Owl", "Oriental Scops-Owl", "Wilson's Phalarope", "Great Skua", "South Polar Skua", "Mew Gull", "Long-billed Murrelet", "Grey-lined Hawk", "Southern Caracara", "Crested Caracara", "Nazca Booby", "Great Egret", "Intermediate Egret", "Herald Petrel", "Short-tailed Albatross", "Black-footed Albatross", "Laysan Albatross", "Black-browed Albatross", "Shy Albatross", "Yellow-nosed Albatross", "Olive-sided Flycatcher", "Green Jay", "Bicknell's Thrush", "Ridgway's Titmouse", "Brown-chested Martin", "Nelson's Sharp-tailed Sparrow", "Spotted Towhee", "Bullock's Oriole", "Black-backed Oriole"]

let placenames_ = ["Abaíra", "Abaré", "Acajutiba", "Adustina", "Água Fria", "Aiquara", "Alagoinhas", "Alcobaça", "Almadina", "Amargosa", "Amélia Rodrigues", "América Dourada", "Anagé", "Andaraí", "Andorinha", "Angical", "Anguera", "Antas", "Antônio Cardoso", "Antônio Gonçalves", "Aporá", "Apuarema", "Araçás", "Aracatu", "Araci", "Aramari", "Arataca", "Aratuípe", "Aurelino Leal", "Baianópolis", "Baixa Grande", "Banzaê", "Barra", "Barra da Estiva", "Barra do Choça", "Barra do Mendes", "Barra do Rocha", "Barreiras", "Barro Alto", "Barro Preto", "Barrocas", "Belmonte", "Belo Campo", "Biritinga", "Boa Nova", "Boa Vista do Tupim", "Bom Jesus da Lapa", "Bom Jesus da Serra", "Boninal", "Bonito", "Boquira", "Botuporã", "Brejões", "Brejolândia", "Brotas de Macaúbas", "Brumado", "Buerarema", "Buritirama", "Caatiba", "Cabaceiras do Paraguaçu", "Cachoeira", "Caculé", "Caém", "Caetanos", "Caetité", "Cafarnaum", "Cairu", "Caldeirão Grande", "Camacan", "Camaçari", "Camamu", "Campo Alegre de Lourdes", "Campo Formoso", "Canápolis", "Canarana", "Canavieiras", "Candeal", "Candeias", "Candiba", "Cândido Sales", "Cansanção", "Canudos", "Capela do Alto Alegre", "Capim Grosso", "Caraíbas", "Caravelas", "Cardeal da Silva", "Carinhanha", "Casa Nova", "Castro Alves", "Catolândia", "Catu", "Caturama", "Central", "Chorrochó", "Cícero Dantas", "Cipó", "Coaraci", "Cocos", "Conceição da Feira", "Conceição do Almeida", "Conceição do Coité", "Conceição do Jacuípe", "Conde", "Condeúba", "Contendas do Sincorá", "Coração de Maria", "Cordeiros", "Coribe", "Coronel João Sá", "Correntina", "Cotegipe", "Cravolândia", "Crisópolis", "Cristópolis", "Cruz das Almas", "Curaçá", "Dário Meira", "Dias d'Ávila", "Dom Basílio", "Dom Macedo Costa", "Elísio Medrado", "Encruzilhada", "Entre Rios", "Érico Cardoso", "Esplanada", "Euclides da Cunha", "Eunápolis", "Fátima", "Feira da Mata", "Feira de Santana", "Filadélfia", "Firmino Alves", "Floresta Azul", "Formosa do Rio Preto", "Gandu", "Gavião", "Gentio do Ouro", "Glória", "Gongogi", "Governador Mangabeira", "Guajeru", "Guanambi", "Guaratinga", "Heliópolis", "Iaçu", "Ibiassucê", "Ibicaraí", "Ibicoara", "Ibicuí", "Ibipeba", "Ibipitanga", "Ibiquera", "Ibirapitanga", "Ibirapuã", "Ibirataia", "Ibitiara", "Ibititá", "Ibotirama", "Ichu", "Igaporã", "Igrapiúna", "Iguaí", "Ilhéus", "Inhambupe", "Ipecaetá", "Ipiaú", "Ipirá", "Ipupiara", "Irajuba", "Iramaia", "Iraquara", "Irará", "Irecê", "Itabela", "Itaberaba", "Itabuna", "Itacaré", "Itaetê", "Itagi", "Itagibá", "Itagimirim", "Itaguaçu da Bahia", "Itaju do Colônia", "Itajuípe", "Itamaraju", "Itamari", "Itambé", "Itanagra", "Itanhém", "Itaparica", "Itapé", "Itapebi", "Itapetinga", "Itapicuru", "Itapitanga", "Itaquara", "Itarantim", "Itatim", "Itiruçu", "Itiúba", "Itororó", "Ituaçu", "Ituberá", "Iuiú", "Jaborandi", "Jacaraci", "Jacobina", "Jaguaquara", "Jaguarari", "Jaguaripe", "Jandaíra", "Jequié", "Jeremoabo", "Jiquiriçá", "Jitaúna", "João Dourado", "Juazeiro", "Jucuruçu", "Jussara", "Jussari", "Jussiape", "Lafaiete Coutinho", "Lagoa Real", "Laje", "Lajedão", "Lajedinho", "Lajedo do Tabocal", "Lamarão", "Lapão", "Lauro de Freitas", "Lençóis", "Licínio de Almeida", "Livramento de Nossa Senhora", "Luis Eduardo Magalhães", "Macajuba", "Macarani", "Macaúbas", "Macururé", "Madre de Deus", "Maetinga", "Maiquinique", "Mairi", "Malhada", "Malhada de Pedras", "Manoel Vitorino", "Mansidão", "Maracás", "Maragogipe", "Maraú", "Marcionílio Souza", "Mascote", "Mata de São João", "Matina", "Medeiros Neto", "Miguel Calmon", "Milagres", "Mirangaba", "Mirante", "Monte Santo", "Morpará", "Morro do Chapéu", "Mortugaba", "Mucugê", "Mucuri", "Mulungu do Morro", "Mundo Novo", "Muniz Ferreira", "Muquém de São Francisco", "Muritiba", "Mutuípe", "Nazaré", "Nilo Peçanha", "Nordestina", "Nova Canaã", "Nova Fátima", "Nova Ibiá", "Nova Itarana", "Nova Redenção", "Nova Soure", "Nova Viçosa", "Novo Horizonte", "Novo Triunfo", "Olindina", "Oliveira dos Brejinhos", "Ouriçangas", "Ourolândia", "Palmas de Monte Alto", "Palmeiras", "Paramirim", "Paratinga", "Paripiranga", "Pau Brasil", "Paulo Afonso", "Pé de Serra", "Pedrão", "Pedro Alexandre", "Piatã", "Pilão Arcado", "Pindaí", "Pindobaçu", "Pintadas", "Piraí do Norte", "Piripá", "Piritiba", "Planaltino", "Planalto", "Poções", "Pojuca", "Ponto Novo", "Porto Seguro", "Potiraguá", "Prado", "Presidente Dutra", "Presidente Jânio Quadros", "Presidente Tancredo Neves", "Queimadas", "Quijingue", "Quixabeira", "Rafael Jambeiro", "Remanso", "Retirolândia", "Riachão do Jacuípe", "Riacho de Santana", "Ribeira do Amparo", "Ribeira do Pombal", "Ribeirão do Largo", "Rio de Contas", "Rio do Antônio", "Rio do Pires", "Rio Real", "Rodelas", "Ruy Barbosa", "Salinas da Margarida", "Salvador", "Santa Bárbara", "Santa Brígida", "Santa Cruz Cabrália", "Santa Cruz da Vitória", "Santa Inês", "Santa Luzia", "Santa Maria da Vitória", "Santa Rita de Cássia", "Santa Teresinha", "Santaluz", "Santana", "Santanópolis", "Santo Amaro", "Santo Antônio de Jesus", "Santo Estêvão", "São Desidério", "São Domingos", "São Felipe", "São Félix", "São Félix do Coribe", "São Francisco do Conde", "São Gabriel", "São Gonçalo dos Campos", "São José da Vitória", "São José do Jacuípe", "São Miguel das Matas", "São Sebastião do Passé", "Sapeaçu", "Sátiro Dias", "Saubara", "Saúde", "Seabra", "Sebastião Laranjeiras", "Senhor do Bonfim", "Sento Sé", "Serra do Ramalho", "Serra Dourada", "Serra Preta", "Serrinha", "Serrolândia", "Simões Filho", "Sítio do Mato", "Sítio do Quinto", "Sobradinho", "Souto Soares", "Tabocas do Brejo Velho", "Tanhaçu", "Tanque Novo", "Tanquinho", "Taperoá", "Tapiramutá", "Teixeira de Freitas", "Teodoro Sampaio", "Teofilândia", "Teolândia", "Tremedal", "Tucano", "Uauá", "Ubaíra", "Ubaitaba", "Ubatã", "Uibaí", "Umburanas", "Una", "Urandi", "Uruçuca", "Utinga", "Valença", "Valente", "Várzea da Roça", "Várzea do Poço", "Várzea Nova", "Varzedo", "Vera Cruz", "Vereda", "Vitória da Conquista", "Wagner", "Wanderley", "Wenceslau Guimarães", "Xique-Xique"];


</script>
</body>
</html>